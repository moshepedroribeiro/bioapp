var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/@rails/actioncable/src/adapters.js
var adapters_default;
var init_adapters = __esm(() => {
  adapters_default = {
    logger: typeof console !== "undefined" ? console : undefined,
    WebSocket: typeof WebSocket !== "undefined" ? WebSocket : undefined
  };
});

// node_modules/@rails/actioncable/src/logger.js
var logger_default;
var init_logger = __esm(() => {
  init_adapters();
  logger_default = {
    log(...messages) {
      if (this.enabled) {
        messages.push(Date.now());
        adapters_default.logger.log("[ActionCable]", ...messages);
      }
    }
  };
});

// node_modules/@rails/actioncable/src/connection_monitor.js
class ConnectionMonitor {
  constructor(connection) {
    this.visibilityDidChange = this.visibilityDidChange.bind(this);
    this.connection = connection;
    this.reconnectAttempts = 0;
  }
  start() {
    if (!this.isRunning()) {
      this.startedAt = now();
      delete this.stoppedAt;
      this.startPolling();
      addEventListener("visibilitychange", this.visibilityDidChange);
      logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
    }
  }
  stop() {
    if (this.isRunning()) {
      this.stoppedAt = now();
      this.stopPolling();
      removeEventListener("visibilitychange", this.visibilityDidChange);
      logger_default.log("ConnectionMonitor stopped");
    }
  }
  isRunning() {
    return this.startedAt && !this.stoppedAt;
  }
  recordMessage() {
    this.pingedAt = now();
  }
  recordConnect() {
    this.reconnectAttempts = 0;
    delete this.disconnectedAt;
    logger_default.log("ConnectionMonitor recorded connect");
  }
  recordDisconnect() {
    this.disconnectedAt = now();
    logger_default.log("ConnectionMonitor recorded disconnect");
  }
  startPolling() {
    this.stopPolling();
    this.poll();
  }
  stopPolling() {
    clearTimeout(this.pollTimeout);
  }
  poll() {
    this.pollTimeout = setTimeout(() => {
      this.reconnectIfStale();
      this.poll();
    }, this.getPollInterval());
  }
  getPollInterval() {
    const { staleThreshold, reconnectionBackoffRate } = this.constructor;
    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
    const jitter = jitterMax * Math.random();
    return staleThreshold * 1000 * backoff * (1 + jitter);
  }
  reconnectIfStale() {
    if (this.connectionIsStale()) {
      logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
      this.reconnectAttempts++;
      if (this.disconnectedRecently()) {
        logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
      } else {
        logger_default.log("ConnectionMonitor reopening");
        this.connection.reopen();
      }
    }
  }
  get refreshedAt() {
    return this.pingedAt ? this.pingedAt : this.startedAt;
  }
  connectionIsStale() {
    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
  }
  disconnectedRecently() {
    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
  }
  visibilityDidChange() {
    if (document.visibilityState === "visible") {
      setTimeout(() => {
        if (this.connectionIsStale() || !this.connection.isOpen()) {
          logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
          this.connection.reopen();
        }
      }, 200);
    }
  }
}
var now, secondsSince, connection_monitor_default;
var init_connection_monitor = __esm(() => {
  init_logger();
  now = () => new Date().getTime();
  secondsSince = (time) => (now() - time) / 1000;
  ConnectionMonitor.staleThreshold = 6;
  ConnectionMonitor.reconnectionBackoffRate = 0.15;
  connection_monitor_default = ConnectionMonitor;
});

// node_modules/@rails/actioncable/src/internal.js
var internal_default;
var init_internal = __esm(() => {
  internal_default = {
    message_types: {
      welcome: "welcome",
      disconnect: "disconnect",
      ping: "ping",
      confirmation: "confirm_subscription",
      rejection: "reject_subscription"
    },
    disconnect_reasons: {
      unauthorized: "unauthorized",
      invalid_request: "invalid_request",
      server_restart: "server_restart",
      remote: "remote"
    },
    default_mount_path: "/cable",
    protocols: [
      "actioncable-v1-json",
      "actioncable-unsupported"
    ]
  };
});

// node_modules/@rails/actioncable/src/connection.js
class Connection {
  constructor(consumer) {
    this.open = this.open.bind(this);
    this.consumer = consumer;
    this.subscriptions = this.consumer.subscriptions;
    this.monitor = new connection_monitor_default(this);
    this.disconnected = true;
  }
  send(data) {
    if (this.isOpen()) {
      this.webSocket.send(JSON.stringify(data));
      return true;
    } else {
      return false;
    }
  }
  open() {
    if (this.isActive()) {
      logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
      return false;
    } else {
      const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
      logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
      if (this.webSocket) {
        this.uninstallEventHandlers();
      }
      this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
      this.installEventHandlers();
      this.monitor.start();
      return true;
    }
  }
  close({ allowReconnect } = { allowReconnect: true }) {
    if (!allowReconnect) {
      this.monitor.stop();
    }
    if (this.isOpen()) {
      return this.webSocket.close();
    }
  }
  reopen() {
    logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
    if (this.isActive()) {
      try {
        return this.close();
      } catch (error) {
        logger_default.log("Failed to reopen WebSocket", error);
      } finally {
        logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
        setTimeout(this.open, this.constructor.reopenDelay);
      }
    } else {
      return this.open();
    }
  }
  getProtocol() {
    if (this.webSocket) {
      return this.webSocket.protocol;
    }
  }
  isOpen() {
    return this.isState("open");
  }
  isActive() {
    return this.isState("open", "connecting");
  }
  triedToReconnect() {
    return this.monitor.reconnectAttempts > 0;
  }
  isProtocolSupported() {
    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
  }
  isState(...states) {
    return indexOf.call(states, this.getState()) >= 0;
  }
  getState() {
    if (this.webSocket) {
      for (let state in adapters_default.WebSocket) {
        if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
          return state.toLowerCase();
        }
      }
    }
    return null;
  }
  installEventHandlers() {
    for (let eventName in this.events) {
      const handler = this.events[eventName].bind(this);
      this.webSocket[`on${eventName}`] = handler;
    }
  }
  uninstallEventHandlers() {
    for (let eventName in this.events) {
      this.webSocket[`on${eventName}`] = function() {
      };
    }
  }
}
var message_types, protocols, supportedProtocols, indexOf, connection_default;
var init_connection = __esm(() => {
  init_adapters();
  init_connection_monitor();
  init_internal();
  init_logger();
  ({ message_types, protocols } = internal_default);
  supportedProtocols = protocols.slice(0, protocols.length - 1);
  indexOf = [].indexOf;
  Connection.reopenDelay = 500;
  Connection.prototype.events = {
    message(event) {
      if (!this.isProtocolSupported()) {
        return;
      }
      const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
      this.monitor.recordMessage();
      switch (type) {
        case message_types.welcome:
          if (this.triedToReconnect()) {
            this.reconnectAttempted = true;
          }
          this.monitor.recordConnect();
          return this.subscriptions.reload();
        case message_types.disconnect:
          logger_default.log(`Disconnecting. Reason: ${reason}`);
          return this.close({ allowReconnect: reconnect });
        case message_types.ping:
          return null;
        case message_types.confirmation:
          this.subscriptions.confirmSubscription(identifier);
          if (this.reconnectAttempted) {
            this.reconnectAttempted = false;
            return this.subscriptions.notify(identifier, "connected", { reconnected: true });
          } else {
            return this.subscriptions.notify(identifier, "connected", { reconnected: false });
          }
        case message_types.rejection:
          return this.subscriptions.reject(identifier);
        default:
          return this.subscriptions.notify(identifier, "received", message);
      }
    },
    open() {
      logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
      this.disconnected = false;
      if (!this.isProtocolSupported()) {
        logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
        return this.close({ allowReconnect: false });
      }
    },
    close(event) {
      logger_default.log("WebSocket onclose event");
      if (this.disconnected) {
        return;
      }
      this.disconnected = true;
      this.monitor.recordDisconnect();
      return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
    },
    error() {
      logger_default.log("WebSocket onerror event");
    }
  };
  connection_default = Connection;
});

// node_modules/@rails/actioncable/src/subscription.js
class Subscription {
  constructor(consumer, params = {}, mixin) {
    this.consumer = consumer;
    this.identifier = JSON.stringify(params);
    extend(this, mixin);
  }
  perform(action, data = {}) {
    data.action = action;
    return this.send(data);
  }
  send(data) {
    return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
  }
  unsubscribe() {
    return this.consumer.subscriptions.remove(this);
  }
}
var extend;
var init_subscription = __esm(() => {
  extend = function(object, properties) {
    if (properties != null) {
      for (let key in properties) {
        const value = properties[key];
        object[key] = value;
      }
    }
    return object;
  };
});

// node_modules/@rails/actioncable/src/subscription_guarantor.js
class SubscriptionGuarantor {
  constructor(subscriptions) {
    this.subscriptions = subscriptions;
    this.pendingSubscriptions = [];
  }
  guarantee(subscription) {
    if (this.pendingSubscriptions.indexOf(subscription) == -1) {
      logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
      this.pendingSubscriptions.push(subscription);
    } else {
      logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
    }
    this.startGuaranteeing();
  }
  forget(subscription) {
    logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
    this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
  }
  startGuaranteeing() {
    this.stopGuaranteeing();
    this.retrySubscribing();
  }
  stopGuaranteeing() {
    clearTimeout(this.retryTimeout);
  }
  retrySubscribing() {
    this.retryTimeout = setTimeout(() => {
      if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
        this.pendingSubscriptions.map((subscription) => {
          logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
          this.subscriptions.subscribe(subscription);
        });
      }
    }, 500);
  }
}
var subscription_guarantor_default;
var init_subscription_guarantor = __esm(() => {
  init_logger();
  subscription_guarantor_default = SubscriptionGuarantor;
});

// node_modules/@rails/actioncable/src/subscriptions.js
class Subscriptions {
  constructor(consumer) {
    this.consumer = consumer;
    this.guarantor = new subscription_guarantor_default(this);
    this.subscriptions = [];
  }
  create(channelName, mixin) {
    const channel = channelName;
    const params = typeof channel === "object" ? channel : { channel };
    const subscription2 = new Subscription(this.consumer, params, mixin);
    return this.add(subscription2);
  }
  add(subscription2) {
    this.subscriptions.push(subscription2);
    this.consumer.ensureActiveConnection();
    this.notify(subscription2, "initialized");
    this.subscribe(subscription2);
    return subscription2;
  }
  remove(subscription2) {
    this.forget(subscription2);
    if (!this.findAll(subscription2.identifier).length) {
      this.sendCommand(subscription2, "unsubscribe");
    }
    return subscription2;
  }
  reject(identifier) {
    return this.findAll(identifier).map((subscription2) => {
      this.forget(subscription2);
      this.notify(subscription2, "rejected");
      return subscription2;
    });
  }
  forget(subscription2) {
    this.guarantor.forget(subscription2);
    this.subscriptions = this.subscriptions.filter((s) => s !== subscription2);
    return subscription2;
  }
  findAll(identifier) {
    return this.subscriptions.filter((s) => s.identifier === identifier);
  }
  reload() {
    return this.subscriptions.map((subscription2) => this.subscribe(subscription2));
  }
  notifyAll(callbackName, ...args) {
    return this.subscriptions.map((subscription2) => this.notify(subscription2, callbackName, ...args));
  }
  notify(subscription2, callbackName, ...args) {
    let subscriptions;
    if (typeof subscription2 === "string") {
      subscriptions = this.findAll(subscription2);
    } else {
      subscriptions = [subscription2];
    }
    return subscriptions.map((subscription3) => typeof subscription3[callbackName] === "function" ? subscription3[callbackName](...args) : undefined);
  }
  subscribe(subscription2) {
    if (this.sendCommand(subscription2, "subscribe")) {
      this.guarantor.guarantee(subscription2);
    }
  }
  confirmSubscription(identifier) {
    logger_default.log(`Subscription confirmed ${identifier}`);
    this.findAll(identifier).map((subscription2) => this.guarantor.forget(subscription2));
  }
  sendCommand(subscription2, command) {
    const { identifier } = subscription2;
    return this.consumer.send({ command, identifier });
  }
}
var init_subscriptions = __esm(() => {
  init_subscription();
  init_subscription_guarantor();
  init_logger();
});

// node_modules/@rails/actioncable/src/consumer.js
function createWebSocketURL(url) {
  if (typeof url === "function") {
    url = url();
  }
  if (url && !/^wss?:/i.test(url)) {
    const a = document.createElement("a");
    a.href = url;
    a.href = a.href;
    a.protocol = a.protocol.replace("http", "ws");
    return a.href;
  } else {
    return url;
  }
}

class Consumer {
  constructor(url) {
    this._url = url;
    this.subscriptions = new Subscriptions(this);
    this.connection = new connection_default(this);
    this.subprotocols = [];
  }
  get url() {
    return createWebSocketURL(this._url);
  }
  send(data) {
    return this.connection.send(data);
  }
  connect() {
    return this.connection.open();
  }
  disconnect() {
    return this.connection.close({ allowReconnect: false });
  }
  ensureActiveConnection() {
    if (!this.connection.isActive()) {
      return this.connection.open();
    }
  }
  addSubProtocol(subprotocol) {
    this.subprotocols = [...this.subprotocols, subprotocol];
  }
}
var init_consumer = __esm(() => {
  init_connection();
  init_subscriptions();
});

// node_modules/@rails/actioncable/src/index.js
var exports_src = {};
__export(exports_src, {
  logger: () => {
    {
      return logger_default;
    }
  },
  getConfig: () => {
    {
      return getConfig;
    }
  },
  createWebSocketURL: () => {
    {
      return createWebSocketURL;
    }
  },
  createConsumer: () => {
    {
      return createConsumer;
    }
  },
  adapters: () => {
    {
      return adapters_default;
    }
  },
  Subscriptions: () => {
    {
      return Subscriptions;
    }
  },
  SubscriptionGuarantor: () => {
    {
      return subscription_guarantor_default;
    }
  },
  Subscription: () => {
    {
      return Subscription;
    }
  },
  INTERNAL: () => {
    {
      return internal_default;
    }
  },
  Consumer: () => {
    {
      return Consumer;
    }
  },
  ConnectionMonitor: () => {
    {
      return connection_monitor_default;
    }
  },
  Connection: () => {
    {
      return connection_default;
    }
  }
});
function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
  return new Consumer(url);
}
function getConfig(name) {
  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
  if (element) {
    return element.getAttribute("content");
  }
}
var init_src = __esm(() => {
  init_connection();
  init_connection_monitor();
  init_consumer();
  init_internal();
  init_subscription();
  init_subscriptions();
  init_subscription_guarantor();
  init_adapters();
  init_logger();
});

// node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
var exports_turbo_es2017_esm = {};
__export(exports_turbo_es2017_esm, {
  visit: () => {
    {
      return visit;
    }
  },
  start: () => {
    {
      return start;
    }
  },
  setProgressBarDelay: () => {
    {
      return setProgressBarDelay;
    }
  },
  setFormMode: () => {
    {
      return setFormMode;
    }
  },
  setConfirmMethod: () => {
    {
      return setConfirmMethod;
    }
  },
  session: () => {
    {
      return session;
    }
  },
  renderStreamMessage: () => {
    {
      return renderStreamMessage;
    }
  },
  registerAdapter: () => {
    {
      return registerAdapter;
    }
  },
  navigator: () => {
    {
      return navigator$1;
    }
  },
  isSafe: () => {
    {
      return isSafe;
    }
  },
  fetchMethodFromString: () => {
    {
      return fetchMethodFromString;
    }
  },
  fetchEnctypeFromString: () => {
    {
      return fetchEnctypeFromString;
    }
  },
  fetch: () => {
    {
      return fetchWithTurboHeaders;
    }
  },
  disconnectStreamSource: () => {
    {
      return disconnectStreamSource;
    }
  },
  connectStreamSource: () => {
    {
      return connectStreamSource;
    }
  },
  config: () => {
    {
      return config;
    }
  },
  clearCache: () => {
    {
      return clearCache;
    }
  },
  cache: () => {
    {
      return cache;
    }
  },
  StreamSourceElement: () => {
    {
      return StreamSourceElement;
    }
  },
  StreamElement: () => {
    {
      return StreamElement;
    }
  },
  StreamActions: () => {
    {
      return StreamActions;
    }
  },
  PageSnapshot: () => {
    {
      return PageSnapshot;
    }
  },
  PageRenderer: () => {
    {
      return PageRenderer;
    }
  },
  FrameRenderer: () => {
    {
      return FrameRenderer;
    }
  },
  FrameLoadingStyle: () => {
    {
      return FrameLoadingStyle;
    }
  },
  FrameElement: () => {
    {
      return FrameElement;
    }
  },
  FetchResponse: () => {
    {
      return FetchResponse;
    }
  },
  FetchRequest: () => {
    {
      return FetchRequest;
    }
  },
  FetchMethod: () => {
    {
      return FetchMethod;
    }
  },
  FetchEnctype: () => {
    {
      return FetchEnctype;
    }
  }
});
var findSubmitterFromClickTarget = function(target) {
  const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
  const candidate = element ? element.closest("input, button") : null;
  return candidate?.type == "submit" ? candidate : null;
};
var clickCaptured = function(event) {
  const submitter = findSubmitterFromClickTarget(event.target);
  if (submitter && submitter.form) {
    submittersByForm.set(submitter.form, submitter);
  }
};
var frameLoadingStyleFromString = function(style) {
  switch (style.toLowerCase()) {
    case "lazy":
      return FrameLoadingStyle.lazy;
    default:
      return FrameLoadingStyle.eager;
  }
};
var activateScriptElement = function(element) {
  if (element.getAttribute("data-turbo-eval") == "false") {
    return element;
  } else {
    const createdScriptElement = document.createElement("script");
    const cspNonce = getCspNonce();
    if (cspNonce) {
      createdScriptElement.nonce = cspNonce;
    }
    createdScriptElement.textContent = element.textContent;
    createdScriptElement.async = false;
    copyElementAttributes(createdScriptElement, element);
    return createdScriptElement;
  }
};
var copyElementAttributes = function(destinationElement, sourceElement) {
  for (const { name, value } of sourceElement.attributes) {
    destinationElement.setAttribute(name, value);
  }
};
var createDocumentFragment = function(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
};
var dispatch = function(eventName, { target, cancelable, detail } = {}) {
  const event = new CustomEvent(eventName, {
    cancelable,
    bubbles: true,
    composed: true,
    detail
  });
  if (target && target.isConnected) {
    target.dispatchEvent(event);
  } else {
    document.documentElement.dispatchEvent(event);
  }
  return event;
};
var cancelEvent = function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
};
var nextRepaint = function() {
  if (document.visibilityState === "hidden") {
    return nextEventLoopTick();
  } else {
    return nextAnimationFrame();
  }
};
var nextAnimationFrame = function() {
  return new Promise((resolve) => requestAnimationFrame(() => resolve()));
};
var nextEventLoopTick = function() {
  return new Promise((resolve) => setTimeout(() => resolve(), 0));
};
var nextMicrotask = function() {
  return Promise.resolve();
};
var parseHTMLDocument = function(html = "") {
  return new DOMParser().parseFromString(html, "text/html");
};
var unindent = function(strings, ...values) {
  const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
  const match = lines[0].match(/^\s+/);
  const indent = match ? match[0].length : 0;
  return lines.map((line) => line.slice(indent)).join("\n");
};
var interpolate = function(strings, values) {
  return strings.reduce((result, string, i) => {
    const value = values[i] == undefined ? "" : values[i];
    return result + string + value;
  }, "");
};
var uuid = function() {
  return Array.from({ length: 36 }).map((_, i) => {
    if (i == 8 || i == 13 || i == 18 || i == 23) {
      return "-";
    } else if (i == 14) {
      return "4";
    } else if (i == 19) {
      return (Math.floor(Math.random() * 4) + 8).toString(16);
    } else {
      return Math.floor(Math.random() * 15).toString(16);
    }
  }).join("");
};
var getAttribute = function(attributeName, ...elements) {
  for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
    if (typeof value == "string")
      return value;
  }
  return null;
};
var hasAttribute = function(attributeName, ...elements) {
  return elements.some((element) => element && element.hasAttribute(attributeName));
};
var markAsBusy = function(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.setAttribute("busy", "");
    }
    element.setAttribute("aria-busy", "true");
  }
};
var clearBusyState = function(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.removeAttribute("busy");
    }
    element.removeAttribute("aria-busy");
  }
};
var waitForLoad = function(element, timeoutInMilliseconds = 2000) {
  return new Promise((resolve) => {
    const onComplete = () => {
      element.removeEventListener("error", onComplete);
      element.removeEventListener("load", onComplete);
      resolve();
    };
    element.addEventListener("load", onComplete, { once: true });
    element.addEventListener("error", onComplete, { once: true });
    setTimeout(resolve, timeoutInMilliseconds);
  });
};
var getHistoryMethodForAction = function(action) {
  switch (action) {
    case "replace":
      return history.replaceState;
    case "advance":
    case "restore":
      return history.pushState;
  }
};
var isAction = function(action) {
  return action == "advance" || action == "replace" || action == "restore";
};
var getVisitAction = function(...elements) {
  const action = getAttribute("data-turbo-action", ...elements);
  return isAction(action) ? action : null;
};
var getMetaElement = function(name) {
  return document.querySelector(`meta[name="${name}"]`);
};
var getMetaContent = function(name) {
  const element = getMetaElement(name);
  return element && element.content;
};
var getCspNonce = function() {
  const element = getMetaElement("csp-nonce");
  if (element) {
    const { nonce, content } = element;
    return nonce == "" ? content : nonce;
  }
};
var setMetaContent = function(name, content) {
  let element = getMetaElement(name);
  if (!element) {
    element = document.createElement("meta");
    element.setAttribute("name", name);
    document.head.appendChild(element);
  }
  element.setAttribute("content", content);
  return element;
};
var findClosestRecursively = function(element, selector) {
  if (element instanceof Element) {
    return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
  }
};
var elementIsFocusable = function(element) {
  const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
  return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
};
var queryAutofocusableElement = function(elementOrDocumentFragment) {
  return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
};
async function around(callback, reader) {
  const before = reader();
  callback();
  await nextAnimationFrame();
  const after = reader();
  return [before, after];
}
var doesNotTargetIFrame = function(name) {
  if (name === "_blank") {
    return false;
  } else if (name) {
    for (const element of document.getElementsByName(name)) {
      if (element instanceof HTMLIFrameElement)
        return false;
    }
    return true;
  } else {
    return true;
  }
};
var findLinkFromClickTarget = function(target) {
  return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
};
var getLocationForLink = function(link) {
  return expandURL(link.getAttribute("href") || "");
};
var debounce = function(fn, delay) {
  let timeoutId = null;
  return (...args) => {
    const callback = () => fn.apply(this, args);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(callback, delay);
  };
};
var expandURL = function(locatable) {
  return new URL(locatable.toString(), document.baseURI);
};
var getAnchor = function(url) {
  let anchorMatch;
  if (url.hash) {
    return url.hash.slice(1);
  } else if (anchorMatch = url.href.match(/#(.*)$/)) {
    return anchorMatch[1];
  }
};
var getAction$1 = function(form, submitter) {
  const action = submitter?.getAttribute("formaction") || form.getAttribute("action") || form.action;
  return expandURL(action);
};
var getExtension = function(url) {
  return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
};
var isPrefixedBy = function(baseURL, url) {
  const prefix = getPrefix(url);
  return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
};
var locationIsVisitable = function(location2, rootLocation) {
  return isPrefixedBy(location2, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location2));
};
var getRequestURL = function(url) {
  const anchor = getAnchor(url);
  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
};
var toCacheKey = function(url) {
  return getRequestURL(url);
};
var urlsAreEqual = function(left, right) {
  return expandURL(left).href == expandURL(right).href;
};
var getPathComponents = function(url) {
  return url.pathname.split("/").slice(1);
};
var getLastPathComponent = function(url) {
  return getPathComponents(url).slice(-1)[0];
};
var getPrefix = function(url) {
  return addTrailingSlash(url.origin + url.pathname);
};
var addTrailingSlash = function(value) {
  return value.endsWith("/") ? value : value + "/";
};
var fetchWithTurboHeaders = function(url, options = {}) {
  const modifiedHeaders = new Headers(options.headers || {});
  const requestUID = uuid();
  recentRequests.add(requestUID);
  modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
  return nativeFetch(url, {
    ...options,
    headers: modifiedHeaders
  });
};
var fetchMethodFromString = function(method) {
  switch (method.toLowerCase()) {
    case "get":
      return FetchMethod.get;
    case "post":
      return FetchMethod.post;
    case "put":
      return FetchMethod.put;
    case "patch":
      return FetchMethod.patch;
    case "delete":
      return FetchMethod.delete;
  }
};
var fetchEnctypeFromString = function(encoding) {
  switch (encoding.toLowerCase()) {
    case FetchEnctype.multipart:
      return FetchEnctype.multipart;
    case FetchEnctype.plain:
      return FetchEnctype.plain;
    default:
      return FetchEnctype.urlEncoded;
  }
};
var isSafe = function(fetchMethod) {
  return fetchMethodFromString(fetchMethod) == FetchMethod.get;
};
var buildResourceAndBody = function(resource, method, requestBody, enctype) {
  const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
  if (isSafe(method)) {
    return [mergeIntoURLSearchParams(resource, searchParams), null];
  } else if (enctype == FetchEnctype.urlEncoded) {
    return [resource, searchParams];
  } else {
    return [resource, requestBody];
  }
};
var entriesExcludingFiles = function(requestBody) {
  const entries = [];
  for (const [name, value] of requestBody) {
    if (value instanceof File)
      continue;
    else
      entries.push([name, value]);
  }
  return entries;
};
var mergeIntoURLSearchParams = function(url, requestBody) {
  const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
  url.search = searchParams.toString();
  return url;
};
var importStreamElements = function(fragment) {
  for (const element of fragment.querySelectorAll("turbo-stream")) {
    const streamElement = document.importNode(element, true);
    for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
      inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
    }
    element.replaceWith(streamElement);
  }
  return fragment;
};
var buildFormData = function(formElement, submitter) {
  const formData = new FormData(formElement);
  const name = submitter?.getAttribute("name");
  const value = submitter?.getAttribute("value");
  if (name) {
    formData.append(name, value || "");
  }
  return formData;
};
var getCookieValue = function(cookieName) {
  if (cookieName != null) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      return value ? decodeURIComponent(value) : undefined;
    }
  }
};
var responseSucceededWithoutRedirect = function(response) {
  return response.statusCode == 200 && !response.redirected;
};
var getFormAction = function(formElement, submitter) {
  const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
  if (submitter?.hasAttribute("formaction")) {
    return submitter.getAttribute("formaction") || "";
  } else {
    return formElement.getAttribute("action") || formElementAction || "";
  }
};
var getAction = function(formAction, fetchMethod) {
  const action = expandURL(formAction);
  if (isSafe(fetchMethod)) {
    action.search = "";
  }
  return action;
};
var getMethod = function(formElement, submitter) {
  const method = submitter?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
};
var getEnctype = function(formElement, submitter) {
  return fetchEnctypeFromString(submitter?.getAttribute("formenctype") || formElement.enctype);
};
var getPermanentElementById = function(node, id) {
  return node.querySelector(`#${id}[data-turbo-permanent]`);
};
var queryPermanentElementsAll = function(node) {
  return node.querySelectorAll("[id][data-turbo-permanent]");
};
var submissionDoesNotDismissDialog = function(form, submitter) {
  const method = submitter?.getAttribute("formmethod") || form.getAttribute("method");
  return method != "dialog";
};
var submissionDoesNotTargetIFrame = function(form, submitter) {
  const target = submitter?.getAttribute("formtarget") || form.getAttribute("target");
  return doesNotTargetIFrame(target);
};
var createPlaceholderForPermanentElement = function(permanentElement) {
  const element = document.createElement("meta");
  element.setAttribute("name", "turbo-permanent-placeholder");
  element.setAttribute("content", permanentElement.id);
  return element;
};
var readScrollLogicalPosition = function(value, defaultValue) {
  if (value == "end" || value == "start" || value == "center" || value == "nearest") {
    return value;
  } else {
    return defaultValue;
  }
};
var readScrollBehavior = function(value, defaultValue) {
  if (value == "auto" || value == "smooth") {
    return value;
  } else {
    return defaultValue;
  }
};
var morphElements = function(currentElement, newElement, { callbacks, ...options } = {}) {
  Idiomorph.morph(currentElement, newElement, {
    ...options,
    callbacks: new DefaultIdiomorphCallbacks(callbacks)
  });
};
var morphChildren = function(currentElement, newElement) {
  morphElements(currentElement, newElement.childNodes, {
    morphStyle: "innerHTML"
  });
};
var elementType = function(element) {
  if (elementIsScript(element)) {
    return "script";
  } else if (elementIsStylesheet(element)) {
    return "stylesheet";
  }
};
var elementIsTracked = function(element) {
  return element.getAttribute("data-turbo-track") == "reload";
};
var elementIsScript = function(element) {
  const tagName = element.localName;
  return tagName == "script";
};
var elementIsNoscript = function(element) {
  const tagName = element.localName;
  return tagName == "noscript";
};
var elementIsStylesheet = function(element) {
  const tagName = element.localName;
  return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
};
var elementIsMetaElementWithName = function(element, name) {
  const tagName = element.localName;
  return tagName == "meta" && element.getAttribute("name") == name;
};
var elementWithoutNonce = function(element) {
  if (element.hasAttribute("nonce")) {
    element.setAttribute("nonce", "");
  }
  return element;
};
var isSuccessful = function(statusCode) {
  return statusCode >= 200 && statusCode < 300;
};
var getPermanentElementMapForFragment = function(fragment) {
  const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
  const permanentElementMap = {};
  for (const permanentElementInDocument of permanentElementsInDocument) {
    const { id } = permanentElementInDocument;
    for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
      const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
      if (elementInStream) {
        permanentElementMap[id] = [permanentElementInDocument, elementInStream];
      }
    }
  }
  return permanentElementMap;
};
async function withAutofocusFromFragment(fragment, callback) {
  const generatedID = `turbo-stream-autofocus-${uuid()}`;
  const turboStreams = fragment.querySelectorAll("turbo-stream");
  const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
  let willAutofocusId = null;
  if (elementWithAutofocus) {
    if (elementWithAutofocus.id) {
      willAutofocusId = elementWithAutofocus.id;
    } else {
      willAutofocusId = generatedID;
    }
    elementWithAutofocus.id = willAutofocusId;
  }
  callback();
  await nextRepaint();
  const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
  if (hasNoActiveElement && willAutofocusId) {
    const elementToAutofocus = document.getElementById(willAutofocusId);
    if (elementIsFocusable(elementToAutofocus)) {
      elementToAutofocus.focus();
    }
    if (elementToAutofocus && elementToAutofocus.id == generatedID) {
      elementToAutofocus.removeAttribute("id");
    }
  }
}
async function withPreservedFocus(callback) {
  const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
  const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
  if (restoreFocusTo) {
    const elementToFocus = document.getElementById(restoreFocusTo);
    if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
      elementToFocus.focus();
    }
  }
}
var firstAutofocusableElementInStreams = function(nodeListOfStreamElements) {
  for (const streamElement of nodeListOfStreamElements) {
    const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
    if (elementWithAutofocus)
      return elementWithAutofocus;
  }
  return null;
};
var fetchResponseFromEvent = function(event) {
  const fetchResponse = event.detail?.fetchResponse;
  if (fetchResponse instanceof FetchResponse) {
    return fetchResponse;
  }
};
var fetchResponseIsStream = function(response) {
  const contentType = response.contentType ?? "";
  return contentType.startsWith(StreamMessage.contentType);
};
var canRefreshFrame = function(frame) {
  return frame instanceof FrameElement && frame.src && frame.refresh === "morph" && !frame.closest("[data-turbo-permanent]");
};
var extendURLWithDeprecatedProperties = function(url) {
  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
};
var start = function() {
  session.start();
};
var registerAdapter = function(adapter) {
  session.registerAdapter(adapter);
};
var visit = function(location2, options) {
  session.visit(location2, options);
};
var connectStreamSource = function(source) {
  session.connectStreamSource(source);
};
var disconnectStreamSource = function(source) {
  session.disconnectStreamSource(source);
};
var renderStreamMessage = function(message) {
  session.renderStreamMessage(message);
};
var clearCache = function() {
  console.warn("Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  session.clearCache();
};
var setProgressBarDelay = function(delay) {
  console.warn("Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  config.drive.progressBarDelay = delay;
};
var setConfirmMethod = function(confirmMethod) {
  console.warn("Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  config.forms.confirm = confirmMethod;
};
var setFormMode = function(mode) {
  console.warn("Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  config.forms.mode = mode;
};
var getFrameElementById = function(id) {
  if (id != null) {
    const element = document.getElementById(id);
    if (element instanceof FrameElement) {
      return element;
    }
  }
};
var activateElement = function(element, currentURL) {
  if (element) {
    const src = element.getAttribute("src");
    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
      throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
    }
    if (element.ownerDocument !== document) {
      element = document.importNode(element, true);
    }
    if (element instanceof FrameElement) {
      element.connectedCallback();
      element.disconnectedCallback();
      return element;
    }
  }
};
/*!
Turbo 8.0.13
Copyright Â© 2025 37signals LLC
 */
(function(prototype) {
  if (typeof prototype.requestSubmit == "function")
    return;
  prototype.requestSubmit = function(submitter) {
    if (submitter) {
      validateSubmitter(submitter, this);
      submitter.click();
    } else {
      submitter = document.createElement("input");
      submitter.type = "submit";
      submitter.hidden = true;
      this.appendChild(submitter);
      submitter.click();
      this.removeChild(submitter);
    }
  };
  function validateSubmitter(submitter, form) {
    submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
    submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
    submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
  }
  function raise(errorConstructor, message, name) {
    throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
  }
})(HTMLFormElement.prototype);
var submittersByForm = new WeakMap;
(function() {
  if ("submitter" in Event.prototype)
    return;
  let prototype = window.Event.prototype;
  if ("SubmitEvent" in window) {
    const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
    if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
      prototype = prototypeOfSubmitEvent;
    } else {
      return;
    }
  }
  addEventListener("click", clickCaptured, true);
  Object.defineProperty(prototype, "submitter", {
    get() {
      if (this.type == "submit" && this.target instanceof HTMLFormElement) {
        return submittersByForm.get(this.target);
      }
    }
  });
})();
var FrameLoadingStyle = {
  eager: "eager",
  lazy: "lazy"
};

class FrameElement extends HTMLElement {
  static delegateConstructor = undefined;
  loaded = Promise.resolve();
  static get observedAttributes() {
    return ["disabled", "loading", "src"];
  }
  constructor() {
    super();
    this.delegate = new FrameElement.delegateConstructor(this);
  }
  connectedCallback() {
    this.delegate.connect();
  }
  disconnectedCallback() {
    this.delegate.disconnect();
  }
  reload() {
    return this.delegate.sourceURLReloaded();
  }
  attributeChangedCallback(name) {
    if (name == "loading") {
      this.delegate.loadingStyleChanged();
    } else if (name == "src") {
      this.delegate.sourceURLChanged();
    } else if (name == "disabled") {
      this.delegate.disabledChanged();
    }
  }
  get src() {
    return this.getAttribute("src");
  }
  set src(value) {
    if (value) {
      this.setAttribute("src", value);
    } else {
      this.removeAttribute("src");
    }
  }
  get refresh() {
    return this.getAttribute("refresh");
  }
  set refresh(value) {
    if (value) {
      this.setAttribute("refresh", value);
    } else {
      this.removeAttribute("refresh");
    }
  }
  get shouldReloadWithMorph() {
    return this.src && this.refresh === "morph";
  }
  get loading() {
    return frameLoadingStyleFromString(this.getAttribute("loading") || "");
  }
  set loading(value) {
    if (value) {
      this.setAttribute("loading", value);
    } else {
      this.removeAttribute("loading");
    }
  }
  get disabled() {
    return this.hasAttribute("disabled");
  }
  set disabled(value) {
    if (value) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }
  get autoscroll() {
    return this.hasAttribute("autoscroll");
  }
  set autoscroll(value) {
    if (value) {
      this.setAttribute("autoscroll", "");
    } else {
      this.removeAttribute("autoscroll");
    }
  }
  get complete() {
    return !this.delegate.isLoading;
  }
  get isActive() {
    return this.ownerDocument === document && !this.isPreview;
  }
  get isPreview() {
    return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
  }
}
var drive = {
  enabled: true,
  progressBarDelay: 500,
  unvisitableExtensions: new Set([
    ".7z",
    ".aac",
    ".apk",
    ".avi",
    ".bmp",
    ".bz2",
    ".css",
    ".csv",
    ".deb",
    ".dmg",
    ".doc",
    ".docx",
    ".exe",
    ".gif",
    ".gz",
    ".heic",
    ".heif",
    ".ico",
    ".iso",
    ".jpeg",
    ".jpg",
    ".js",
    ".json",
    ".m4a",
    ".mkv",
    ".mov",
    ".mp3",
    ".mp4",
    ".mpeg",
    ".mpg",
    ".msi",
    ".ogg",
    ".ogv",
    ".pdf",
    ".pkg",
    ".png",
    ".ppt",
    ".pptx",
    ".rar",
    ".rtf",
    ".svg",
    ".tar",
    ".tif",
    ".tiff",
    ".txt",
    ".wav",
    ".webm",
    ".webp",
    ".wma",
    ".wmv",
    ".xls",
    ".xlsx",
    ".xml",
    ".zip"
  ])
};
var submitter = {
  "aria-disabled": {
    beforeSubmit: (submitter2) => {
      submitter2.setAttribute("aria-disabled", "true");
      submitter2.addEventListener("click", cancelEvent);
    },
    afterSubmit: (submitter2) => {
      submitter2.removeAttribute("aria-disabled");
      submitter2.removeEventListener("click", cancelEvent);
    }
  },
  disabled: {
    beforeSubmit: (submitter2) => submitter2.disabled = true,
    afterSubmit: (submitter2) => submitter2.disabled = false
  }
};

class Config {
  #submitter = null;
  constructor(config) {
    Object.assign(this, config);
  }
  get submitter() {
    return this.#submitter;
  }
  set submitter(value) {
    this.#submitter = submitter[value] || value;
  }
}
var forms = new Config({
  mode: "on",
  submitter: "disabled"
});
var config = {
  drive,
  forms
};

class FetchResponse {
  constructor(response) {
    this.response = response;
  }
  get succeeded() {
    return this.response.ok;
  }
  get failed() {
    return !this.succeeded;
  }
  get clientError() {
    return this.statusCode >= 400 && this.statusCode <= 499;
  }
  get serverError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
  get redirected() {
    return this.response.redirected;
  }
  get location() {
    return expandURL(this.response.url);
  }
  get isHTML() {
    return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
  }
  get statusCode() {
    return this.response.status;
  }
  get contentType() {
    return this.header("Content-Type");
  }
  get responseText() {
    return this.response.clone().text();
  }
  get responseHTML() {
    if (this.isHTML) {
      return this.response.clone().text();
    } else {
      return Promise.resolve(undefined);
    }
  }
  header(name) {
    return this.response.headers.get(name);
  }
}

class LimitedSet extends Set {
  constructor(maxSize) {
    super();
    this.maxSize = maxSize;
  }
  add(value) {
    if (this.size >= this.maxSize) {
      const iterator = this.values();
      const oldestValue = iterator.next().value;
      this.delete(oldestValue);
    }
    super.add(value);
  }
}
var recentRequests = new LimitedSet(20);
var nativeFetch = window.fetch;
var FetchMethod = {
  get: "get",
  post: "post",
  put: "put",
  patch: "patch",
  delete: "delete"
};
var FetchEnctype = {
  urlEncoded: "application/x-www-form-urlencoded",
  multipart: "multipart/form-data",
  plain: "text/plain"
};

class FetchRequest {
  abortController = new AbortController;
  #resolveRequestPromise = (_value) => {
  };
  constructor(delegate, method, location2, requestBody = new URLSearchParams, target = null, enctype = FetchEnctype.urlEncoded) {
    const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
    this.delegate = delegate;
    this.url = url;
    this.target = target;
    this.fetchOptions = {
      credentials: "same-origin",
      redirect: "follow",
      method: method.toUpperCase(),
      headers: { ...this.defaultHeaders },
      body,
      signal: this.abortSignal,
      referrer: this.delegate.referrer?.href
    };
    this.enctype = enctype;
  }
  get method() {
    return this.fetchOptions.method;
  }
  set method(value) {
    const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData;
    const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
    this.url.search = "";
    const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
    this.url = url;
    this.fetchOptions.body = body;
    this.fetchOptions.method = fetchMethod.toUpperCase();
  }
  get headers() {
    return this.fetchOptions.headers;
  }
  set headers(value) {
    this.fetchOptions.headers = value;
  }
  get body() {
    if (this.isSafe) {
      return this.url.searchParams;
    } else {
      return this.fetchOptions.body;
    }
  }
  set body(value) {
    this.fetchOptions.body = value;
  }
  get location() {
    return this.url;
  }
  get params() {
    return this.url.searchParams;
  }
  get entries() {
    return this.body ? Array.from(this.body.entries()) : [];
  }
  cancel() {
    this.abortController.abort();
  }
  async perform() {
    const { fetchOptions } = this;
    this.delegate.prepareRequest(this);
    const event = await this.#allowRequestToBeIntercepted(fetchOptions);
    try {
      this.delegate.requestStarted(this);
      if (event.detail.fetchRequest) {
        this.response = event.detail.fetchRequest.response;
      } else {
        this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
      }
      const response = await this.response;
      return await this.receive(response);
    } catch (error) {
      if (error.name !== "AbortError") {
        if (this.#willDelegateErrorHandling(error)) {
          this.delegate.requestErrored(this, error);
        }
        throw error;
      }
    } finally {
      this.delegate.requestFinished(this);
    }
  }
  async receive(response) {
    const fetchResponse = new FetchResponse(response);
    const event = dispatch("turbo:before-fetch-response", {
      cancelable: true,
      detail: { fetchResponse },
      target: this.target
    });
    if (event.defaultPrevented) {
      this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
    } else if (fetchResponse.succeeded) {
      this.delegate.requestSucceededWithResponse(this, fetchResponse);
    } else {
      this.delegate.requestFailedWithResponse(this, fetchResponse);
    }
    return fetchResponse;
  }
  get defaultHeaders() {
    return {
      Accept: "text/html, application/xhtml+xml"
    };
  }
  get isSafe() {
    return isSafe(this.method);
  }
  get abortSignal() {
    return this.abortController.signal;
  }
  acceptResponseType(mimeType) {
    this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
  }
  async#allowRequestToBeIntercepted(fetchOptions) {
    const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
    const event = dispatch("turbo:before-fetch-request", {
      cancelable: true,
      detail: {
        fetchOptions,
        url: this.url,
        resume: this.#resolveRequestPromise
      },
      target: this.target
    });
    this.url = event.detail.url;
    if (event.defaultPrevented)
      await requestInterception;
    return event;
  }
  #willDelegateErrorHandling(error) {
    const event = dispatch("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: { request: this, error }
    });
    return !event.defaultPrevented;
  }
}

class AppearanceObserver {
  started = false;
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
    this.intersectionObserver = new IntersectionObserver(this.intersect);
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.intersectionObserver.observe(this.element);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.intersectionObserver.unobserve(this.element);
    }
  }
  intersect = (entries) => {
    const lastEntry = entries.slice(-1)[0];
    if (lastEntry?.isIntersecting) {
      this.delegate.elementAppearedInViewport(this.element);
    }
  };
}

class StreamMessage {
  static contentType = "text/vnd.turbo-stream.html";
  static wrap(message) {
    if (typeof message == "string") {
      return new this(createDocumentFragment(message));
    } else {
      return message;
    }
  }
  constructor(fragment) {
    this.fragment = importStreamElements(fragment);
  }
}
var PREFETCH_DELAY = 100;

class PrefetchCache {
  #prefetchTimeout = null;
  #prefetched = null;
  get(url) {
    if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
      return this.#prefetched.request;
    }
  }
  setLater(url, request, ttl) {
    this.clear();
    this.#prefetchTimeout = setTimeout(() => {
      request.perform();
      this.set(url, request, ttl);
      this.#prefetchTimeout = null;
    }, PREFETCH_DELAY);
  }
  set(url, request, ttl) {
    this.#prefetched = { url, request, expire: new Date(new Date().getTime() + ttl) };
  }
  clear() {
    if (this.#prefetchTimeout)
      clearTimeout(this.#prefetchTimeout);
    this.#prefetched = null;
  }
}
var cacheTtl = 10 * 1000;
var prefetchCache = new PrefetchCache;
var FormSubmissionState = {
  initialized: "initialized",
  requesting: "requesting",
  waiting: "waiting",
  receiving: "receiving",
  stopping: "stopping",
  stopped: "stopped"
};

class FormSubmission {
  state = FormSubmissionState.initialized;
  static confirmMethod(message) {
    return Promise.resolve(confirm(message));
  }
  constructor(delegate, formElement, submitter2, mustRedirect = false) {
    const method = getMethod(formElement, submitter2);
    const action = getAction(getFormAction(formElement, submitter2), method);
    const body = buildFormData(formElement, submitter2);
    const enctype = getEnctype(formElement, submitter2);
    this.delegate = delegate;
    this.formElement = formElement;
    this.submitter = submitter2;
    this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
    this.mustRedirect = mustRedirect;
  }
  get method() {
    return this.fetchRequest.method;
  }
  set method(value) {
    this.fetchRequest.method = value;
  }
  get action() {
    return this.fetchRequest.url.toString();
  }
  set action(value) {
    this.fetchRequest.url = expandURL(value);
  }
  get body() {
    return this.fetchRequest.body;
  }
  get enctype() {
    return this.fetchRequest.enctype;
  }
  get isSafe() {
    return this.fetchRequest.isSafe;
  }
  get location() {
    return this.fetchRequest.url;
  }
  async start() {
    const { initialized, requesting } = FormSubmissionState;
    const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
    if (typeof confirmationMessage === "string") {
      const confirmMethod = typeof config.forms.confirm === "function" ? config.forms.confirm : FormSubmission.confirmMethod;
      const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);
      if (!answer) {
        return;
      }
    }
    if (this.state == initialized) {
      this.state = requesting;
      return this.fetchRequest.perform();
    }
  }
  stop() {
    const { stopping, stopped } = FormSubmissionState;
    if (this.state != stopping && this.state != stopped) {
      this.state = stopping;
      this.fetchRequest.cancel();
      return true;
    }
  }
  prepareRequest(request) {
    if (!request.isSafe) {
      const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
      if (token) {
        request.headers["X-CSRF-Token"] = token;
      }
    }
    if (this.requestAcceptsTurboStreamResponse(request)) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    this.state = FormSubmissionState.waiting;
    if (this.submitter)
      config.forms.submitter.beforeSubmit(this.submitter);
    this.setSubmitsWith();
    markAsBusy(this.formElement);
    dispatch("turbo:submit-start", {
      target: this.formElement,
      detail: { formSubmission: this }
    });
    this.delegate.formSubmissionStarted(this);
  }
  requestPreventedHandlingResponse(request, response) {
    prefetchCache.clear();
    this.result = { success: response.succeeded, fetchResponse: response };
  }
  requestSucceededWithResponse(request, response) {
    if (response.clientError || response.serverError) {
      this.delegate.formSubmissionFailedWithResponse(this, response);
      return;
    }
    prefetchCache.clear();
    if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
      const error = new Error("Form responses must redirect to another location");
      this.delegate.formSubmissionErrored(this, error);
    } else {
      this.state = FormSubmissionState.receiving;
      this.result = { success: true, fetchResponse: response };
      this.delegate.formSubmissionSucceededWithResponse(this, response);
    }
  }
  requestFailedWithResponse(request, response) {
    this.result = { success: false, fetchResponse: response };
    this.delegate.formSubmissionFailedWithResponse(this, response);
  }
  requestErrored(request, error) {
    this.result = { success: false, error };
    this.delegate.formSubmissionErrored(this, error);
  }
  requestFinished(_request) {
    this.state = FormSubmissionState.stopped;
    if (this.submitter)
      config.forms.submitter.afterSubmit(this.submitter);
    this.resetSubmitterText();
    clearBusyState(this.formElement);
    dispatch("turbo:submit-end", {
      target: this.formElement,
      detail: { formSubmission: this, ...this.result }
    });
    this.delegate.formSubmissionFinished(this);
  }
  setSubmitsWith() {
    if (!this.submitter || !this.submitsWith)
      return;
    if (this.submitter.matches("button")) {
      this.originalSubmitText = this.submitter.innerHTML;
      this.submitter.innerHTML = this.submitsWith;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      this.originalSubmitText = input.value;
      input.value = this.submitsWith;
    }
  }
  resetSubmitterText() {
    if (!this.submitter || !this.originalSubmitText)
      return;
    if (this.submitter.matches("button")) {
      this.submitter.innerHTML = this.originalSubmitText;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      input.value = this.originalSubmitText;
    }
  }
  requestMustRedirect(request) {
    return !request.isSafe && this.mustRedirect;
  }
  requestAcceptsTurboStreamResponse(request) {
    return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
  }
  get submitsWith() {
    return this.submitter?.getAttribute("data-turbo-submits-with");
  }
}

class Snapshot {
  constructor(element) {
    this.element = element;
  }
  get activeElement() {
    return this.element.ownerDocument.activeElement;
  }
  get children() {
    return [...this.element.children];
  }
  hasAnchor(anchor) {
    return this.getElementForAnchor(anchor) != null;
  }
  getElementForAnchor(anchor) {
    return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
  }
  get isConnected() {
    return this.element.isConnected;
  }
  get firstAutofocusableElement() {
    return queryAutofocusableElement(this.element);
  }
  get permanentElements() {
    return queryPermanentElementsAll(this.element);
  }
  getPermanentElementById(id) {
    return getPermanentElementById(this.element, id);
  }
  getPermanentElementMapForSnapshot(snapshot) {
    const permanentElementMap = {};
    for (const currentPermanentElement of this.permanentElements) {
      const { id } = currentPermanentElement;
      const newPermanentElement = snapshot.getPermanentElementById(id);
      if (newPermanentElement) {
        permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
      }
    }
    return permanentElementMap;
  }
}

class FormSubmitObserver {
  started = false;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("submit", this.submitCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
      this.started = false;
    }
  }
  submitCaptured = () => {
    this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
    this.eventTarget.addEventListener("submit", this.submitBubbled, false);
  };
  submitBubbled = (event) => {
    if (!event.defaultPrevented) {
      const form = event.target instanceof HTMLFormElement ? event.target : undefined;
      const submitter2 = event.submitter || undefined;
      if (form && submissionDoesNotDismissDialog(form, submitter2) && submissionDoesNotTargetIFrame(form, submitter2) && this.delegate.willSubmitForm(form, submitter2)) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this.delegate.formSubmitted(form, submitter2);
      }
    }
  };
}

class View {
  #resolveRenderPromise = (_value) => {
  };
  #resolveInterceptionPromise = (_value) => {
  };
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }
  scrollToAnchor(anchor) {
    const element = this.snapshot.getElementForAnchor(anchor);
    if (element) {
      this.scrollToElement(element);
      this.focusElement(element);
    } else {
      this.scrollToPosition({ x: 0, y: 0 });
    }
  }
  scrollToAnchorFromLocation(location2) {
    this.scrollToAnchor(getAnchor(location2));
  }
  scrollToElement(element) {
    element.scrollIntoView();
  }
  focusElement(element) {
    if (element instanceof HTMLElement) {
      if (element.hasAttribute("tabindex")) {
        element.focus();
      } else {
        element.setAttribute("tabindex", "-1");
        element.focus();
        element.removeAttribute("tabindex");
      }
    }
  }
  scrollToPosition({ x, y }) {
    this.scrollRoot.scrollTo(x, y);
  }
  scrollToTop() {
    this.scrollToPosition({ x: 0, y: 0 });
  }
  get scrollRoot() {
    return window;
  }
  async render(renderer) {
    const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
    const shouldInvalidate = willRender;
    if (shouldRender) {
      try {
        this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
        this.renderer = renderer;
        await this.prepareToRenderSnapshot(renderer);
        const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
        const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
        const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
        if (!immediateRender)
          await renderInterception;
        await this.renderSnapshot(renderer);
        this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
        this.delegate.preloadOnLoadLinksForView(this.element);
        this.finishRenderingSnapshot(renderer);
      } finally {
        delete this.renderer;
        this.#resolveRenderPromise(undefined);
        delete this.renderPromise;
      }
    } else if (shouldInvalidate) {
      this.invalidate(renderer.reloadReason);
    }
  }
  invalidate(reason) {
    this.delegate.viewInvalidated(reason);
  }
  async prepareToRenderSnapshot(renderer) {
    this.markAsPreview(renderer.isPreview);
    await renderer.prepareToRender();
  }
  markAsPreview(isPreview) {
    if (isPreview) {
      this.element.setAttribute("data-turbo-preview", "");
    } else {
      this.element.removeAttribute("data-turbo-preview");
    }
  }
  markVisitDirection(direction) {
    this.element.setAttribute("data-turbo-visit-direction", direction);
  }
  unmarkVisitDirection() {
    this.element.removeAttribute("data-turbo-visit-direction");
  }
  async renderSnapshot(renderer) {
    await renderer.render();
  }
  finishRenderingSnapshot(renderer) {
    renderer.finishRendering();
  }
}

class FrameView extends View {
  missing() {
    this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
  }
  get snapshot() {
    return new Snapshot(this.element);
  }
}

class LinkInterceptor {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }
  start() {
    this.element.addEventListener("click", this.clickBubbled);
    document.addEventListener("turbo:click", this.linkClicked);
    document.addEventListener("turbo:before-visit", this.willVisit);
  }
  stop() {
    this.element.removeEventListener("click", this.clickBubbled);
    document.removeEventListener("turbo:click", this.linkClicked);
    document.removeEventListener("turbo:before-visit", this.willVisit);
  }
  clickBubbled = (event) => {
    if (this.clickEventIsSignificant(event)) {
      this.clickEvent = event;
    } else {
      delete this.clickEvent;
    }
  };
  linkClicked = (event) => {
    if (this.clickEvent && this.clickEventIsSignificant(event)) {
      if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
        this.clickEvent.preventDefault();
        event.preventDefault();
        this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
      }
    }
    delete this.clickEvent;
  };
  willVisit = (_event) => {
    delete this.clickEvent;
  };
  clickEventIsSignificant(event) {
    const target = event.composed ? event.target?.parentElement : event.target;
    const element = findLinkFromClickTarget(target) || target;
    return element instanceof Element && element.closest("turbo-frame, html") == this.element;
  }
}

class LinkClickObserver {
  started = false;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("click", this.clickCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("click", this.clickCaptured, true);
      this.started = false;
    }
  }
  clickCaptured = () => {
    this.eventTarget.removeEventListener("click", this.clickBubbled, false);
    this.eventTarget.addEventListener("click", this.clickBubbled, false);
  };
  clickBubbled = (event) => {
    if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
      const target = event.composedPath && event.composedPath()[0] || event.target;
      const link = findLinkFromClickTarget(target);
      if (link && doesNotTargetIFrame(link.target)) {
        const location2 = getLocationForLink(link);
        if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
          event.preventDefault();
          this.delegate.followedLinkToLocation(link, location2);
        }
      }
    }
  };
  clickEventIsSignificant(event) {
    return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
  }
}

class FormLinkClickObserver {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.linkInterceptor = new LinkClickObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
  }
  stop() {
    this.linkInterceptor.stop();
  }
  canPrefetchRequestToLocation(link, location2) {
    return false;
  }
  prefetchAndCacheRequestToLocation(link, location2) {
    return;
  }
  willFollowLinkToLocation(link, location2, originalEvent) {
    return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
  }
  followedLinkToLocation(link, location2) {
    const form = document.createElement("form");
    const type = "hidden";
    for (const [name, value] of location2.searchParams) {
      form.append(Object.assign(document.createElement("input"), { type, name, value }));
    }
    const action = Object.assign(location2, { search: "" });
    form.setAttribute("data-turbo", "true");
    form.setAttribute("action", action.href);
    form.setAttribute("hidden", "");
    const method = link.getAttribute("data-turbo-method");
    if (method)
      form.setAttribute("method", method);
    const turboFrame = link.getAttribute("data-turbo-frame");
    if (turboFrame)
      form.setAttribute("data-turbo-frame", turboFrame);
    const turboAction = getVisitAction(link);
    if (turboAction)
      form.setAttribute("data-turbo-action", turboAction);
    const turboConfirm = link.getAttribute("data-turbo-confirm");
    if (turboConfirm)
      form.setAttribute("data-turbo-confirm", turboConfirm);
    const turboStream = link.hasAttribute("data-turbo-stream");
    if (turboStream)
      form.setAttribute("data-turbo-stream", "");
    this.delegate.submittedFormLinkToLocation(link, location2, form);
    document.body.appendChild(form);
    form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
    requestAnimationFrame(() => form.requestSubmit());
  }
}

class Bardo {
  static async preservingPermanentElements(delegate, permanentElementMap, callback) {
    const bardo = new this(delegate, permanentElementMap);
    bardo.enter();
    await callback();
    bardo.leave();
  }
  constructor(delegate, permanentElementMap) {
    this.delegate = delegate;
    this.permanentElementMap = permanentElementMap;
  }
  enter() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
      this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
      this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
    }
  }
  leave() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement] = this.permanentElementMap[id];
      this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
      this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      this.delegate.leavingBardo(currentPermanentElement);
    }
  }
  replaceNewPermanentElementWithPlaceholder(permanentElement) {
    const placeholder = createPlaceholderForPermanentElement(permanentElement);
    permanentElement.replaceWith(placeholder);
  }
  replaceCurrentPermanentElementWithClone(permanentElement) {
    const clone = permanentElement.cloneNode(true);
    permanentElement.replaceWith(clone);
  }
  replacePlaceholderWithPermanentElement(permanentElement) {
    const placeholder = this.getPlaceholderById(permanentElement.id);
    placeholder?.replaceWith(permanentElement);
  }
  getPlaceholderById(id) {
    return this.placeholders.find((element) => element.content == id);
  }
  get placeholders() {
    return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
  }
}

class Renderer {
  #activeElement = null;
  static renderElement(currentElement, newElement) {
  }
  constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
    this.currentSnapshot = currentSnapshot;
    this.newSnapshot = newSnapshot;
    this.isPreview = isPreview;
    this.willRender = willRender;
    this.renderElement = this.constructor.renderElement;
    this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
  }
  get shouldRender() {
    return true;
  }
  get shouldAutofocus() {
    return true;
  }
  get reloadReason() {
    return;
  }
  prepareToRender() {
    return;
  }
  render() {
  }
  finishRendering() {
    if (this.resolvingFunctions) {
      this.resolvingFunctions.resolve();
      delete this.resolvingFunctions;
    }
  }
  async preservingPermanentElements(callback) {
    await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
  }
  focusFirstAutofocusableElement() {
    if (this.shouldAutofocus) {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
  }
  enteringBardo(currentPermanentElement) {
    if (this.#activeElement)
      return;
    if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
      this.#activeElement = this.currentSnapshot.activeElement;
    }
  }
  leavingBardo(currentPermanentElement) {
    if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
      this.#activeElement.focus();
      this.#activeElement = null;
    }
  }
  get connectedSnapshot() {
    return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
  }
  get currentElement() {
    return this.currentSnapshot.element;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  get permanentElementMap() {
    return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
  }
  get renderMethod() {
    return "replace";
  }
}

class FrameRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const destinationRange = document.createRange();
    destinationRange.selectNodeContents(currentElement);
    destinationRange.deleteContents();
    const frameElement = newElement;
    const sourceRange = frameElement.ownerDocument?.createRange();
    if (sourceRange) {
      sourceRange.selectNodeContents(frameElement);
      currentElement.appendChild(sourceRange.extractContents());
    }
  }
  constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
    this.delegate = delegate;
  }
  get shouldRender() {
    return true;
  }
  async render() {
    await nextRepaint();
    this.preservingPermanentElements(() => {
      this.loadFrameElement();
    });
    this.scrollFrameIntoView();
    await nextRepaint();
    this.focusFirstAutofocusableElement();
    await nextRepaint();
    this.activateScriptElements();
  }
  loadFrameElement() {
    this.delegate.willRenderFrame(this.currentElement, this.newElement);
    this.renderElement(this.currentElement, this.newElement);
  }
  scrollFrameIntoView() {
    if (this.currentElement.autoscroll || this.newElement.autoscroll) {
      const element = this.currentElement.firstElementChild;
      const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
      const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
      if (element) {
        element.scrollIntoView({ block, behavior });
        return true;
      }
    }
    return false;
  }
  activateScriptElements() {
    for (const inertScriptElement of this.newScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  get newScriptElements() {
    return this.currentElement.querySelectorAll("script");
  }
}
var Idiomorph = function() {
  const noOp = () => {
  };
  const defaults = {
    morphStyle: "outerHTML",
    callbacks: {
      beforeNodeAdded: noOp,
      afterNodeAdded: noOp,
      beforeNodeMorphed: noOp,
      afterNodeMorphed: noOp,
      beforeNodeRemoved: noOp,
      afterNodeRemoved: noOp,
      beforeAttributeUpdated: noOp
    },
    head: {
      style: "merge",
      shouldPreserve: (elt) => elt.getAttribute("im-preserve") === "true",
      shouldReAppend: (elt) => elt.getAttribute("im-re-append") === "true",
      shouldRemove: noOp,
      afterHeadMorphed: noOp
    },
    restoreFocus: true
  };
  function morph(oldNode, newContent, config2 = {}) {
    oldNode = normalizeElement(oldNode);
    const newNode = normalizeParent(newContent);
    const ctx = createMorphContext(oldNode, newNode, config2);
    const morphedNodes = saveAndRestoreFocus(ctx, () => {
      return withHeadBlocking(ctx, oldNode, newNode, (ctx2) => {
        if (ctx2.morphStyle === "innerHTML") {
          morphChildren2(ctx2, oldNode, newNode);
          return Array.from(oldNode.childNodes);
        } else {
          return morphOuterHTML(ctx2, oldNode, newNode);
        }
      });
    });
    ctx.pantry.remove();
    return morphedNodes;
  }
  function morphOuterHTML(ctx, oldNode, newNode) {
    const oldParent = normalizeParent(oldNode);
    let childNodes = Array.from(oldParent.childNodes);
    const index = childNodes.indexOf(oldNode);
    const rightMargin = childNodes.length - (index + 1);
    morphChildren2(ctx, oldParent, newNode, oldNode, oldNode.nextSibling);
    childNodes = Array.from(oldParent.childNodes);
    return childNodes.slice(index, childNodes.length - rightMargin);
  }
  function saveAndRestoreFocus(ctx, fn) {
    if (!ctx.config.restoreFocus)
      return fn();
    let activeElement = document.activeElement;
    if (!(activeElement instanceof HTMLInputElement || activeElement instanceof HTMLTextAreaElement)) {
      return fn();
    }
    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;
    const results = fn();
    if (activeElementId && activeElementId !== document.activeElement?.id) {
      activeElement = ctx.target.querySelector(`#${activeElementId}`);
      activeElement?.focus();
    }
    if (activeElement && !activeElement.selectionEnd && selectionEnd) {
      activeElement.setSelectionRange(selectionStart, selectionEnd);
    }
    return results;
  }
  const morphChildren2 = function() {
    function morphChildren3(ctx, oldParent, newParent, insertionPoint = null, endPoint = null) {
      if (oldParent instanceof HTMLTemplateElement && newParent instanceof HTMLTemplateElement) {
        oldParent = oldParent.content;
        newParent = newParent.content;
      }
      insertionPoint ||= oldParent.firstChild;
      for (const newChild of newParent.childNodes) {
        if (insertionPoint && insertionPoint != endPoint) {
          const bestMatch = findBestMatch(ctx, newChild, insertionPoint, endPoint);
          if (bestMatch) {
            if (bestMatch !== insertionPoint) {
              removeNodesBetween(ctx, insertionPoint, bestMatch);
            }
            morphNode(bestMatch, newChild, ctx);
            insertionPoint = bestMatch.nextSibling;
            continue;
          }
        }
        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {
          const movedChild = moveBeforeById(oldParent, newChild.id, insertionPoint, ctx);
          morphNode(movedChild, newChild, ctx);
          insertionPoint = movedChild.nextSibling;
          continue;
        }
        const insertedNode = createNode(oldParent, newChild, insertionPoint, ctx);
        if (insertedNode) {
          insertionPoint = insertedNode.nextSibling;
        }
      }
      while (insertionPoint && insertionPoint != endPoint) {
        const tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(ctx, tempNode);
      }
    }
    function createNode(oldParent, newChild, insertionPoint, ctx) {
      if (ctx.callbacks.beforeNodeAdded(newChild) === false)
        return null;
      if (ctx.idMap.has(newChild)) {
        const newEmptyChild = document.createElement(newChild.tagName);
        oldParent.insertBefore(newEmptyChild, insertionPoint);
        morphNode(newEmptyChild, newChild, ctx);
        ctx.callbacks.afterNodeAdded(newEmptyChild);
        return newEmptyChild;
      } else {
        const newClonedChild = document.importNode(newChild, true);
        oldParent.insertBefore(newClonedChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newClonedChild);
        return newClonedChild;
      }
    }
    const findBestMatch = function() {
      function findBestMatch2(ctx, node, startPoint, endPoint) {
        let softMatch = null;
        let nextSibling = node.nextSibling;
        let siblingSoftMatchCount = 0;
        let cursor = startPoint;
        while (cursor && cursor != endPoint) {
          if (isSoftMatch(cursor, node)) {
            if (isIdSetMatch(ctx, cursor, node)) {
              return cursor;
            }
            if (softMatch === null) {
              if (!ctx.idMap.has(cursor)) {
                softMatch = cursor;
              }
            }
          }
          if (softMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {
            siblingSoftMatchCount++;
            nextSibling = nextSibling.nextSibling;
            if (siblingSoftMatchCount >= 2) {
              softMatch = undefined;
            }
          }
          if (cursor.contains(document.activeElement))
            break;
          cursor = cursor.nextSibling;
        }
        return softMatch || null;
      }
      function isIdSetMatch(ctx, oldNode, newNode) {
        let oldSet = ctx.idMap.get(oldNode);
        let newSet = ctx.idMap.get(newNode);
        if (!newSet || !oldSet)
          return false;
        for (const id of oldSet) {
          if (newSet.has(id)) {
            return true;
          }
        }
        return false;
      }
      function isSoftMatch(oldNode, newNode) {
        const oldElt = oldNode;
        const newElt = newNode;
        return oldElt.nodeType === newElt.nodeType && oldElt.tagName === newElt.tagName && (!oldElt.id || oldElt.id === newElt.id);
      }
      return findBestMatch2;
    }();
    function removeNode(ctx, node) {
      if (ctx.idMap.has(node)) {
        moveBefore(ctx.pantry, node, null);
      } else {
        if (ctx.callbacks.beforeNodeRemoved(node) === false)
          return;
        node.parentNode?.removeChild(node);
        ctx.callbacks.afterNodeRemoved(node);
      }
    }
    function removeNodesBetween(ctx, startInclusive, endExclusive) {
      let cursor = startInclusive;
      while (cursor && cursor !== endExclusive) {
        let tempNode = cursor;
        cursor = cursor.nextSibling;
        removeNode(ctx, tempNode);
      }
      return cursor;
    }
    function moveBeforeById(parentNode, id, after, ctx) {
      const target = ctx.target.querySelector(`#${id}`) || ctx.pantry.querySelector(`#${id}`);
      removeElementFromAncestorsIdMaps(target, ctx);
      moveBefore(parentNode, target, after);
      return target;
    }
    function removeElementFromAncestorsIdMaps(element, ctx) {
      const id = element.id;
      while (element = element.parentNode) {
        let idSet = ctx.idMap.get(element);
        if (idSet) {
          idSet.delete(id);
          if (!idSet.size) {
            ctx.idMap.delete(element);
          }
        }
      }
    }
    function moveBefore(parentNode, element, after) {
      if (parentNode.moveBefore) {
        try {
          parentNode.moveBefore(element, after);
        } catch (e) {
          parentNode.insertBefore(element, after);
        }
      } else {
        parentNode.insertBefore(element, after);
      }
    }
    return morphChildren3;
  }();
  const morphNode = function() {
    function morphNode2(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement) {
        return null;
      }
      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {
        return oldNode;
      }
      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore)
        ;
      else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
        handleHeadElement(oldNode, newContent, ctx);
      } else {
        morphAttributes(oldNode, newContent, ctx);
        if (!ignoreValueOfActiveElement(oldNode, ctx)) {
          morphChildren2(ctx, oldNode, newContent);
        }
      }
      ctx.callbacks.afterNodeMorphed(oldNode, newContent);
      return oldNode;
    }
    function morphAttributes(oldNode, newNode, ctx) {
      let type = newNode.nodeType;
      if (type === 1) {
        const oldElt = oldNode;
        const newElt = newNode;
        const oldAttributes = oldElt.attributes;
        const newAttributes = newElt.attributes;
        for (const newAttribute of newAttributes) {
          if (ignoreAttribute(newAttribute.name, oldElt, "update", ctx)) {
            continue;
          }
          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {
            oldElt.setAttribute(newAttribute.name, newAttribute.value);
          }
        }
        for (let i = oldAttributes.length - 1;0 <= i; i--) {
          const oldAttribute = oldAttributes[i];
          if (!oldAttribute)
            continue;
          if (!newElt.hasAttribute(oldAttribute.name)) {
            if (ignoreAttribute(oldAttribute.name, oldElt, "remove", ctx)) {
              continue;
            }
            oldElt.removeAttribute(oldAttribute.name);
          }
        }
        if (!ignoreValueOfActiveElement(oldElt, ctx)) {
          syncInputValue(oldElt, newElt, ctx);
        }
      }
      if (type === 8 || type === 3) {
        if (oldNode.nodeValue !== newNode.nodeValue) {
          oldNode.nodeValue = newNode.nodeValue;
        }
      }
    }
    function syncInputValue(oldElement, newElement, ctx) {
      if (oldElement instanceof HTMLInputElement && newElement instanceof HTMLInputElement && newElement.type !== "file") {
        let newValue = newElement.value;
        let oldValue = oldElement.value;
        syncBooleanAttribute(oldElement, newElement, "checked", ctx);
        syncBooleanAttribute(oldElement, newElement, "disabled", ctx);
        if (!newElement.hasAttribute("value")) {
          if (!ignoreAttribute("value", oldElement, "remove", ctx)) {
            oldElement.value = "";
            oldElement.removeAttribute("value");
          }
        } else if (oldValue !== newValue) {
          if (!ignoreAttribute("value", oldElement, "update", ctx)) {
            oldElement.setAttribute("value", newValue);
            oldElement.value = newValue;
          }
        }
      } else if (oldElement instanceof HTMLOptionElement && newElement instanceof HTMLOptionElement) {
        syncBooleanAttribute(oldElement, newElement, "selected", ctx);
      } else if (oldElement instanceof HTMLTextAreaElement && newElement instanceof HTMLTextAreaElement) {
        let newValue = newElement.value;
        let oldValue = oldElement.value;
        if (ignoreAttribute("value", oldElement, "update", ctx)) {
          return;
        }
        if (newValue !== oldValue) {
          oldElement.value = newValue;
        }
        if (oldElement.firstChild && oldElement.firstChild.nodeValue !== newValue) {
          oldElement.firstChild.nodeValue = newValue;
        }
      }
    }
    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {
      const newLiveValue = newElement[attributeName], oldLiveValue = oldElement[attributeName];
      if (newLiveValue !== oldLiveValue) {
        const ignoreUpdate = ignoreAttribute(attributeName, oldElement, "update", ctx);
        if (!ignoreUpdate) {
          oldElement[attributeName] = newElement[attributeName];
        }
        if (newLiveValue) {
          if (!ignoreUpdate) {
            oldElement.setAttribute(attributeName, "");
          }
        } else {
          if (!ignoreAttribute(attributeName, oldElement, "remove", ctx)) {
            oldElement.removeAttribute(attributeName);
          }
        }
      }
    }
    function ignoreAttribute(attr, element, updateType, ctx) {
      if (attr === "value" && ctx.ignoreActiveValue && element === document.activeElement) {
        return true;
      }
      return ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) === false;
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return !!ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    return morphNode2;
  }();
  function withHeadBlocking(ctx, oldNode, newNode, callback) {
    if (ctx.head.block) {
      const oldHead = oldNode.querySelector("head");
      const newHead = newNode.querySelector("head");
      if (oldHead && newHead) {
        const promises = handleHeadElement(oldHead, newHead, ctx);
        return Promise.all(promises).then(() => {
          const newCtx = Object.assign(ctx, {
            head: {
              block: false,
              ignore: true
            }
          });
          return callback(newCtx);
        });
      }
    }
    return callback(ctx);
  }
  function handleHeadElement(oldHead, newHead, ctx) {
    let added = [];
    let removed = [];
    let preserved = [];
    let nodesToAppend = [];
    let srcToNewHeadNodes = new Map;
    for (const newHeadChild of newHead.children) {
      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
    }
    for (const currentHeadElt of oldHead.children) {
      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
      if (inNewContent || isPreserved) {
        if (isReAppended) {
          removed.push(currentHeadElt);
        } else {
          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
          preserved.push(currentHeadElt);
        }
      } else {
        if (ctx.head.style === "append") {
          if (isReAppended) {
            removed.push(currentHeadElt);
            nodesToAppend.push(currentHeadElt);
          }
        } else {
          if (ctx.head.shouldRemove(currentHeadElt) !== false) {
            removed.push(currentHeadElt);
          }
        }
      }
    }
    nodesToAppend.push(...srcToNewHeadNodes.values());
    let promises = [];
    for (const newNode of nodesToAppend) {
      let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
        if ("href" in newElt && newElt.href || "src" in newElt && newElt.src) {
          let resolve;
          let promise = new Promise(function(_resolve) {
            resolve = _resolve;
          });
          newElt.addEventListener("load", function() {
            resolve();
          });
          promises.push(promise);
        }
        oldHead.appendChild(newElt);
        ctx.callbacks.afterNodeAdded(newElt);
        added.push(newElt);
      }
    }
    for (const removedElement of removed) {
      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
        oldHead.removeChild(removedElement);
        ctx.callbacks.afterNodeRemoved(removedElement);
      }
    }
    ctx.head.afterHeadMorphed(oldHead, {
      added,
      kept: preserved,
      removed
    });
    return promises;
  }
  const createMorphContext = function() {
    function createMorphContext2(oldNode, newContent, config2) {
      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);
      const mergedConfig = mergeDefaults(config2);
      const morphStyle = mergedConfig.morphStyle || "outerHTML";
      if (!["innerHTML", "outerHTML"].includes(morphStyle)) {
        throw `Do not understand how to morph style ${morphStyle}`;
      }
      return {
        target: oldNode,
        newContent,
        config: mergedConfig,
        morphStyle,
        ignoreActive: mergedConfig.ignoreActive,
        ignoreActiveValue: mergedConfig.ignoreActiveValue,
        restoreFocus: mergedConfig.restoreFocus,
        idMap,
        persistentIds,
        pantry: createPantry(),
        callbacks: mergedConfig.callbacks,
        head: mergedConfig.head
      };
    }
    function mergeDefaults(config2) {
      let finalConfig = Object.assign({}, defaults);
      Object.assign(finalConfig, config2);
      finalConfig.callbacks = Object.assign({}, defaults.callbacks, config2.callbacks);
      finalConfig.head = Object.assign({}, defaults.head, config2.head);
      return finalConfig;
    }
    function createPantry() {
      const pantry = document.createElement("div");
      pantry.hidden = true;
      document.body.insertAdjacentElement("afterend", pantry);
      return pantry;
    }
    function findIdElements(root) {
      let elements = Array.from(root.querySelectorAll("[id]"));
      if (root.id) {
        elements.push(root);
      }
      return elements;
    }
    function populateIdMapWithTree(idMap, persistentIds, root, elements) {
      for (const elt of elements) {
        if (persistentIds.has(elt.id)) {
          let current = elt;
          while (current) {
            let idSet = idMap.get(current);
            if (idSet == null) {
              idSet = new Set;
              idMap.set(current, idSet);
            }
            idSet.add(elt.id);
            if (current === root)
              break;
            current = current.parentElement;
          }
        }
      }
    }
    function createIdMaps(oldContent, newContent) {
      const oldIdElements = findIdElements(oldContent);
      const newIdElements = findIdElements(newContent);
      const persistentIds = createPersistentIds(oldIdElements, newIdElements);
      let idMap = new Map;
      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);
      const newRoot = newContent.__idiomorphRoot || newContent;
      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);
      return { persistentIds, idMap };
    }
    function createPersistentIds(oldIdElements, newIdElements) {
      let duplicateIds = new Set;
      let oldIdTagNameMap = new Map;
      for (const { id, tagName } of oldIdElements) {
        if (oldIdTagNameMap.has(id)) {
          duplicateIds.add(id);
        } else {
          oldIdTagNameMap.set(id, tagName);
        }
      }
      let persistentIds = new Set;
      for (const { id, tagName } of newIdElements) {
        if (persistentIds.has(id)) {
          duplicateIds.add(id);
        } else if (oldIdTagNameMap.get(id) === tagName) {
          persistentIds.add(id);
        }
      }
      for (const id of duplicateIds) {
        persistentIds.delete(id);
      }
      return persistentIds;
    }
    return createMorphContext2;
  }();
  const { normalizeElement, normalizeParent } = function() {
    const generatedByIdiomorph = new WeakSet;
    function normalizeElement2(content) {
      if (content instanceof Document) {
        return content.documentElement;
      } else {
        return content;
      }
    }
    function normalizeParent2(newContent) {
      if (newContent == null) {
        return document.createElement("div");
      } else if (typeof newContent === "string") {
        return normalizeParent2(parseContent(newContent));
      } else if (generatedByIdiomorph.has(newContent)) {
        return newContent;
      } else if (newContent instanceof Node) {
        if (newContent.parentNode) {
          return createDuckTypedParent(newContent);
        } else {
          const dummyParent = document.createElement("div");
          dummyParent.append(newContent);
          return dummyParent;
        }
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function createDuckTypedParent(newContent) {
      return {
        childNodes: [newContent],
        querySelectorAll: (s) => {
          const elements = newContent.querySelectorAll(s);
          return newContent.matches(s) ? [newContent, ...elements] : elements;
        },
        insertBefore: (n, r) => newContent.parentNode.insertBefore(n, r),
        moveBefore: (n, r) => newContent.parentNode.moveBefore(n, r),
        get __idiomorphRoot() {
          return newContent;
        }
      };
    }
    function parseContent(newContent) {
      let parser = new DOMParser;
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          generatedByIdiomorph.add(content);
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            generatedByIdiomorph.add(htmlElement);
          }
          return htmlElement;
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        generatedByIdiomorph.add(content);
        return content;
      }
    }
    return { normalizeElement: normalizeElement2, normalizeParent: normalizeParent2 };
  }();
  return {
    morph,
    defaults
  };
}();

class DefaultIdiomorphCallbacks {
  #beforeNodeMorphed;
  constructor({ beforeNodeMorphed } = {}) {
    this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);
  }
  beforeNodeAdded = (node) => {
    return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
  };
  beforeNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      if (!currentElement.hasAttribute("data-turbo-permanent") && this.#beforeNodeMorphed(currentElement, newElement)) {
        const event = dispatch("turbo:before-morph-element", {
          cancelable: true,
          target: currentElement,
          detail: { currentElement, newElement }
        });
        return !event.defaultPrevented;
      } else {
        return false;
      }
    }
  };
  beforeAttributeUpdated = (attributeName, target, mutationType) => {
    const event = dispatch("turbo:before-morph-attribute", {
      cancelable: true,
      target,
      detail: { attributeName, mutationType }
    });
    return !event.defaultPrevented;
  };
  beforeNodeRemoved = (node) => {
    return this.beforeNodeMorphed(node);
  };
  afterNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      dispatch("turbo:morph-element", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
    }
  };
}

class MorphingFrameRenderer extends FrameRenderer {
  static renderElement(currentElement, newElement) {
    dispatch("turbo:before-frame-morph", {
      target: currentElement,
      detail: { currentElement, newElement }
    });
    morphChildren(currentElement, newElement);
  }
  async preservingPermanentElements(callback) {
    return await callback();
  }
}

class ProgressBar {
  static animationDuration = 300;
  static get defaultCSS() {
    return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
  }
  hiding = false;
  value = 0;
  visible = false;
  constructor() {
    this.stylesheetElement = this.createStylesheetElement();
    this.progressElement = this.createProgressElement();
    this.installStylesheetElement();
    this.setValue(0);
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this.installProgressElement();
      this.startTrickling();
    }
  }
  hide() {
    if (this.visible && !this.hiding) {
      this.hiding = true;
      this.fadeProgressElement(() => {
        this.uninstallProgressElement();
        this.stopTrickling();
        this.visible = false;
        this.hiding = false;
      });
    }
  }
  setValue(value) {
    this.value = value;
    this.refresh();
  }
  installStylesheetElement() {
    document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
  }
  installProgressElement() {
    this.progressElement.style.width = "0";
    this.progressElement.style.opacity = "1";
    document.documentElement.insertBefore(this.progressElement, document.body);
    this.refresh();
  }
  fadeProgressElement(callback) {
    this.progressElement.style.opacity = "0";
    setTimeout(callback, ProgressBar.animationDuration * 1.5);
  }
  uninstallProgressElement() {
    if (this.progressElement.parentNode) {
      document.documentElement.removeChild(this.progressElement);
    }
  }
  startTrickling() {
    if (!this.trickleInterval) {
      this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
    }
  }
  stopTrickling() {
    window.clearInterval(this.trickleInterval);
    delete this.trickleInterval;
  }
  trickle = () => {
    this.setValue(this.value + Math.random() / 100);
  };
  refresh() {
    requestAnimationFrame(() => {
      this.progressElement.style.width = `${10 + this.value * 90}%`;
    });
  }
  createStylesheetElement() {
    const element = document.createElement("style");
    element.type = "text/css";
    element.textContent = ProgressBar.defaultCSS;
    const cspNonce = getCspNonce();
    if (cspNonce) {
      element.nonce = cspNonce;
    }
    return element;
  }
  createProgressElement() {
    const element = document.createElement("div");
    element.className = "turbo-progress-bar";
    return element;
  }
}

class HeadSnapshot extends Snapshot {
  detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
    const { outerHTML } = element;
    const details = outerHTML in result ? result[outerHTML] : {
      type: elementType(element),
      tracked: elementIsTracked(element),
      elements: []
    };
    return {
      ...result,
      [outerHTML]: {
        ...details,
        elements: [...details.elements, element]
      }
    };
  }, {});
  get trackedElementSignature() {
    return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
  }
  getScriptElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
  }
  getStylesheetElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
  }
  getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
    return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
  }
  get provisionalElements() {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
      if (type == null && !tracked) {
        return [...result, ...elements];
      } else if (elements.length > 1) {
        return [...result, ...elements.slice(1)];
      } else {
        return result;
      }
    }, []);
  }
  getMetaValue(name) {
    const element = this.findMetaElementByName(name);
    return element ? element.getAttribute("content") : null;
  }
  findMetaElementByName(name) {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        elements: [element]
      } = this.detailsByOuterHTML[outerHTML];
      return elementIsMetaElementWithName(element, name) ? element : result;
    }, undefined | undefined);
  }
}

class PageSnapshot extends Snapshot {
  static fromHTMLString(html = "") {
    return this.fromDocument(parseHTMLDocument(html));
  }
  static fromElement(element) {
    return this.fromDocument(element.ownerDocument);
  }
  static fromDocument({ documentElement, body, head }) {
    return new this(documentElement, body, new HeadSnapshot(head));
  }
  constructor(documentElement, body, headSnapshot) {
    super(body);
    this.documentElement = documentElement;
    this.headSnapshot = headSnapshot;
  }
  clone() {
    const clonedElement = this.element.cloneNode(true);
    const selectElements = this.element.querySelectorAll("select");
    const clonedSelectElements = clonedElement.querySelectorAll("select");
    for (const [index, source] of selectElements.entries()) {
      const clone = clonedSelectElements[index];
      for (const option of clone.selectedOptions)
        option.selected = false;
      for (const option of source.selectedOptions)
        clone.options[option.index].selected = true;
    }
    for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
      clonedPasswordInput.value = "";
    }
    return new PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
  }
  get lang() {
    return this.documentElement.getAttribute("lang");
  }
  get headElement() {
    return this.headSnapshot.element;
  }
  get rootLocation() {
    const root = this.getSetting("root") ?? "/";
    return expandURL(root);
  }
  get cacheControlValue() {
    return this.getSetting("cache-control");
  }
  get isPreviewable() {
    return this.cacheControlValue != "no-preview";
  }
  get isCacheable() {
    return this.cacheControlValue != "no-cache";
  }
  get isVisitable() {
    return this.getSetting("visit-control") != "reload";
  }
  get prefersViewTransitions() {
    return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
  }
  get shouldMorphPage() {
    return this.getSetting("refresh-method") === "morph";
  }
  get shouldPreserveScrollPosition() {
    return this.getSetting("refresh-scroll") === "preserve";
  }
  getSetting(name) {
    return this.headSnapshot.getMetaValue(`turbo-${name}`);
  }
}

class ViewTransitioner {
  #viewTransitionStarted = false;
  #lastOperation = Promise.resolve();
  renderChange(useViewTransition, render) {
    if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
      this.#viewTransitionStarted = true;
      this.#lastOperation = this.#lastOperation.then(async () => {
        await document.startViewTransition(render).finished;
      });
    } else {
      this.#lastOperation = this.#lastOperation.then(render);
    }
    return this.#lastOperation;
  }
  get viewTransitionsAvailable() {
    return document.startViewTransition;
  }
}
var defaultOptions = {
  action: "advance",
  historyChanged: false,
  visitCachedSnapshot: () => {
  },
  willRender: true,
  updateHistory: true,
  shouldCacheSnapshot: true,
  acceptsStreamResponse: false
};
var TimingMetric = {
  visitStart: "visitStart",
  requestStart: "requestStart",
  requestEnd: "requestEnd",
  visitEnd: "visitEnd"
};
var VisitState = {
  initialized: "initialized",
  started: "started",
  canceled: "canceled",
  failed: "failed",
  completed: "completed"
};
var SystemStatusCode = {
  networkFailure: 0,
  timeoutFailure: -1,
  contentTypeMismatch: -2
};
var Direction = {
  advance: "forward",
  restore: "back",
  replace: "none"
};

class Visit {
  identifier = uuid();
  timingMetrics = {};
  followedRedirect = false;
  historyChanged = false;
  scrolled = false;
  shouldCacheSnapshot = true;
  acceptsStreamResponse = false;
  snapshotCached = false;
  state = VisitState.initialized;
  viewTransitioner = new ViewTransitioner;
  constructor(delegate, location2, restorationIdentifier, options = {}) {
    this.delegate = delegate;
    this.location = location2;
    this.restorationIdentifier = restorationIdentifier || uuid();
    const {
      action,
      historyChanged,
      referrer,
      snapshot,
      snapshotHTML,
      response,
      visitCachedSnapshot,
      willRender,
      updateHistory,
      shouldCacheSnapshot,
      acceptsStreamResponse,
      direction
    } = {
      ...defaultOptions,
      ...options
    };
    this.action = action;
    this.historyChanged = historyChanged;
    this.referrer = referrer;
    this.snapshot = snapshot;
    this.snapshotHTML = snapshotHTML;
    this.response = response;
    this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
    this.isPageRefresh = this.view.isPageRefresh(this);
    this.visitCachedSnapshot = visitCachedSnapshot;
    this.willRender = willRender;
    this.updateHistory = updateHistory;
    this.scrolled = !willRender;
    this.shouldCacheSnapshot = shouldCacheSnapshot;
    this.acceptsStreamResponse = acceptsStreamResponse;
    this.direction = direction || Direction[action];
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get history() {
    return this.delegate.history;
  }
  get restorationData() {
    return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
  }
  get silent() {
    return this.isSamePage;
  }
  start() {
    if (this.state == VisitState.initialized) {
      this.recordTimingMetric(TimingMetric.visitStart);
      this.state = VisitState.started;
      this.adapter.visitStarted(this);
      this.delegate.visitStarted(this);
    }
  }
  cancel() {
    if (this.state == VisitState.started) {
      if (this.request) {
        this.request.cancel();
      }
      this.cancelRender();
      this.state = VisitState.canceled;
    }
  }
  complete() {
    if (this.state == VisitState.started) {
      this.recordTimingMetric(TimingMetric.visitEnd);
      this.adapter.visitCompleted(this);
      this.state = VisitState.completed;
      this.followRedirect();
      if (!this.followedRedirect) {
        this.delegate.visitCompleted(this);
      }
    }
  }
  fail() {
    if (this.state == VisitState.started) {
      this.state = VisitState.failed;
      this.adapter.visitFailed(this);
      this.delegate.visitCompleted(this);
    }
  }
  changeHistory() {
    if (!this.historyChanged && this.updateHistory) {
      const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
      const method = getHistoryMethodForAction(actionForHistory);
      this.history.update(method, this.location, this.restorationIdentifier);
      this.historyChanged = true;
    }
  }
  issueRequest() {
    if (this.hasPreloadedResponse()) {
      this.simulateRequest();
    } else if (this.shouldIssueRequest() && !this.request) {
      this.request = new FetchRequest(this, FetchMethod.get, this.location);
      this.request.perform();
    }
  }
  simulateRequest() {
    if (this.response) {
      this.startRequest();
      this.recordResponse();
      this.finishRequest();
    }
  }
  startRequest() {
    this.recordTimingMetric(TimingMetric.requestStart);
    this.adapter.visitRequestStarted(this);
  }
  recordResponse(response = this.response) {
    this.response = response;
    if (response) {
      const { statusCode } = response;
      if (isSuccessful(statusCode)) {
        this.adapter.visitRequestCompleted(this);
      } else {
        this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
      }
    }
  }
  finishRequest() {
    this.recordTimingMetric(TimingMetric.requestEnd);
    this.adapter.visitRequestFinished(this);
  }
  loadResponse() {
    if (this.response) {
      const { statusCode, responseHTML } = this.response;
      this.render(async () => {
        if (this.shouldCacheSnapshot)
          this.cacheSnapshot();
        if (this.view.renderPromise)
          await this.view.renderPromise;
        if (isSuccessful(statusCode) && responseHTML != null) {
          const snapshot = PageSnapshot.fromHTMLString(responseHTML);
          await this.renderPageSnapshot(snapshot, false);
          this.adapter.visitRendered(this);
          this.complete();
        } else {
          await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
          this.adapter.visitRendered(this);
          this.fail();
        }
      });
    }
  }
  getCachedSnapshot() {
    const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
    if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
      if (this.action == "restore" || snapshot.isPreviewable) {
        return snapshot;
      }
    }
  }
  getPreloadedSnapshot() {
    if (this.snapshotHTML) {
      return PageSnapshot.fromHTMLString(this.snapshotHTML);
    }
  }
  hasCachedSnapshot() {
    return this.getCachedSnapshot() != null;
  }
  loadCachedSnapshot() {
    const snapshot = this.getCachedSnapshot();
    if (snapshot) {
      const isPreview = this.shouldIssueRequest();
      this.render(async () => {
        this.cacheSnapshot();
        if (this.isSamePage || this.isPageRefresh) {
          this.adapter.visitRendered(this);
        } else {
          if (this.view.renderPromise)
            await this.view.renderPromise;
          await this.renderPageSnapshot(snapshot, isPreview);
          this.adapter.visitRendered(this);
          if (!isPreview) {
            this.complete();
          }
        }
      });
    }
  }
  followRedirect() {
    if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
      this.adapter.visitProposedToLocation(this.redirectedToLocation, {
        action: "replace",
        response: this.response,
        shouldCacheSnapshot: false,
        willRender: false
      });
      this.followedRedirect = true;
    }
  }
  goToSamePageAnchor() {
    if (this.isSamePage) {
      this.render(async () => {
        this.cacheSnapshot();
        this.performScroll();
        this.changeHistory();
        this.adapter.visitRendered(this);
      });
    }
  }
  prepareRequest(request) {
    if (this.acceptsStreamResponse) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted() {
    this.startRequest();
  }
  requestPreventedHandlingResponse(_request, _response) {
  }
  async requestSucceededWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.redirectedToLocation = response.redirected ? response.location : undefined;
      this.recordResponse({ statusCode, responseHTML, redirected });
    }
  }
  async requestFailedWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.recordResponse({ statusCode, responseHTML, redirected });
    }
  }
  requestErrored(_request, _error) {
    this.recordResponse({
      statusCode: SystemStatusCode.networkFailure,
      redirected: false
    });
  }
  requestFinished() {
    this.finishRequest();
  }
  performScroll() {
    if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
      if (this.action == "restore") {
        this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
      } else {
        this.scrollToAnchor() || this.view.scrollToTop();
      }
      if (this.isSamePage) {
        this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
      }
      this.scrolled = true;
    }
  }
  scrollToRestoredPosition() {
    const { scrollPosition } = this.restorationData;
    if (scrollPosition) {
      this.view.scrollToPosition(scrollPosition);
      return true;
    }
  }
  scrollToAnchor() {
    const anchor = getAnchor(this.location);
    if (anchor != null) {
      this.view.scrollToAnchor(anchor);
      return true;
    }
  }
  recordTimingMetric(metric) {
    this.timingMetrics[metric] = new Date().getTime();
  }
  getTimingMetrics() {
    return { ...this.timingMetrics };
  }
  hasPreloadedResponse() {
    return typeof this.response == "object";
  }
  shouldIssueRequest() {
    if (this.isSamePage) {
      return false;
    } else if (this.action == "restore") {
      return !this.hasCachedSnapshot();
    } else {
      return this.willRender;
    }
  }
  cacheSnapshot() {
    if (!this.snapshotCached) {
      this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
      this.snapshotCached = true;
    }
  }
  async render(callback) {
    this.cancelRender();
    await new Promise((resolve) => {
      this.frame = document.visibilityState === "hidden" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());
    });
    await callback();
    delete this.frame;
  }
  async renderPageSnapshot(snapshot, isPreview) {
    await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
      await this.view.renderPage(snapshot, isPreview, this.willRender, this);
      this.performScroll();
    });
  }
  cancelRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
      delete this.frame;
    }
  }
}

class BrowserAdapter {
  progressBar = new ProgressBar;
  constructor(session) {
    this.session = session;
  }
  visitProposedToLocation(location2, options) {
    if (locationIsVisitable(location2, this.navigator.rootLocation)) {
      this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
    } else {
      window.location.href = location2.toString();
    }
  }
  visitStarted(visit2) {
    this.location = visit2.location;
    visit2.loadCachedSnapshot();
    visit2.issueRequest();
    visit2.goToSamePageAnchor();
  }
  visitRequestStarted(visit2) {
    this.progressBar.setValue(0);
    if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
      this.showVisitProgressBarAfterDelay();
    } else {
      this.showProgressBar();
    }
  }
  visitRequestCompleted(visit2) {
    visit2.loadResponse();
  }
  visitRequestFailedWithStatusCode(visit2, statusCode) {
    switch (statusCode) {
      case SystemStatusCode.networkFailure:
      case SystemStatusCode.timeoutFailure:
      case SystemStatusCode.contentTypeMismatch:
        return this.reload({
          reason: "request_failed",
          context: {
            statusCode
          }
        });
      default:
        return visit2.loadResponse();
    }
  }
  visitRequestFinished(_visit) {
  }
  visitCompleted(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  pageInvalidated(reason) {
    this.reload(reason);
  }
  visitFailed(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  visitRendered(_visit) {
  }
  linkPrefetchingIsEnabledForLocation(location2) {
    return true;
  }
  formSubmissionStarted(_formSubmission) {
    this.progressBar.setValue(0);
    this.showFormProgressBarAfterDelay();
  }
  formSubmissionFinished(_formSubmission) {
    this.progressBar.setValue(1);
    this.hideFormProgressBar();
  }
  showVisitProgressBarAfterDelay() {
    this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
  }
  hideVisitProgressBar() {
    this.progressBar.hide();
    if (this.visitProgressBarTimeout != null) {
      window.clearTimeout(this.visitProgressBarTimeout);
      delete this.visitProgressBarTimeout;
    }
  }
  showFormProgressBarAfterDelay() {
    if (this.formProgressBarTimeout == null) {
      this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
  }
  hideFormProgressBar() {
    this.progressBar.hide();
    if (this.formProgressBarTimeout != null) {
      window.clearTimeout(this.formProgressBarTimeout);
      delete this.formProgressBarTimeout;
    }
  }
  showProgressBar = () => {
    this.progressBar.show();
  };
  reload(reason) {
    dispatch("turbo:reload", { detail: reason });
    window.location.href = this.location?.toString() || window.location.href;
  }
  get navigator() {
    return this.session.navigator;
  }
}

class CacheObserver {
  selector = "[data-turbo-temporary]";
  deprecatedSelector = "[data-turbo-cache=false]";
  started = false;
  start() {
    if (!this.started) {
      this.started = true;
      addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  removeTemporaryElements = (_event) => {
    for (const element of this.temporaryElements) {
      element.remove();
    }
  };
  get temporaryElements() {
    return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
  }
  get temporaryElementsWithDeprecation() {
    const elements = document.querySelectorAll(this.deprecatedSelector);
    if (elements.length) {
      console.warn(`The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`);
    }
    return [...elements];
  }
}

class FrameRedirector {
  constructor(session, element) {
    this.session = session;
    this.element = element;
    this.linkInterceptor = new LinkInterceptor(this, element);
    this.formSubmitObserver = new FormSubmitObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
    this.formSubmitObserver.start();
  }
  stop() {
    this.linkInterceptor.stop();
    this.formSubmitObserver.stop();
  }
  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldRedirect(element);
  }
  linkClickIntercepted(element, url, event) {
    const frame = this.#findFrameElement(element);
    if (frame) {
      frame.delegate.linkClickIntercepted(element, url, event);
    }
  }
  willSubmitForm(element, submitter2) {
    return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter2) && this.#shouldRedirect(element, submitter2);
  }
  formSubmitted(element, submitter2) {
    const frame = this.#findFrameElement(element, submitter2);
    if (frame) {
      frame.delegate.formSubmitted(element, submitter2);
    }
  }
  #shouldSubmit(form, submitter2) {
    const action = getAction$1(form, submitter2);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL(meta?.content ?? "/");
    return this.#shouldRedirect(form, submitter2) && locationIsVisitable(action, rootLocation);
  }
  #shouldRedirect(element, submitter2) {
    const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter2) : this.session.elementIsNavigatable(element);
    if (isNavigatable) {
      const frame = this.#findFrameElement(element, submitter2);
      return frame ? frame != element.closest("turbo-frame") : false;
    } else {
      return false;
    }
  }
  #findFrameElement(element, submitter2) {
    const id = submitter2?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
    if (id && id != "_top") {
      const frame = this.element.querySelector(`#${id}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame;
      }
    }
  }
}

class History {
  location;
  restorationIdentifier = uuid();
  restorationData = {};
  started = false;
  pageLoaded = false;
  currentIndex = 0;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("popstate", this.onPopState, false);
      addEventListener("load", this.onPageLoad, false);
      this.currentIndex = history.state?.turbo?.restorationIndex || 0;
      this.started = true;
      this.replace(new URL(window.location.href));
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("popstate", this.onPopState, false);
      removeEventListener("load", this.onPageLoad, false);
      this.started = false;
    }
  }
  push(location2, restorationIdentifier) {
    this.update(history.pushState, location2, restorationIdentifier);
  }
  replace(location2, restorationIdentifier) {
    this.update(history.replaceState, location2, restorationIdentifier);
  }
  update(method, location2, restorationIdentifier = uuid()) {
    if (method === history.pushState)
      ++this.currentIndex;
    const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
    method.call(history, state, "", location2.href);
    this.location = location2;
    this.restorationIdentifier = restorationIdentifier;
  }
  getRestorationDataForIdentifier(restorationIdentifier) {
    return this.restorationData[restorationIdentifier] || {};
  }
  updateRestorationData(additionalData) {
    const { restorationIdentifier } = this;
    const restorationData = this.restorationData[restorationIdentifier];
    this.restorationData[restorationIdentifier] = {
      ...restorationData,
      ...additionalData
    };
  }
  assumeControlOfScrollRestoration() {
    if (!this.previousScrollRestoration) {
      this.previousScrollRestoration = history.scrollRestoration ?? "auto";
      history.scrollRestoration = "manual";
    }
  }
  relinquishControlOfScrollRestoration() {
    if (this.previousScrollRestoration) {
      history.scrollRestoration = this.previousScrollRestoration;
      delete this.previousScrollRestoration;
    }
  }
  onPopState = (event) => {
    if (this.shouldHandlePopState()) {
      const { turbo } = event.state || {};
      if (turbo) {
        this.location = new URL(window.location.href);
        const { restorationIdentifier, restorationIndex } = turbo;
        this.restorationIdentifier = restorationIdentifier;
        const direction = restorationIndex > this.currentIndex ? "forward" : "back";
        this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
        this.currentIndex = restorationIndex;
      }
    }
  };
  onPageLoad = async (_event) => {
    await nextMicrotask();
    this.pageLoaded = true;
  };
  shouldHandlePopState() {
    return this.pageIsLoaded();
  }
  pageIsLoaded() {
    return this.pageLoaded || document.readyState == "complete";
  }
}

class LinkPrefetchObserver {
  started = false;
  #prefetchedLink = null;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (this.started)
      return;
    if (this.eventTarget.readyState === "loading") {
      this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
    } else {
      this.#enable();
    }
  }
  stop() {
    if (!this.started)
      return;
    this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = false;
  }
  #enable = () => {
    this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = true;
  };
  #tryToPrefetchRequest = (event) => {
    if (getMetaContent("turbo-prefetch") === "false")
      return;
    const target = event.target;
    const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
    if (isLink && this.#isPrefetchable(target)) {
      const link = target;
      const location2 = getLocationForLink(link);
      if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
        this.#prefetchedLink = link;
        const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams, target);
        prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
      }
    }
  };
  #cancelRequestIfObsolete = (event) => {
    if (event.target === this.#prefetchedLink)
      this.#cancelPrefetchRequest();
  };
  #cancelPrefetchRequest = () => {
    prefetchCache.clear();
    this.#prefetchedLink = null;
  };
  #tryToUsePrefetchedRequest = (event) => {
    if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "GET") {
      const cached = prefetchCache.get(event.detail.url.toString());
      if (cached) {
        event.detail.fetchRequest = cached;
      }
      prefetchCache.clear();
    }
  };
  prepareRequest(request) {
    const link = request.target;
    request.headers["X-Sec-Purpose"] = "prefetch";
    const turboFrame = link.closest("turbo-frame");
    const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
    if (turboFrameTarget && turboFrameTarget !== "_top") {
      request.headers["Turbo-Frame"] = turboFrameTarget;
    }
  }
  requestSucceededWithResponse() {
  }
  requestStarted(fetchRequest) {
  }
  requestErrored(fetchRequest) {
  }
  requestFinished(fetchRequest) {
  }
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
  }
  requestFailedWithResponse(fetchRequest, fetchResponse) {
  }
  get #cacheTtl() {
    return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
  }
  #isPrefetchable(link) {
    const href = link.getAttribute("href");
    if (!href)
      return false;
    if (unfetchableLink(link))
      return false;
    if (linkToTheSamePage(link))
      return false;
    if (linkOptsOut(link))
      return false;
    if (nonSafeLink(link))
      return false;
    if (eventPrevented(link))
      return false;
    return true;
  }
}
var unfetchableLink = (link) => {
  return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
};
var linkToTheSamePage = (link) => {
  return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
};
var linkOptsOut = (link) => {
  if (link.getAttribute("data-turbo-prefetch") === "false")
    return true;
  if (link.getAttribute("data-turbo") === "false")
    return true;
  const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
  if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false")
    return true;
  return false;
};
var nonSafeLink = (link) => {
  const turboMethod = link.getAttribute("data-turbo-method");
  if (turboMethod && turboMethod.toLowerCase() !== "get")
    return true;
  if (isUJS(link))
    return true;
  if (link.hasAttribute("data-turbo-confirm"))
    return true;
  if (link.hasAttribute("data-turbo-stream"))
    return true;
  return false;
};
var isUJS = (link) => {
  return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
};
var eventPrevented = (link) => {
  const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
  return event.defaultPrevented;
};

class Navigator {
  constructor(delegate) {
    this.delegate = delegate;
  }
  proposeVisit(location2, options = {}) {
    if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
      this.delegate.visitProposedToLocation(location2, options);
    }
  }
  startVisit(locatable, restorationIdentifier, options = {}) {
    this.stop();
    this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
      referrer: this.location,
      ...options
    });
    this.currentVisit.start();
  }
  submitForm(form, submitter2) {
    this.stop();
    this.formSubmission = new FormSubmission(this, form, submitter2, true);
    this.formSubmission.start();
  }
  stop() {
    if (this.formSubmission) {
      this.formSubmission.stop();
      delete this.formSubmission;
    }
    if (this.currentVisit) {
      this.currentVisit.cancel();
      delete this.currentVisit;
    }
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get rootLocation() {
    return this.view.snapshot.rootLocation;
  }
  get history() {
    return this.delegate.history;
  }
  formSubmissionStarted(formSubmission) {
    if (typeof this.adapter.formSubmissionStarted === "function") {
      this.adapter.formSubmissionStarted(formSubmission);
    }
  }
  async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
    if (formSubmission == this.formSubmission) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const shouldCacheSnapshot = formSubmission.isSafe;
        if (!shouldCacheSnapshot) {
          this.view.clearSnapshotCache();
        }
        const { statusCode, redirected } = fetchResponse;
        const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
        const visitOptions = {
          action,
          shouldCacheSnapshot,
          response: { statusCode, responseHTML, redirected }
        };
        this.proposeVisit(fetchResponse.location, visitOptions);
      }
    }
  }
  async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    const responseHTML = await fetchResponse.responseHTML;
    if (responseHTML) {
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      if (fetchResponse.serverError) {
        await this.view.renderError(snapshot, this.currentVisit);
      } else {
        await this.view.renderPage(snapshot, false, true, this.currentVisit);
      }
      if (!snapshot.shouldPreserveScrollPosition) {
        this.view.scrollToTop();
      }
      this.view.clearSnapshotCache();
    }
  }
  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }
  formSubmissionFinished(formSubmission) {
    if (typeof this.adapter.formSubmissionFinished === "function") {
      this.adapter.formSubmissionFinished(formSubmission);
    }
  }
  linkPrefetchingIsEnabledForLocation(location2) {
    if (typeof this.adapter.linkPrefetchingIsEnabledForLocation === "function") {
      return this.adapter.linkPrefetchingIsEnabledForLocation(location2);
    }
    return true;
  }
  visitStarted(visit2) {
    this.delegate.visitStarted(visit2);
  }
  visitCompleted(visit2) {
    this.delegate.visitCompleted(visit2);
    delete this.currentVisit;
  }
  locationWithActionIsSamePage(location2, action) {
    const anchor = getAnchor(location2);
    const currentAnchor = getAnchor(this.view.lastRenderedLocation);
    const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
    return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  #getActionForFormSubmission(formSubmission, fetchResponse) {
    const { submitter: submitter2, formElement } = formSubmission;
    return getVisitAction(submitter2, formElement) || this.#getDefaultAction(fetchResponse);
  }
  #getDefaultAction(fetchResponse) {
    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
    return sameLocationRedirect ? "replace" : "advance";
  }
}
var PageStage = {
  initial: 0,
  loading: 1,
  interactive: 2,
  complete: 3
};

class PageObserver {
  stage = PageStage.initial;
  started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      if (this.stage == PageStage.initial) {
        this.stage = PageStage.loading;
      }
      document.addEventListener("readystatechange", this.interpretReadyState, false);
      addEventListener("pagehide", this.pageWillUnload, false);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      document.removeEventListener("readystatechange", this.interpretReadyState, false);
      removeEventListener("pagehide", this.pageWillUnload, false);
      this.started = false;
    }
  }
  interpretReadyState = () => {
    const { readyState } = this;
    if (readyState == "interactive") {
      this.pageIsInteractive();
    } else if (readyState == "complete") {
      this.pageIsComplete();
    }
  };
  pageIsInteractive() {
    if (this.stage == PageStage.loading) {
      this.stage = PageStage.interactive;
      this.delegate.pageBecameInteractive();
    }
  }
  pageIsComplete() {
    this.pageIsInteractive();
    if (this.stage == PageStage.interactive) {
      this.stage = PageStage.complete;
      this.delegate.pageLoaded();
    }
  }
  pageWillUnload = () => {
    this.delegate.pageWillUnload();
  };
  get readyState() {
    return document.readyState;
  }
}

class ScrollObserver {
  started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("scroll", this.onScroll, false);
      this.onScroll();
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("scroll", this.onScroll, false);
      this.started = false;
    }
  }
  onScroll = () => {
    this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
  };
  updatePosition(position) {
    this.delegate.scrollPositionChanged(position);
  }
}

class StreamMessageRenderer {
  render({ fragment }) {
    Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
      withAutofocusFromFragment(fragment, () => {
        withPreservedFocus(() => {
          document.documentElement.appendChild(fragment);
        });
      });
    });
  }
  enteringBardo(currentPermanentElement, newPermanentElement) {
    newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
  }
  leavingBardo() {
  }
}

class StreamObserver {
  sources = new Set;
  #started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.#started) {
      this.#started = true;
      addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  stop() {
    if (this.#started) {
      this.#started = false;
      removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  connectStreamSource(source) {
    if (!this.streamSourceIsConnected(source)) {
      this.sources.add(source);
      source.addEventListener("message", this.receiveMessageEvent, false);
    }
  }
  disconnectStreamSource(source) {
    if (this.streamSourceIsConnected(source)) {
      this.sources.delete(source);
      source.removeEventListener("message", this.receiveMessageEvent, false);
    }
  }
  streamSourceIsConnected(source) {
    return this.sources.has(source);
  }
  inspectFetchResponse = (event) => {
    const response = fetchResponseFromEvent(event);
    if (response && fetchResponseIsStream(response)) {
      event.preventDefault();
      this.receiveMessageResponse(response);
    }
  };
  receiveMessageEvent = (event) => {
    if (this.#started && typeof event.data == "string") {
      this.receiveMessageHTML(event.data);
    }
  };
  async receiveMessageResponse(response) {
    const html = await response.responseHTML;
    if (html) {
      this.receiveMessageHTML(html);
    }
  }
  receiveMessageHTML(html) {
    this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
  }
}

class ErrorRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const { documentElement, body } = document;
    documentElement.replaceChild(newElement, body);
  }
  async render() {
    this.replaceHeadAndBody();
    this.activateScriptElements();
  }
  replaceHeadAndBody() {
    const { documentElement, head } = document;
    documentElement.replaceChild(this.newHead, head);
    this.renderElement(this.currentElement, this.newElement);
  }
  activateScriptElements() {
    for (const replaceableElement of this.scriptElements) {
      const parentNode = replaceableElement.parentNode;
      if (parentNode) {
        const element = activateScriptElement(replaceableElement);
        parentNode.replaceChild(element, replaceableElement);
      }
    }
  }
  get newHead() {
    return this.newSnapshot.headSnapshot.element;
  }
  get scriptElements() {
    return document.documentElement.querySelectorAll("script");
  }
}

class PageRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    if (document.body && newElement instanceof HTMLBodyElement) {
      document.body.replaceWith(newElement);
    } else {
      document.documentElement.appendChild(newElement);
    }
  }
  get shouldRender() {
    return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
  }
  get reloadReason() {
    if (!this.newSnapshot.isVisitable) {
      return {
        reason: "turbo_visit_control_is_reload"
      };
    }
    if (!this.trackedElementsAreIdentical) {
      return {
        reason: "tracked_element_mismatch"
      };
    }
  }
  async prepareToRender() {
    this.#setLanguage();
    await this.mergeHead();
  }
  async render() {
    if (this.willRender) {
      await this.replaceBody();
    }
  }
  finishRendering() {
    super.finishRendering();
    if (!this.isPreview) {
      this.focusFirstAutofocusableElement();
    }
  }
  get currentHeadSnapshot() {
    return this.currentSnapshot.headSnapshot;
  }
  get newHeadSnapshot() {
    return this.newSnapshot.headSnapshot;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  #setLanguage() {
    const { documentElement } = this.currentSnapshot;
    const { lang } = this.newSnapshot;
    if (lang) {
      documentElement.setAttribute("lang", lang);
    } else {
      documentElement.removeAttribute("lang");
    }
  }
  async mergeHead() {
    const mergedHeadElements = this.mergeProvisionalElements();
    const newStylesheetElements = this.copyNewHeadStylesheetElements();
    this.copyNewHeadScriptElements();
    await mergedHeadElements;
    await newStylesheetElements;
    if (this.willRender) {
      this.removeUnusedDynamicStylesheetElements();
    }
  }
  async replaceBody() {
    await this.preservingPermanentElements(async () => {
      this.activateNewBody();
      await this.assignNewBody();
    });
  }
  get trackedElementsAreIdentical() {
    return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
  }
  async copyNewHeadStylesheetElements() {
    const loadingElements = [];
    for (const element of this.newHeadStylesheetElements) {
      loadingElements.push(waitForLoad(element));
      document.head.appendChild(element);
    }
    await Promise.all(loadingElements);
  }
  copyNewHeadScriptElements() {
    for (const element of this.newHeadScriptElements) {
      document.head.appendChild(activateScriptElement(element));
    }
  }
  removeUnusedDynamicStylesheetElements() {
    for (const element of this.unusedDynamicStylesheetElements) {
      document.head.removeChild(element);
    }
  }
  async mergeProvisionalElements() {
    const newHeadElements = [...this.newHeadProvisionalElements];
    for (const element of this.currentHeadProvisionalElements) {
      if (!this.isCurrentElementInElementList(element, newHeadElements)) {
        document.head.removeChild(element);
      }
    }
    for (const element of newHeadElements) {
      document.head.appendChild(element);
    }
  }
  isCurrentElementInElementList(element, elementList) {
    for (const [index, newElement] of elementList.entries()) {
      if (element.tagName == "TITLE") {
        if (newElement.tagName != "TITLE") {
          continue;
        }
        if (element.innerHTML == newElement.innerHTML) {
          elementList.splice(index, 1);
          return true;
        }
      }
      if (newElement.isEqualNode(element)) {
        elementList.splice(index, 1);
        return true;
      }
    }
    return false;
  }
  removeCurrentHeadProvisionalElements() {
    for (const element of this.currentHeadProvisionalElements) {
      document.head.removeChild(element);
    }
  }
  copyNewHeadProvisionalElements() {
    for (const element of this.newHeadProvisionalElements) {
      document.head.appendChild(element);
    }
  }
  activateNewBody() {
    document.adoptNode(this.newElement);
    this.activateNewBodyScriptElements();
  }
  activateNewBodyScriptElements() {
    for (const inertScriptElement of this.newBodyScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  async assignNewBody() {
    await this.renderElement(this.currentElement, this.newElement);
  }
  get unusedDynamicStylesheetElements() {
    return this.oldHeadStylesheetElements.filter((element) => {
      return element.getAttribute("data-turbo-track") === "dynamic";
    });
  }
  get oldHeadStylesheetElements() {
    return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
  }
  get newHeadStylesheetElements() {
    return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get newHeadScriptElements() {
    return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get currentHeadProvisionalElements() {
    return this.currentHeadSnapshot.provisionalElements;
  }
  get newHeadProvisionalElements() {
    return this.newHeadSnapshot.provisionalElements;
  }
  get newBodyScriptElements() {
    return this.newElement.querySelectorAll("script");
  }
}

class MorphingPageRenderer extends PageRenderer {
  static renderElement(currentElement, newElement) {
    morphElements(currentElement, newElement, {
      callbacks: {
        beforeNodeMorphed: (element) => !canRefreshFrame(element)
      }
    });
    for (const frame of currentElement.querySelectorAll("turbo-frame")) {
      if (canRefreshFrame(frame))
        frame.reload();
    }
    dispatch("turbo:morph", { detail: { currentElement, newElement } });
  }
  async preservingPermanentElements(callback) {
    return await callback();
  }
  get renderMethod() {
    return "morph";
  }
  get shouldAutofocus() {
    return false;
  }
}

class SnapshotCache {
  keys = [];
  snapshots = {};
  constructor(size) {
    this.size = size;
  }
  has(location2) {
    return toCacheKey(location2) in this.snapshots;
  }
  get(location2) {
    if (this.has(location2)) {
      const snapshot = this.read(location2);
      this.touch(location2);
      return snapshot;
    }
  }
  put(location2, snapshot) {
    this.write(location2, snapshot);
    this.touch(location2);
    return snapshot;
  }
  clear() {
    this.snapshots = {};
  }
  read(location2) {
    return this.snapshots[toCacheKey(location2)];
  }
  write(location2, snapshot) {
    this.snapshots[toCacheKey(location2)] = snapshot;
  }
  touch(location2) {
    const key = toCacheKey(location2);
    const index = this.keys.indexOf(key);
    if (index > -1)
      this.keys.splice(index, 1);
    this.keys.unshift(key);
    this.trim();
  }
  trim() {
    for (const key of this.keys.splice(this.size)) {
      delete this.snapshots[key];
    }
  }
}

class PageView extends View {
  snapshotCache = new SnapshotCache(10);
  lastRenderedLocation = new URL(location.href);
  forceReloaded = false;
  shouldTransitionTo(newSnapshot) {
    return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
  }
  renderPage(snapshot, isPreview = false, willRender = true, visit2) {
    const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
    const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
    const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);
    if (!renderer.shouldRender) {
      this.forceReloaded = true;
    } else {
      visit2?.changeHistory();
    }
    return this.render(renderer);
  }
  renderError(snapshot, visit2) {
    visit2?.changeHistory();
    const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
    return this.render(renderer);
  }
  clearSnapshotCache() {
    this.snapshotCache.clear();
  }
  async cacheSnapshot(snapshot = this.snapshot) {
    if (snapshot.isCacheable) {
      this.delegate.viewWillCacheSnapshot();
      const { lastRenderedLocation: location2 } = this;
      await nextEventLoopTick();
      const cachedSnapshot = snapshot.clone();
      this.snapshotCache.put(location2, cachedSnapshot);
      return cachedSnapshot;
    }
  }
  getCachedSnapshotForLocation(location2) {
    return this.snapshotCache.get(location2);
  }
  isPageRefresh(visit2) {
    return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
  }
  shouldPreserveScrollPosition(visit2) {
    return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
  }
  get snapshot() {
    return PageSnapshot.fromElement(this.element);
  }
}

class Preloader {
  selector = "a[data-turbo-preload]";
  constructor(delegate, snapshotCache) {
    this.delegate = delegate;
    this.snapshotCache = snapshotCache;
  }
  start() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", this.#preloadAll);
    } else {
      this.preloadOnLoadLinksForView(document.body);
    }
  }
  stop() {
    document.removeEventListener("DOMContentLoaded", this.#preloadAll);
  }
  preloadOnLoadLinksForView(element) {
    for (const link of element.querySelectorAll(this.selector)) {
      if (this.delegate.shouldPreloadLink(link)) {
        this.preloadURL(link);
      }
    }
  }
  async preloadURL(link) {
    const location2 = new URL(link.href);
    if (this.snapshotCache.has(location2)) {
      return;
    }
    const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams, link);
    await fetchRequest.perform();
  }
  prepareRequest(fetchRequest) {
    fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
  }
  async requestSucceededWithResponse(fetchRequest, fetchResponse) {
    try {
      const responseHTML = await fetchResponse.responseHTML;
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      this.snapshotCache.put(fetchRequest.url, snapshot);
    } catch (_) {
    }
  }
  requestStarted(fetchRequest) {
  }
  requestErrored(fetchRequest) {
  }
  requestFinished(fetchRequest) {
  }
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
  }
  requestFailedWithResponse(fetchRequest, fetchResponse) {
  }
  #preloadAll = () => {
    this.preloadOnLoadLinksForView(document.body);
  };
}

class Cache {
  constructor(session) {
    this.session = session;
  }
  clear() {
    this.session.clearCache();
  }
  resetCacheControl() {
    this.#setCacheControl("");
  }
  exemptPageFromCache() {
    this.#setCacheControl("no-cache");
  }
  exemptPageFromPreview() {
    this.#setCacheControl("no-preview");
  }
  #setCacheControl(value) {
    setMetaContent("turbo-cache-control", value);
  }
}

class Session {
  navigator = new Navigator(this);
  history = new History(this);
  view = new PageView(this, document.documentElement);
  adapter = new BrowserAdapter(this);
  pageObserver = new PageObserver(this);
  cacheObserver = new CacheObserver;
  linkPrefetchObserver = new LinkPrefetchObserver(this, document);
  linkClickObserver = new LinkClickObserver(this, window);
  formSubmitObserver = new FormSubmitObserver(this, document);
  scrollObserver = new ScrollObserver(this);
  streamObserver = new StreamObserver(this);
  formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
  frameRedirector = new FrameRedirector(this, document.documentElement);
  streamMessageRenderer = new StreamMessageRenderer;
  cache = new Cache(this);
  enabled = true;
  started = false;
  #pageRefreshDebouncePeriod = 150;
  constructor(recentRequests2) {
    this.recentRequests = recentRequests2;
    this.preloader = new Preloader(this, this.view.snapshotCache);
    this.debouncedRefresh = this.refresh;
    this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
  }
  start() {
    if (!this.started) {
      this.pageObserver.start();
      this.cacheObserver.start();
      this.linkPrefetchObserver.start();
      this.formLinkClickObserver.start();
      this.linkClickObserver.start();
      this.formSubmitObserver.start();
      this.scrollObserver.start();
      this.streamObserver.start();
      this.frameRedirector.start();
      this.history.start();
      this.preloader.start();
      this.started = true;
      this.enabled = true;
    }
  }
  disable() {
    this.enabled = false;
  }
  stop() {
    if (this.started) {
      this.pageObserver.stop();
      this.cacheObserver.stop();
      this.linkPrefetchObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkClickObserver.stop();
      this.formSubmitObserver.stop();
      this.scrollObserver.stop();
      this.streamObserver.stop();
      this.frameRedirector.stop();
      this.history.stop();
      this.preloader.stop();
      this.started = false;
    }
  }
  registerAdapter(adapter) {
    this.adapter = adapter;
  }
  visit(location2, options = {}) {
    const frameElement = options.frame ? document.getElementById(options.frame) : null;
    if (frameElement instanceof FrameElement) {
      const action = options.action || getVisitAction(frameElement);
      frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
      frameElement.src = location2.toString();
    } else {
      this.navigator.proposeVisit(expandURL(location2), options);
    }
  }
  refresh(url, requestId) {
    const isRecentRequest = requestId && this.recentRequests.has(requestId);
    const isCurrentUrl = url === document.baseURI;
    if (!isRecentRequest && !this.navigator.currentVisit && isCurrentUrl) {
      this.visit(url, { action: "replace", shouldCacheSnapshot: false });
    }
  }
  connectStreamSource(source) {
    this.streamObserver.connectStreamSource(source);
  }
  disconnectStreamSource(source) {
    this.streamObserver.disconnectStreamSource(source);
  }
  renderStreamMessage(message) {
    this.streamMessageRenderer.render(StreamMessage.wrap(message));
  }
  clearCache() {
    this.view.clearSnapshotCache();
  }
  setProgressBarDelay(delay) {
    console.warn("Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`");
    this.progressBarDelay = delay;
  }
  set progressBarDelay(delay) {
    config.drive.progressBarDelay = delay;
  }
  get progressBarDelay() {
    return config.drive.progressBarDelay;
  }
  set drive(value) {
    config.drive.enabled = value;
  }
  get drive() {
    return config.drive.enabled;
  }
  set formMode(value) {
    config.forms.mode = value;
  }
  get formMode() {
    return config.forms.mode;
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  get pageRefreshDebouncePeriod() {
    return this.#pageRefreshDebouncePeriod;
  }
  set pageRefreshDebouncePeriod(value) {
    this.refresh = debounce(this.debouncedRefresh.bind(this), value);
    this.#pageRefreshDebouncePeriod = value;
  }
  shouldPreloadLink(element) {
    const isUnsafe = element.hasAttribute("data-turbo-method");
    const isStream = element.hasAttribute("data-turbo-stream");
    const frameTarget = element.getAttribute("data-turbo-frame");
    const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
    if (isUnsafe || isStream || frame instanceof FrameElement) {
      return false;
    } else {
      const location2 = new URL(element.href);
      return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
  }
  historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
    if (this.enabled) {
      this.navigator.startVisit(location2, restorationIdentifier, {
        action: "restore",
        historyChanged: true,
        direction
      });
    } else {
      this.adapter.pageInvalidated({
        reason: "turbo_disabled"
      });
    }
  }
  scrollPositionChanged(position) {
    this.history.updateRestorationData({ scrollPosition: position });
  }
  willSubmitFormLinkToLocation(link, location2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
  }
  submittedFormLinkToLocation() {
  }
  canPrefetchRequestToLocation(link, location2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.navigator.linkPrefetchingIsEnabledForLocation(location2);
  }
  willFollowLinkToLocation(link, location2, event) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
  }
  followedLinkToLocation(link, location2) {
    const action = this.getActionForLink(link);
    const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
    this.visit(location2.href, { action, acceptsStreamResponse });
  }
  allowsVisitingLocationWithAction(location2, action) {
    return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
  }
  visitProposedToLocation(location2, options) {
    extendURLWithDeprecatedProperties(location2);
    this.adapter.visitProposedToLocation(location2, options);
  }
  visitStarted(visit2) {
    if (!visit2.acceptsStreamResponse) {
      markAsBusy(document.documentElement);
      this.view.markVisitDirection(visit2.direction);
    }
    extendURLWithDeprecatedProperties(visit2.location);
    if (!visit2.silent) {
      this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
    }
  }
  visitCompleted(visit2) {
    this.view.unmarkVisitDirection();
    clearBusyState(document.documentElement);
    this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
  }
  locationWithActionIsSamePage(location2, action) {
    return this.navigator.locationWithActionIsSamePage(location2, action);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
  }
  willSubmitForm(form, submitter2) {
    const action = getAction$1(form, submitter2);
    return this.submissionIsNavigatable(form, submitter2) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
  }
  formSubmitted(form, submitter2) {
    this.navigator.submitForm(form, submitter2);
  }
  pageBecameInteractive() {
    this.view.lastRenderedLocation = this.location;
    this.notifyApplicationAfterPageLoad();
  }
  pageLoaded() {
    this.history.assumeControlOfScrollRestoration();
  }
  pageWillUnload() {
    this.history.relinquishControlOfScrollRestoration();
  }
  receivedMessageFromStream(message) {
    this.renderStreamMessage(message);
  }
  viewWillCacheSnapshot() {
    if (!this.navigator.currentVisit?.silent) {
      this.notifyApplicationBeforeCachingSnapshot();
    }
  }
  allowsImmediateRender({ element }, options) {
    const event = this.notifyApplicationBeforeRender(element, options);
    const {
      defaultPrevented,
      detail: { render }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
    this.view.lastRenderedLocation = this.history.location;
    this.notifyApplicationAfterRender(renderMethod);
  }
  preloadOnLoadLinksForView(element) {
    this.preloader.preloadOnLoadLinksForView(element);
  }
  viewInvalidated(reason) {
    this.adapter.pageInvalidated(reason);
  }
  frameLoaded(frame) {
    this.notifyApplicationAfterFrameLoad(frame);
  }
  frameRendered(fetchResponse, frame) {
    this.notifyApplicationAfterFrameRender(fetchResponse, frame);
  }
  applicationAllowsFollowingLinkToLocation(link, location2, ev) {
    const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
    return !event.defaultPrevented;
  }
  applicationAllowsVisitingLocation(location2) {
    const event = this.notifyApplicationBeforeVisitingLocation(location2);
    return !event.defaultPrevented;
  }
  notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
    return dispatch("turbo:click", {
      target: link,
      detail: { url: location2.href, originalEvent: event },
      cancelable: true
    });
  }
  notifyApplicationBeforeVisitingLocation(location2) {
    return dispatch("turbo:before-visit", {
      detail: { url: location2.href },
      cancelable: true
    });
  }
  notifyApplicationAfterVisitingLocation(location2, action) {
    return dispatch("turbo:visit", { detail: { url: location2.href, action } });
  }
  notifyApplicationBeforeCachingSnapshot() {
    return dispatch("turbo:before-cache");
  }
  notifyApplicationBeforeRender(newBody, options) {
    return dispatch("turbo:before-render", {
      detail: { newBody, ...options },
      cancelable: true
    });
  }
  notifyApplicationAfterRender(renderMethod) {
    return dispatch("turbo:render", { detail: { renderMethod } });
  }
  notifyApplicationAfterPageLoad(timing = {}) {
    return dispatch("turbo:load", {
      detail: { url: this.location.href, timing }
    });
  }
  notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
    dispatchEvent(new HashChangeEvent("hashchange", {
      oldURL: oldURL.toString(),
      newURL: newURL.toString()
    }));
  }
  notifyApplicationAfterFrameLoad(frame) {
    return dispatch("turbo:frame-load", { target: frame });
  }
  notifyApplicationAfterFrameRender(fetchResponse, frame) {
    return dispatch("turbo:frame-render", {
      detail: { fetchResponse },
      target: frame,
      cancelable: true
    });
  }
  submissionIsNavigatable(form, submitter2) {
    if (config.forms.mode == "off") {
      return false;
    } else {
      const submitterIsNavigatable = submitter2 ? this.elementIsNavigatable(submitter2) : true;
      if (config.forms.mode == "optin") {
        return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
      } else {
        return submitterIsNavigatable && this.elementIsNavigatable(form);
      }
    }
  }
  elementIsNavigatable(element) {
    const container = findClosestRecursively(element, "[data-turbo]");
    const withinFrame = findClosestRecursively(element, "turbo-frame");
    if (config.drive.enabled || withinFrame) {
      if (container) {
        return container.getAttribute("data-turbo") != "false";
      } else {
        return true;
      }
    } else {
      if (container) {
        return container.getAttribute("data-turbo") == "true";
      } else {
        return false;
      }
    }
  }
  getActionForLink(link) {
    return getVisitAction(link) || "advance";
  }
  get snapshot() {
    return this.view.snapshot;
  }
}
var deprecatedLocationPropertyDescriptors = {
  absoluteURL: {
    get() {
      return this.toString();
    }
  }
};
var session = new Session(recentRequests);
var { cache, navigator: navigator$1 } = session;
var Turbo = Object.freeze({
  __proto__: null,
  navigator: navigator$1,
  session,
  cache,
  PageRenderer,
  PageSnapshot,
  FrameRenderer,
  fetch: fetchWithTurboHeaders,
  config,
  start,
  registerAdapter,
  visit,
  connectStreamSource,
  disconnectStreamSource,
  renderStreamMessage,
  clearCache,
  setProgressBarDelay,
  setConfirmMethod,
  setFormMode
});

class TurboFrameMissingError extends Error {
}

class FrameController {
  fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
  #currentFetchRequest = null;
  #resolveVisitPromise = () => {
  };
  #connected = false;
  #hasBeenLoaded = false;
  #ignoredAttributes = new Set;
  #shouldMorphFrame = false;
  action = null;
  constructor(element) {
    this.element = element;
    this.view = new FrameView(this, this.element);
    this.appearanceObserver = new AppearanceObserver(this, this.element);
    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
    this.linkInterceptor = new LinkInterceptor(this, this.element);
    this.restorationIdentifier = uuid();
    this.formSubmitObserver = new FormSubmitObserver(this, this.element);
  }
  connect() {
    if (!this.#connected) {
      this.#connected = true;
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.#loadSourceURL();
      }
      this.formLinkClickObserver.start();
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
  }
  disconnect() {
    if (this.#connected) {
      this.#connected = false;
      this.appearanceObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
  }
  disabledChanged() {
    if (this.loadingStyle == FrameLoadingStyle.eager) {
      this.#loadSourceURL();
    }
  }
  sourceURLChanged() {
    if (this.#isIgnoringChangesTo("src"))
      return;
    if (this.element.isConnected) {
      this.complete = false;
    }
    if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
      this.#loadSourceURL();
    }
  }
  sourceURLReloaded() {
    const { refresh, src } = this.element;
    this.#shouldMorphFrame = src && refresh === "morph";
    this.element.removeAttribute("complete");
    this.element.src = null;
    this.element.src = src;
    return this.element.loaded;
  }
  loadingStyleChanged() {
    if (this.loadingStyle == FrameLoadingStyle.lazy) {
      this.appearanceObserver.start();
    } else {
      this.appearanceObserver.stop();
      this.#loadSourceURL();
    }
  }
  async#loadSourceURL() {
    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
      this.element.loaded = this.#visit(expandURL(this.sourceURL));
      this.appearanceObserver.stop();
      await this.element.loaded;
      this.#hasBeenLoaded = true;
    }
  }
  async loadResponse(fetchResponse) {
    if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
      this.sourceURL = fetchResponse.response.url;
    }
    try {
      const html = await fetchResponse.responseHTML;
      if (html) {
        const document2 = parseHTMLDocument(html);
        const pageSnapshot = PageSnapshot.fromDocument(document2);
        if (pageSnapshot.isVisitable) {
          await this.#loadFrameResponse(fetchResponse, document2);
        } else {
          await this.#handleUnvisitableFrameResponse(fetchResponse);
        }
      }
    } finally {
      this.#shouldMorphFrame = false;
      this.fetchResponseLoaded = () => Promise.resolve();
    }
  }
  elementAppearedInViewport(element) {
    this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
    this.#loadSourceURL();
  }
  willSubmitFormLinkToLocation(link) {
    return this.#shouldInterceptNavigation(link);
  }
  submittedFormLinkToLocation(link, _location, form) {
    const frame = this.#findFrameElement(link);
    if (frame)
      form.setAttribute("data-turbo-frame", frame.id);
  }
  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldInterceptNavigation(element);
  }
  linkClickIntercepted(element, location2) {
    this.#navigateFrame(element, location2);
  }
  willSubmitForm(element, submitter2) {
    return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter2);
  }
  formSubmitted(element, submitter2) {
    if (this.formSubmission) {
      this.formSubmission.stop();
    }
    this.formSubmission = new FormSubmission(this, element, submitter2);
    const { fetchRequest } = this.formSubmission;
    this.prepareRequest(fetchRequest);
    this.formSubmission.start();
  }
  prepareRequest(request) {
    request.headers["Turbo-Frame"] = this.id;
    if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    markAsBusy(this.element);
  }
  requestPreventedHandlingResponse(_request, _response) {
    this.#resolveVisitPromise();
  }
  async requestSucceededWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  async requestFailedWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  requestErrored(request, error) {
    console.error(error);
    this.#resolveVisitPromise();
  }
  requestFinished(_request) {
    clearBusyState(this.element);
  }
  formSubmissionStarted({ formElement }) {
    markAsBusy(formElement, this.#findFrameElement(formElement));
  }
  formSubmissionSucceededWithResponse(formSubmission, response) {
    const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
    frame.delegate.loadResponse(response);
    if (!formSubmission.isSafe) {
      session.clearCache();
    }
  }
  formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    this.element.delegate.loadResponse(fetchResponse);
    session.clearCache();
  }
  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }
  formSubmissionFinished({ formElement }) {
    clearBusyState(formElement, this.#findFrameElement(formElement));
  }
  allowsImmediateRender({ element: newFrame }, options) {
    const event = dispatch("turbo:before-frame-render", {
      target: this.element,
      detail: { newFrame, ...options },
      cancelable: true
    });
    const {
      defaultPrevented,
      detail: { render }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
  }
  preloadOnLoadLinksForView(element) {
    session.preloadOnLoadLinksForView(element);
  }
  viewInvalidated() {
  }
  willRenderFrame(currentElement, _newElement) {
    this.previousFrameElement = currentElement.cloneNode(true);
  }
  visitCachedSnapshot = ({ element }) => {
    const frame = element.querySelector("#" + this.element.id);
    if (frame && this.previousFrameElement) {
      frame.replaceChildren(...this.previousFrameElement.children);
    }
    delete this.previousFrameElement;
  };
  async#loadFrameResponse(fetchResponse, document2) {
    const newFrameElement = await this.extractForeignFrameElement(document2.body);
    const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;
    if (newFrameElement) {
      const snapshot = new Snapshot(newFrameElement);
      const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
      if (this.view.renderPromise)
        await this.view.renderPromise;
      this.changeHistory();
      await this.view.render(renderer);
      this.complete = true;
      session.frameRendered(fetchResponse, this.element);
      session.frameLoaded(this.element);
      await this.fetchResponseLoaded(fetchResponse);
    } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
      this.#handleFrameMissingFromResponse(fetchResponse);
    }
  }
  async#visit(url) {
    const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams, this.element);
    this.#currentFetchRequest?.cancel();
    this.#currentFetchRequest = request;
    return new Promise((resolve) => {
      this.#resolveVisitPromise = () => {
        this.#resolveVisitPromise = () => {
        };
        this.#currentFetchRequest = null;
        resolve();
      };
      request.perform();
    });
  }
  #navigateFrame(element, url, submitter2) {
    const frame = this.#findFrameElement(element, submitter2);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter2, element, frame));
    this.#withCurrentNavigationElement(element, () => {
      frame.src = url;
    });
  }
  proposeVisitIfNavigatedWithAction(frame, action = null) {
    this.action = action;
    if (this.action) {
      const pageSnapshot = PageSnapshot.fromElement(frame).clone();
      const { visitCachedSnapshot } = frame.delegate;
      frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
        if (frame.src) {
          const { statusCode, redirected } = fetchResponse;
          const responseHTML = await fetchResponse.responseHTML;
          const response = { statusCode, redirected, responseHTML };
          const options = {
            response,
            visitCachedSnapshot,
            willRender: false,
            updateHistory: false,
            restorationIdentifier: this.restorationIdentifier,
            snapshot: pageSnapshot
          };
          if (this.action)
            options.action = this.action;
          session.visit(frame.src, options);
        }
      };
    }
  }
  changeHistory() {
    if (this.action) {
      const method = getHistoryMethodForAction(this.action);
      session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
    }
  }
  async#handleUnvisitableFrameResponse(fetchResponse) {
    console.warn(`The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`);
    await this.#visitResponse(fetchResponse.response);
  }
  #willHandleFrameMissingFromResponse(fetchResponse) {
    this.element.setAttribute("complete", "");
    const response = fetchResponse.response;
    const visit2 = async (url, options) => {
      if (url instanceof Response) {
        this.#visitResponse(url);
      } else {
        session.visit(url, options);
      }
    };
    const event = dispatch("turbo:frame-missing", {
      target: this.element,
      detail: { response, visit: visit2 },
      cancelable: true
    });
    return !event.defaultPrevented;
  }
  #handleFrameMissingFromResponse(fetchResponse) {
    this.view.missing();
    this.#throwFrameMissingError(fetchResponse);
  }
  #throwFrameMissingError(fetchResponse) {
    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
    throw new TurboFrameMissingError(message);
  }
  async#visitResponse(response) {
    const wrapped = new FetchResponse(response);
    const responseHTML = await wrapped.responseHTML;
    const { location: location2, redirected, statusCode } = wrapped;
    return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
  }
  #findFrameElement(element, submitter2) {
    const id = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    return getFrameElementById(id) ?? this.element;
  }
  async extractForeignFrameElement(container) {
    let element;
    const id = CSS.escape(this.id);
    try {
      element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
      if (element) {
        return element;
      }
      element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
      if (element) {
        await element.loaded;
        return await this.extractForeignFrameElement(element);
      }
    } catch (error) {
      console.error(error);
      return new FrameElement;
    }
    return null;
  }
  #formActionIsVisitable(form, submitter2) {
    const action = getAction$1(form, submitter2);
    return locationIsVisitable(expandURL(action), this.rootLocation);
  }
  #shouldInterceptNavigation(element, submitter2) {
    const id = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter2)) {
      return false;
    }
    if (!this.enabled || id == "_top") {
      return false;
    }
    if (id) {
      const frameElement = getFrameElementById(id);
      if (frameElement) {
        return !frameElement.disabled;
      }
    }
    if (!session.elementIsNavigatable(element)) {
      return false;
    }
    if (submitter2 && !session.elementIsNavigatable(submitter2)) {
      return false;
    }
    return true;
  }
  get id() {
    return this.element.id;
  }
  get enabled() {
    return !this.element.disabled;
  }
  get sourceURL() {
    if (this.element.src) {
      return this.element.src;
    }
  }
  set sourceURL(sourceURL) {
    this.#ignoringChangesToAttribute("src", () => {
      this.element.src = sourceURL ?? null;
    });
  }
  get loadingStyle() {
    return this.element.loading;
  }
  get isLoading() {
    return this.formSubmission !== undefined || this.#resolveVisitPromise() !== undefined;
  }
  get complete() {
    return this.element.hasAttribute("complete");
  }
  set complete(value) {
    if (value) {
      this.element.setAttribute("complete", "");
    } else {
      this.element.removeAttribute("complete");
    }
  }
  get isActive() {
    return this.element.isActive && this.#connected;
  }
  get rootLocation() {
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const root = meta?.content ?? "/";
    return expandURL(root);
  }
  #isIgnoringChangesTo(attributeName) {
    return this.#ignoredAttributes.has(attributeName);
  }
  #ignoringChangesToAttribute(attributeName, callback) {
    this.#ignoredAttributes.add(attributeName);
    callback();
    this.#ignoredAttributes.delete(attributeName);
  }
  #withCurrentNavigationElement(element, callback) {
    this.currentNavigationElement = element;
    callback();
    delete this.currentNavigationElement;
  }
}
var StreamActions = {
  after() {
    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e.nextSibling));
  },
  append() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e) => e.append(this.templateContent));
  },
  before() {
    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e));
  },
  prepend() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e) => e.prepend(this.templateContent));
  },
  remove() {
    this.targetElements.forEach((e) => e.remove());
  },
  replace() {
    const method = this.getAttribute("method");
    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphElements(targetElement, this.templateContent);
      } else {
        targetElement.replaceWith(this.templateContent);
      }
    });
  },
  update() {
    const method = this.getAttribute("method");
    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphChildren(targetElement, this.templateContent);
      } else {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      }
    });
  },
  refresh() {
    session.refresh(this.baseURI, this.requestId);
  }
};

class StreamElement extends HTMLElement {
  static async renderElement(newElement) {
    await newElement.performAction();
  }
  async connectedCallback() {
    try {
      await this.render();
    } catch (error) {
      console.error(error);
    } finally {
      this.disconnect();
    }
  }
  async render() {
    return this.renderPromise ??= (async () => {
      const event = this.beforeRenderEvent;
      if (this.dispatchEvent(event)) {
        await nextRepaint();
        await event.detail.render(this);
      }
    })();
  }
  disconnect() {
    try {
      this.remove();
    } catch {
    }
  }
  removeDuplicateTargetChildren() {
    this.duplicateChildren.forEach((c) => c.remove());
  }
  get duplicateChildren() {
    const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.getAttribute("id"));
    const newChildrenIds = [...this.templateContent?.children || []].filter((c) => !!c.getAttribute("id")).map((c) => c.getAttribute("id"));
    return existingChildren.filter((c) => newChildrenIds.includes(c.getAttribute("id")));
  }
  get performAction() {
    if (this.action) {
      const actionFunction = StreamActions[this.action];
      if (actionFunction) {
        return actionFunction;
      }
      this.#raise("unknown action");
    }
    this.#raise("action attribute is missing");
  }
  get targetElements() {
    if (this.target) {
      return this.targetElementsById;
    } else if (this.targets) {
      return this.targetElementsByQuery;
    } else {
      this.#raise("target or targets attribute is missing");
    }
  }
  get templateContent() {
    return this.templateElement.content.cloneNode(true);
  }
  get templateElement() {
    if (this.firstElementChild === null) {
      const template = this.ownerDocument.createElement("template");
      this.appendChild(template);
      return template;
    } else if (this.firstElementChild instanceof HTMLTemplateElement) {
      return this.firstElementChild;
    }
    this.#raise("first child element must be a <template> element");
  }
  get action() {
    return this.getAttribute("action");
  }
  get target() {
    return this.getAttribute("target");
  }
  get targets() {
    return this.getAttribute("targets");
  }
  get requestId() {
    return this.getAttribute("request-id");
  }
  #raise(message) {
    throw new Error(`${this.description}: ${message}`);
  }
  get description() {
    return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
  }
  get beforeRenderEvent() {
    return new CustomEvent("turbo:before-stream-render", {
      bubbles: true,
      cancelable: true,
      detail: { newStream: this, render: StreamElement.renderElement }
    });
  }
  get targetElementsById() {
    const element = this.ownerDocument?.getElementById(this.target);
    if (element !== null) {
      return [element];
    } else {
      return [];
    }
  }
  get targetElementsByQuery() {
    const elements = this.ownerDocument?.querySelectorAll(this.targets);
    if (elements.length !== 0) {
      return Array.prototype.slice.call(elements);
    } else {
      return [];
    }
  }
}

class StreamSourceElement extends HTMLElement {
  streamSource = null;
  connectedCallback() {
    this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
    connectStreamSource(this.streamSource);
  }
  disconnectedCallback() {
    if (this.streamSource) {
      this.streamSource.close();
      disconnectStreamSource(this.streamSource);
    }
  }
  get src() {
    return this.getAttribute("src") || "";
  }
}
FrameElement.delegateConstructor = FrameController;
if (customElements.get("turbo-frame") === undefined) {
  customElements.define("turbo-frame", FrameElement);
}
if (customElements.get("turbo-stream") === undefined) {
  customElements.define("turbo-stream", StreamElement);
}
if (customElements.get("turbo-stream-source") === undefined) {
  customElements.define("turbo-stream-source", StreamSourceElement);
}
(() => {
  let element = document.currentScript;
  if (!element)
    return;
  if (element.hasAttribute("data-turbo-suppress-warning"))
    return;
  element = element.parentElement;
  while (element) {
    if (element == document.body) {
      return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applicationâs JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ââ
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
    }
    element = element.parentElement;
  }
})();
window.Turbo = { ...Turbo, StreamActions };
start();

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
async function getConsumer() {
  return consumer2 || setConsumer(createConsumer2().then(setConsumer));
}
function setConsumer(newConsumer) {
  return consumer2 = newConsumer;
}
async function createConsumer2() {
  const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), exports_src));
  return createConsumer3();
}
async function subscribeTo(channel, mixin) {
  const { subscriptions: subscriptions3 } = await getConsumer();
  return subscriptions3.create(channel, mixin);
}
var consumer2;

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
function walk(obj) {
  if (!obj || typeof obj !== "object")
    return obj;
  if (obj instanceof Date || obj instanceof RegExp)
    return obj;
  if (Array.isArray(obj))
    return obj.map(walk);
  return Object.keys(obj).reduce(function(acc, key) {
    var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m, x) {
      return "_" + x.toLowerCase();
    });
    acc[camel] = walk(obj[key]);
    return acc;
  }, {});
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
class TurboCableStreamSourceElement extends HTMLElement {
  static observedAttributes = ["channel", "signed-stream-name"];
  async connectedCallback() {
    connectStreamSource(this);
    this.subscription = await subscribeTo(this.channel, {
      received: this.dispatchMessageEvent.bind(this),
      connected: this.subscriptionConnected.bind(this),
      disconnected: this.subscriptionDisconnected.bind(this)
    });
  }
  disconnectedCallback() {
    disconnectStreamSource(this);
    if (this.subscription)
      this.subscription.unsubscribe();
    this.subscriptionDisconnected();
  }
  attributeChangedCallback() {
    if (this.subscription) {
      this.disconnectedCallback();
      this.connectedCallback();
    }
  }
  dispatchMessageEvent(data) {
    const event = new MessageEvent("message", { data });
    return this.dispatchEvent(event);
  }
  subscriptionConnected() {
    this.setAttribute("connected", "");
  }
  subscriptionDisconnected() {
    this.removeAttribute("connected");
  }
  get channel() {
    const channel = this.getAttribute("channel");
    const signed_stream_name = this.getAttribute("signed-stream-name");
    return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
  }
}
if (customElements.get("turbo-cable-stream-source") === undefined) {
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
function encodeMethodIntoRequestBody(event) {
  if (event.target instanceof HTMLFormElement) {
    const { target: form, detail: { fetchOptions } } = event;
    form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter: submitter2 } } }) => {
      const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams;
      const method = determineFetchMethod(submitter2, body, form);
      if (!/get/i.test(method)) {
        if (/post/i.test(method)) {
          body.delete("_method");
        } else {
          body.set("_method", method);
        }
        fetchOptions.method = "post";
      }
    }, { once: true });
  }
}
var determineFetchMethod = function(submitter2, body, form) {
  const formMethod = determineFormMethod(submitter2);
  const overrideMethod = body.get("_method");
  const method = form.getAttribute("method") || "get";
  if (typeof formMethod == "string") {
    return formMethod;
  } else if (typeof overrideMethod == "string") {
    return overrideMethod;
  } else {
    return method;
  }
};
var determineFormMethod = function(submitter2) {
  if (submitter2 instanceof HTMLButtonElement || submitter2 instanceof HTMLInputElement) {
    if (submitter2.name === "_method") {
      return submitter2.value;
    } else if (submitter2.hasAttribute("formmethod")) {
      return submitter2.formMethod;
    } else {
      return null;
    }
  } else {
    return null;
  }
};
var isBodyInit = function(body) {
  return body instanceof FormData || body instanceof URLSearchParams;
};

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
window.Turbo = exports_turbo_es2017_esm;
addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

// node_modules/@hotwired/stimulus/dist/stimulus.js
var extendEvent = function(event) {
  if ("immediatePropagationStopped" in event) {
    return event;
  } else {
    const { stopImmediatePropagation } = event;
    return Object.assign(event, {
      immediatePropagationStopped: false,
      stopImmediatePropagation() {
        this.immediatePropagationStopped = true;
        stopImmediatePropagation.call(this);
      }
    });
  }
};
var parseActionDescriptorString = function(descriptorString) {
  const source = descriptorString.trim();
  const matches = source.match(descriptorPattern) || [];
  let eventName = matches[2];
  let keyFilter = matches[3];
  if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
    eventName += `.${keyFilter}`;
    keyFilter = "";
  }
  return {
    eventTarget: parseEventTarget(matches[4]),
    eventName,
    eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
    identifier: matches[5],
    methodName: matches[6],
    keyFilter: matches[1] || keyFilter
  };
};
var parseEventTarget = function(eventTargetName) {
  if (eventTargetName == "window") {
    return window;
  } else if (eventTargetName == "document") {
    return document;
  }
};
var parseEventOptions = function(eventOptions) {
  return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
};
var stringifyEventTarget = function(eventTarget) {
  if (eventTarget == window) {
    return "window";
  } else if (eventTarget == document) {
    return "document";
  }
};
var camelize = function(value) {
  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
};
var namespaceCamelize = function(value) {
  return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
};
var capitalize = function(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
};
var dasherize = function(value) {
  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
};
var tokenize = function(value) {
  return value.match(/[^\s]+/g) || [];
};
var isSomething = function(object) {
  return object !== null && object !== undefined;
};
var hasProperty = function(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
};
var getDefaultEventNameForElement = function(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName in defaultEventNames) {
    return defaultEventNames[tagName](element);
  }
};
var error = function(message) {
  throw new Error(message);
};
var typecast = function(value) {
  try {
    return JSON.parse(value);
  } catch (o_O) {
    return value;
  }
};
var add = function(map, key, value) {
  fetch(map, key).add(value);
};
var del = function(map, key, value) {
  fetch(map, key).delete(value);
  prune(map, key);
};
var fetch = function(map, key) {
  let values = map.get(key);
  if (!values) {
    values = new Set;
    map.set(key, values);
  }
  return values;
};
var prune = function(map, key) {
  const values = map.get(key);
  if (values != null && values.size == 0) {
    map.delete(key);
  }
};
var parseTokenString = function(tokenString, element, attributeName) {
  return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
};
var zip = function(left, right) {
  const length = Math.max(left.length, right.length);
  return Array.from({ length }, (_, index) => [left[index], right[index]]);
};
var tokensAreEqual = function(left, right) {
  return left && right && left.index == right.index && left.content == right.content;
};
var readInheritableStaticArrayValues = function(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return Array.from(ancestors.reduce((values, constructor2) => {
    getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
    return values;
  }, new Set));
};
var readInheritableStaticObjectPairs = function(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return ancestors.reduce((pairs, constructor2) => {
    pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
    return pairs;
  }, []);
};
var getAncestorsForConstructor = function(constructor) {
  const ancestors = [];
  while (constructor) {
    ancestors.push(constructor);
    constructor = Object.getPrototypeOf(constructor);
  }
  return ancestors.reverse();
};
var getOwnStaticArrayValues = function(constructor, propertyName) {
  const definition = constructor[propertyName];
  return Array.isArray(definition) ? definition : [];
};
var getOwnStaticObjectPairs = function(constructor, propertyName) {
  const definition = constructor[propertyName];
  return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
};
var bless = function(constructor) {
  return shadow(constructor, getBlessedProperties(constructor));
};
var shadow = function(constructor, properties) {
  const shadowConstructor = extend2(constructor);
  const shadowProperties = getShadowProperties(constructor.prototype, properties);
  Object.defineProperties(shadowConstructor.prototype, shadowProperties);
  return shadowConstructor;
};
var getBlessedProperties = function(constructor) {
  const blessings = readInheritableStaticArrayValues(constructor, "blessings");
  return blessings.reduce((blessedProperties, blessing) => {
    const properties = blessing(constructor);
    for (const key in properties) {
      const descriptor = blessedProperties[key] || {};
      blessedProperties[key] = Object.assign(descriptor, properties[key]);
    }
    return blessedProperties;
  }, {});
};
var getShadowProperties = function(prototype, properties) {
  return getOwnKeys(properties).reduce((shadowProperties, key) => {
    const descriptor = getShadowedDescriptor(prototype, properties, key);
    if (descriptor) {
      Object.assign(shadowProperties, { [key]: descriptor });
    }
    return shadowProperties;
  }, {});
};
var getShadowedDescriptor = function(prototype, properties, key) {
  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
  const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
  if (!shadowedByValue) {
    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
    if (shadowingDescriptor) {
      descriptor.get = shadowingDescriptor.get || descriptor.get;
      descriptor.set = shadowingDescriptor.set || descriptor.set;
    }
    return descriptor;
  }
};
var blessDefinition = function(definition) {
  return {
    identifier: definition.identifier,
    controllerConstructor: bless(definition.controllerConstructor)
  };
};
var attributeValueContainsToken = function(attributeName, token) {
  return `[${attributeName}~="${token}"]`;
};
var objectFromEntries = function(array) {
  return array.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
};
var domReady = function() {
  return new Promise((resolve) => {
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", () => resolve());
    } else {
      resolve();
    }
  });
};
var ClassPropertiesBlessing = function(constructor) {
  const classes = readInheritableStaticArrayValues(constructor, "classes");
  return classes.reduce((properties, classDefinition) => {
    return Object.assign(properties, propertiesForClassDefinition(classDefinition));
  }, {});
};
var propertiesForClassDefinition = function(key) {
  return {
    [`${key}Class`]: {
      get() {
        const { classes } = this;
        if (classes.has(key)) {
          return classes.get(key);
        } else {
          const attribute = classes.getAttributeName(key);
          throw new Error(`Missing attribute "${attribute}"`);
        }
      }
    },
    [`${key}Classes`]: {
      get() {
        return this.classes.getAll(key);
      }
    },
    [`has${capitalize(key)}Class`]: {
      get() {
        return this.classes.has(key);
      }
    }
  };
};
var OutletPropertiesBlessing = function(constructor) {
  const outlets = readInheritableStaticArrayValues(constructor, "outlets");
  return outlets.reduce((properties, outletDefinition) => {
    return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
  }, {});
};
var getOutletController = function(controller, element, identifier) {
  return controller.application.getControllerForElementAndIdentifier(element, identifier);
};
var getControllerAndEnsureConnectedScope = function(controller, element, outletName) {
  let outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
  controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
  outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
};
var propertiesForOutletDefinition = function(name) {
  const camelizedName = namespaceCamelize(name);
  return {
    [`${camelizedName}Outlet`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
          if (outletController)
            return outletController;
          throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
        }
        throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
      }
    },
    [`${camelizedName}Outlets`]: {
      get() {
        const outlets = this.outlets.findAll(name);
        if (outlets.length > 0) {
          return outlets.map((outletElement) => {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
          }).filter((controller) => controller);
        }
        return [];
      }
    },
    [`${camelizedName}OutletElement`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          return outletElement;
        } else {
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      }
    },
    [`${camelizedName}OutletElements`]: {
      get() {
        return this.outlets.findAll(name);
      }
    },
    [`has${capitalize(camelizedName)}Outlet`]: {
      get() {
        return this.outlets.has(name);
      }
    }
  };
};
var TargetPropertiesBlessing = function(constructor) {
  const targets = readInheritableStaticArrayValues(constructor, "targets");
  return targets.reduce((properties, targetDefinition) => {
    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
  }, {});
};
var propertiesForTargetDefinition = function(name) {
  return {
    [`${name}Target`]: {
      get() {
        const target = this.targets.find(name);
        if (target) {
          return target;
        } else {
          throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
        }
      }
    },
    [`${name}Targets`]: {
      get() {
        return this.targets.findAll(name);
      }
    },
    [`has${capitalize(name)}Target`]: {
      get() {
        return this.targets.has(name);
      }
    }
  };
};
var ValuePropertiesBlessing = function(constructor) {
  const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
  const propertyDescriptorMap = {
    valueDescriptorMap: {
      get() {
        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
          return Object.assign(result, { [attributeName]: valueDescriptor });
        }, {});
      }
    }
  };
  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
  }, propertyDescriptorMap);
};
var propertiesForValueDefinitionPair = function(valueDefinitionPair, controller) {
  const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
  const { key, name, reader: read, writer: write } = definition;
  return {
    [name]: {
      get() {
        const value = this.data.get(key);
        if (value !== null) {
          return read(value);
        } else {
          return definition.defaultValue;
        }
      },
      set(value) {
        if (value === undefined) {
          this.data.delete(key);
        } else {
          this.data.set(key, write(value));
        }
      }
    },
    [`has${capitalize(name)}`]: {
      get() {
        return this.data.has(key) || definition.hasCustomDefaultValue;
      }
    }
  };
};
var parseValueDefinitionPair = function([token, typeDefinition], controller) {
  return valueDescriptorForTokenAndTypeDefinition({
    controller,
    token,
    typeDefinition
  });
};
var parseValueTypeConstant = function(constant) {
  switch (constant) {
    case Array:
      return "array";
    case Boolean:
      return "boolean";
    case Number:
      return "number";
    case Object:
      return "object";
    case String:
      return "string";
  }
};
var parseValueTypeDefault = function(defaultValue) {
  switch (typeof defaultValue) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
  }
  if (Array.isArray(defaultValue))
    return "array";
  if (Object.prototype.toString.call(defaultValue) === "[object Object]")
    return "object";
};
var parseValueTypeObject = function(payload) {
  const { controller, token, typeObject } = payload;
  const hasType = isSomething(typeObject.type);
  const hasDefault = isSomething(typeObject.default);
  const fullObject = hasType && hasDefault;
  const onlyType = hasType && !hasDefault;
  const onlyDefault = !hasType && hasDefault;
  const typeFromObject = parseValueTypeConstant(typeObject.type);
  const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
  if (onlyType)
    return typeFromObject;
  if (onlyDefault)
    return typeFromDefaultValue;
  if (typeFromObject !== typeFromDefaultValue) {
    const propertyPath = controller ? `${controller}.${token}` : token;
    throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
  }
  if (fullObject)
    return typeFromObject;
};
var parseValueTypeDefinition = function(payload) {
  const { controller, token, typeDefinition } = payload;
  const typeObject = { controller, token, typeObject: typeDefinition };
  const typeFromObject = parseValueTypeObject(typeObject);
  const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
  const typeFromConstant = parseValueTypeConstant(typeDefinition);
  const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
  if (type)
    return type;
  const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
  throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
};
var defaultValueForDefinition = function(typeDefinition) {
  const constant = parseValueTypeConstant(typeDefinition);
  if (constant)
    return defaultValuesByType[constant];
  const hasDefault = hasProperty(typeDefinition, "default");
  const hasType = hasProperty(typeDefinition, "type");
  const typeObject = typeDefinition;
  if (hasDefault)
    return typeObject.default;
  if (hasType) {
    const { type } = typeObject;
    const constantFromType = parseValueTypeConstant(type);
    if (constantFromType)
      return defaultValuesByType[constantFromType];
  }
  return typeDefinition;
};
var valueDescriptorForTokenAndTypeDefinition = function(payload) {
  const { token, typeDefinition } = payload;
  const key = `${dasherize(token)}-value`;
  const type = parseValueTypeDefinition(payload);
  return {
    type,
    key,
    name: camelize(key),
    get defaultValue() {
      return defaultValueForDefinition(typeDefinition);
    },
    get hasCustomDefaultValue() {
      return parseValueTypeDefault(typeDefinition) !== undefined;
    },
    reader: readers[type],
    writer: writers[type] || writers.default
  };
};
var writeJSON = function(value) {
  return JSON.stringify(value);
};
var writeString = function(value) {
  return `${value}`;
};

class EventListener {
  constructor(eventTarget, eventName, eventOptions) {
    this.eventTarget = eventTarget;
    this.eventName = eventName;
    this.eventOptions = eventOptions;
    this.unorderedBindings = new Set;
  }
  connect() {
    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
  }
  disconnect() {
    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
  }
  bindingConnected(binding) {
    this.unorderedBindings.add(binding);
  }
  bindingDisconnected(binding) {
    this.unorderedBindings.delete(binding);
  }
  handleEvent(event) {
    const extendedEvent = extendEvent(event);
    for (const binding of this.bindings) {
      if (extendedEvent.immediatePropagationStopped) {
        break;
      } else {
        binding.handleEvent(extendedEvent);
      }
    }
  }
  hasBindings() {
    return this.unorderedBindings.size > 0;
  }
  get bindings() {
    return Array.from(this.unorderedBindings).sort((left, right) => {
      const leftIndex = left.index, rightIndex = right.index;
      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
    });
  }
}

class Dispatcher {
  constructor(application) {
    this.application = application;
    this.eventListenerMaps = new Map;
    this.started = false;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.eventListeners.forEach((eventListener) => eventListener.connect());
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.eventListeners.forEach((eventListener) => eventListener.disconnect());
    }
  }
  get eventListeners() {
    return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
  }
  bindingConnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingConnected(binding);
  }
  bindingDisconnected(binding, clearEventListeners = false) {
    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    if (clearEventListeners)
      this.clearEventListenersForBinding(binding);
  }
  handleError(error2, message, detail = {}) {
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  clearEventListenersForBinding(binding) {
    const eventListener = this.fetchEventListenerForBinding(binding);
    if (!eventListener.hasBindings()) {
      eventListener.disconnect();
      this.removeMappedEventListenerFor(binding);
    }
  }
  removeMappedEventListenerFor(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    eventListenerMap.delete(cacheKey);
    if (eventListenerMap.size == 0)
      this.eventListenerMaps.delete(eventTarget);
  }
  fetchEventListenerForBinding(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    return this.fetchEventListener(eventTarget, eventName, eventOptions);
  }
  fetchEventListener(eventTarget, eventName, eventOptions) {
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    let eventListener = eventListenerMap.get(cacheKey);
    if (!eventListener) {
      eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
      eventListenerMap.set(cacheKey, eventListener);
    }
    return eventListener;
  }
  createEventListener(eventTarget, eventName, eventOptions) {
    const eventListener = new EventListener(eventTarget, eventName, eventOptions);
    if (this.started) {
      eventListener.connect();
    }
    return eventListener;
  }
  fetchEventListenerMapForEventTarget(eventTarget) {
    let eventListenerMap = this.eventListenerMaps.get(eventTarget);
    if (!eventListenerMap) {
      eventListenerMap = new Map;
      this.eventListenerMaps.set(eventTarget, eventListenerMap);
    }
    return eventListenerMap;
  }
  cacheKey(eventName, eventOptions) {
    const parts = [eventName];
    Object.keys(eventOptions).sort().forEach((key) => {
      parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
    });
    return parts.join(":");
  }
}
var defaultActionDescriptorFilters = {
  stop({ event, value }) {
    if (value)
      event.stopPropagation();
    return true;
  },
  prevent({ event, value }) {
    if (value)
      event.preventDefault();
    return true;
  },
  self({ event, value, element }) {
    if (value) {
      return element === event.target;
    } else {
      return true;
    }
  }
};
var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
var allModifiers = ["meta", "ctrl", "alt", "shift"];

class Action {
  constructor(element, index, descriptor, schema) {
    this.element = element;
    this.index = index;
    this.eventTarget = descriptor.eventTarget || element;
    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
    this.eventOptions = descriptor.eventOptions || {};
    this.identifier = descriptor.identifier || error("missing identifier");
    this.methodName = descriptor.methodName || error("missing method name");
    this.keyFilter = descriptor.keyFilter || "";
    this.schema = schema;
  }
  static forToken(token, schema) {
    return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
  }
  toString() {
    const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
    const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
    return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
  }
  shouldIgnoreKeyboardEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = this.keyFilter.split("+");
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
    if (!standardFilter) {
      return false;
    }
    if (!hasProperty(this.keyMappings, standardFilter)) {
      error(`contains unknown key filter: ${this.keyFilter}`);
    }
    return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
  }
  shouldIgnoreMouseEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = [this.keyFilter];
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    return false;
  }
  get params() {
    const params = {};
    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param\$`, "i");
    for (const { name, value } of Array.from(this.element.attributes)) {
      const match = name.match(pattern);
      const key = match && match[1];
      if (key) {
        params[camelize(key)] = typecast(value);
      }
    }
    return params;
  }
  get eventTargetName() {
    return stringifyEventTarget(this.eventTarget);
  }
  get keyMappings() {
    return this.schema.keyMappings;
  }
  keyFilterDissatisfied(event, filters) {
    const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
    return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
  }
}
var defaultEventNames = {
  a: () => "click",
  button: () => "click",
  form: () => "submit",
  details: () => "toggle",
  input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
  select: () => "change",
  textarea: () => "input"
};

class Binding {
  constructor(context, action) {
    this.context = context;
    this.action = action;
  }
  get index() {
    return this.action.index;
  }
  get eventTarget() {
    return this.action.eventTarget;
  }
  get eventOptions() {
    return this.action.eventOptions;
  }
  get identifier() {
    return this.context.identifier;
  }
  handleEvent(event) {
    const actionEvent = this.prepareActionEvent(event);
    if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
      this.invokeWithEvent(actionEvent);
    }
  }
  get eventName() {
    return this.action.eventName;
  }
  get method() {
    const method = this.controller[this.methodName];
    if (typeof method == "function") {
      return method;
    }
    throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
  }
  applyEventModifiers(event) {
    const { element } = this.action;
    const { actionDescriptorFilters } = this.context.application;
    const { controller } = this.context;
    let passes = true;
    for (const [name, value] of Object.entries(this.eventOptions)) {
      if (name in actionDescriptorFilters) {
        const filter = actionDescriptorFilters[name];
        passes = passes && filter({ name, value, event, element, controller });
      } else {
        continue;
      }
    }
    return passes;
  }
  prepareActionEvent(event) {
    return Object.assign(event, { params: this.action.params });
  }
  invokeWithEvent(event) {
    const { target, currentTarget } = event;
    try {
      this.method.call(this.controller, event);
      this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
    } catch (error2) {
      const { identifier, controller, element, index } = this;
      const detail = { identifier, controller, element, index, event };
      this.context.handleError(error2, `invoking action "${this.action}"`, detail);
    }
  }
  willBeInvokedByEvent(event) {
    const eventTarget = event.target;
    if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
      return false;
    }
    if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
      return false;
    }
    if (this.element === eventTarget) {
      return true;
    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
      return this.scope.containsElement(eventTarget);
    } else {
      return this.scope.containsElement(this.action.element);
    }
  }
  get controller() {
    return this.context.controller;
  }
  get methodName() {
    return this.action.methodName;
  }
  get element() {
    return this.scope.element;
  }
  get scope() {
    return this.context.scope;
  }
}

class ElementObserver {
  constructor(element, delegate) {
    this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
    this.element = element;
    this.started = false;
    this.delegate = delegate;
    this.elements = new Set;
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.refresh();
    }
  }
  pause(callback) {
    if (this.started) {
      this.mutationObserver.disconnect();
      this.started = false;
    }
    callback();
    if (!this.started) {
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      const matches = new Set(this.matchElementsInTree());
      for (const element of Array.from(this.elements)) {
        if (!matches.has(element)) {
          this.removeElement(element);
        }
      }
      for (const element of Array.from(matches)) {
        this.addElement(element);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    if (mutation.type == "attributes") {
      this.processAttributeChange(mutation.target, mutation.attributeName);
    } else if (mutation.type == "childList") {
      this.processRemovedNodes(mutation.removedNodes);
      this.processAddedNodes(mutation.addedNodes);
    }
  }
  processAttributeChange(element, attributeName) {
    if (this.elements.has(element)) {
      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
        this.delegate.elementAttributeChanged(element, attributeName);
      } else {
        this.removeElement(element);
      }
    } else if (this.matchElement(element)) {
      this.addElement(element);
    }
  }
  processRemovedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element) {
        this.processTree(element, this.removeElement);
      }
    }
  }
  processAddedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element && this.elementIsActive(element)) {
        this.processTree(element, this.addElement);
      }
    }
  }
  matchElement(element) {
    return this.delegate.matchElement(element);
  }
  matchElementsInTree(tree = this.element) {
    return this.delegate.matchElementsInTree(tree);
  }
  processTree(tree, processor) {
    for (const element of this.matchElementsInTree(tree)) {
      processor.call(this, element);
    }
  }
  elementFromNode(node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      return node;
    }
  }
  elementIsActive(element) {
    if (element.isConnected != this.element.isConnected) {
      return false;
    } else {
      return this.element.contains(element);
    }
  }
  addElement(element) {
    if (!this.elements.has(element)) {
      if (this.elementIsActive(element)) {
        this.elements.add(element);
        if (this.delegate.elementMatched) {
          this.delegate.elementMatched(element);
        }
      }
    }
  }
  removeElement(element) {
    if (this.elements.has(element)) {
      this.elements.delete(element);
      if (this.delegate.elementUnmatched) {
        this.delegate.elementUnmatched(element);
      }
    }
  }
}

class AttributeObserver {
  constructor(element, attributeName, delegate) {
    this.attributeName = attributeName;
    this.delegate = delegate;
    this.elementObserver = new ElementObserver(element, this);
  }
  get element() {
    return this.elementObserver.element;
  }
  get selector() {
    return `[${this.attributeName}]`;
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get started() {
    return this.elementObserver.started;
  }
  matchElement(element) {
    return element.hasAttribute(this.attributeName);
  }
  matchElementsInTree(tree) {
    const match = this.matchElement(tree) ? [tree] : [];
    const matches = Array.from(tree.querySelectorAll(this.selector));
    return match.concat(matches);
  }
  elementMatched(element) {
    if (this.delegate.elementMatchedAttribute) {
      this.delegate.elementMatchedAttribute(element, this.attributeName);
    }
  }
  elementUnmatched(element) {
    if (this.delegate.elementUnmatchedAttribute) {
      this.delegate.elementUnmatchedAttribute(element, this.attributeName);
    }
  }
  elementAttributeChanged(element, attributeName) {
    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
      this.delegate.elementAttributeValueChanged(element, attributeName);
    }
  }
}

class Multimap {
  constructor() {
    this.valuesByKey = new Map;
  }
  get keys() {
    return Array.from(this.valuesByKey.keys());
  }
  get values() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((values, set) => values.concat(Array.from(set)), []);
  }
  get size() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((size, set) => size + set.size, 0);
  }
  add(key, value) {
    add(this.valuesByKey, key, value);
  }
  delete(key, value) {
    del(this.valuesByKey, key, value);
  }
  has(key, value) {
    const values = this.valuesByKey.get(key);
    return values != null && values.has(value);
  }
  hasKey(key) {
    return this.valuesByKey.has(key);
  }
  hasValue(value) {
    const sets = Array.from(this.valuesByKey.values());
    return sets.some((set) => set.has(value));
  }
  getValuesForKey(key) {
    const values = this.valuesByKey.get(key);
    return values ? Array.from(values) : [];
  }
  getKeysForValue(value) {
    return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
  }
}
class SelectorObserver {
  constructor(element, selector, delegate, details) {
    this._selector = selector;
    this.details = details;
    this.elementObserver = new ElementObserver(element, this);
    this.delegate = delegate;
    this.matchesByElement = new Multimap;
  }
  get started() {
    return this.elementObserver.started;
  }
  get selector() {
    return this._selector;
  }
  set selector(selector) {
    this._selector = selector;
    this.refresh();
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get element() {
    return this.elementObserver.element;
  }
  matchElement(element) {
    const { selector } = this;
    if (selector) {
      const matches = element.matches(selector);
      if (this.delegate.selectorMatchElement) {
        return matches && this.delegate.selectorMatchElement(element, this.details);
      }
      return matches;
    } else {
      return false;
    }
  }
  matchElementsInTree(tree) {
    const { selector } = this;
    if (selector) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
      return match.concat(matches);
    } else {
      return [];
    }
  }
  elementMatched(element) {
    const { selector } = this;
    if (selector) {
      this.selectorMatched(element, selector);
    }
  }
  elementUnmatched(element) {
    const selectors = this.matchesByElement.getKeysForValue(element);
    for (const selector of selectors) {
      this.selectorUnmatched(element, selector);
    }
  }
  elementAttributeChanged(element, _attributeName) {
    const { selector } = this;
    if (selector) {
      const matches = this.matchElement(element);
      const matchedBefore = this.matchesByElement.has(selector, element);
      if (matches && !matchedBefore) {
        this.selectorMatched(element, selector);
      } else if (!matches && matchedBefore) {
        this.selectorUnmatched(element, selector);
      }
    }
  }
  selectorMatched(element, selector) {
    this.delegate.selectorMatched(element, selector, this.details);
    this.matchesByElement.add(selector, element);
  }
  selectorUnmatched(element, selector) {
    this.delegate.selectorUnmatched(element, selector, this.details);
    this.matchesByElement.delete(selector, element);
  }
}

class StringMapObserver {
  constructor(element, delegate) {
    this.element = element;
    this.delegate = delegate;
    this.started = false;
    this.stringMap = new Map;
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
      this.refresh();
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      for (const attributeName of this.knownAttributeNames) {
        this.refreshAttribute(attributeName, null);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    const attributeName = mutation.attributeName;
    if (attributeName) {
      this.refreshAttribute(attributeName, mutation.oldValue);
    }
  }
  refreshAttribute(attributeName, oldValue) {
    const key = this.delegate.getStringMapKeyForAttribute(attributeName);
    if (key != null) {
      if (!this.stringMap.has(attributeName)) {
        this.stringMapKeyAdded(key, attributeName);
      }
      const value = this.element.getAttribute(attributeName);
      if (this.stringMap.get(attributeName) != value) {
        this.stringMapValueChanged(value, key, oldValue);
      }
      if (value == null) {
        const oldValue2 = this.stringMap.get(attributeName);
        this.stringMap.delete(attributeName);
        if (oldValue2)
          this.stringMapKeyRemoved(key, attributeName, oldValue2);
      } else {
        this.stringMap.set(attributeName, value);
      }
    }
  }
  stringMapKeyAdded(key, attributeName) {
    if (this.delegate.stringMapKeyAdded) {
      this.delegate.stringMapKeyAdded(key, attributeName);
    }
  }
  stringMapValueChanged(value, key, oldValue) {
    if (this.delegate.stringMapValueChanged) {
      this.delegate.stringMapValueChanged(value, key, oldValue);
    }
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    if (this.delegate.stringMapKeyRemoved) {
      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
    }
  }
  get knownAttributeNames() {
    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
  }
  get currentAttributeNames() {
    return Array.from(this.element.attributes).map((attribute) => attribute.name);
  }
  get recordedAttributeNames() {
    return Array.from(this.stringMap.keys());
  }
}

class TokenListObserver {
  constructor(element, attributeName, delegate) {
    this.attributeObserver = new AttributeObserver(element, attributeName, this);
    this.delegate = delegate;
    this.tokensByElement = new Multimap;
  }
  get started() {
    return this.attributeObserver.started;
  }
  start() {
    this.attributeObserver.start();
  }
  pause(callback) {
    this.attributeObserver.pause(callback);
  }
  stop() {
    this.attributeObserver.stop();
  }
  refresh() {
    this.attributeObserver.refresh();
  }
  get element() {
    return this.attributeObserver.element;
  }
  get attributeName() {
    return this.attributeObserver.attributeName;
  }
  elementMatchedAttribute(element) {
    this.tokensMatched(this.readTokensForElement(element));
  }
  elementAttributeValueChanged(element) {
    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
    this.tokensUnmatched(unmatchedTokens);
    this.tokensMatched(matchedTokens);
  }
  elementUnmatchedAttribute(element) {
    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
  }
  tokensMatched(tokens) {
    tokens.forEach((token) => this.tokenMatched(token));
  }
  tokensUnmatched(tokens) {
    tokens.forEach((token) => this.tokenUnmatched(token));
  }
  tokenMatched(token) {
    this.delegate.tokenMatched(token);
    this.tokensByElement.add(token.element, token);
  }
  tokenUnmatched(token) {
    this.delegate.tokenUnmatched(token);
    this.tokensByElement.delete(token.element, token);
  }
  refreshTokensForElement(element) {
    const previousTokens = this.tokensByElement.getValuesForKey(element);
    const currentTokens = this.readTokensForElement(element);
    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
    if (firstDifferingIndex == -1) {
      return [[], []];
    } else {
      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
    }
  }
  readTokensForElement(element) {
    const attributeName = this.attributeName;
    const tokenString = element.getAttribute(attributeName) || "";
    return parseTokenString(tokenString, element, attributeName);
  }
}

class ValueListObserver {
  constructor(element, attributeName, delegate) {
    this.tokenListObserver = new TokenListObserver(element, attributeName, this);
    this.delegate = delegate;
    this.parseResultsByToken = new WeakMap;
    this.valuesByTokenByElement = new WeakMap;
  }
  get started() {
    return this.tokenListObserver.started;
  }
  start() {
    this.tokenListObserver.start();
  }
  stop() {
    this.tokenListObserver.stop();
  }
  refresh() {
    this.tokenListObserver.refresh();
  }
  get element() {
    return this.tokenListObserver.element;
  }
  get attributeName() {
    return this.tokenListObserver.attributeName;
  }
  tokenMatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).set(token, value);
      this.delegate.elementMatchedValue(element, value);
    }
  }
  tokenUnmatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).delete(token);
      this.delegate.elementUnmatchedValue(element, value);
    }
  }
  fetchParseResultForToken(token) {
    let parseResult = this.parseResultsByToken.get(token);
    if (!parseResult) {
      parseResult = this.parseToken(token);
      this.parseResultsByToken.set(token, parseResult);
    }
    return parseResult;
  }
  fetchValuesByTokenForElement(element) {
    let valuesByToken = this.valuesByTokenByElement.get(element);
    if (!valuesByToken) {
      valuesByToken = new Map;
      this.valuesByTokenByElement.set(element, valuesByToken);
    }
    return valuesByToken;
  }
  parseToken(token) {
    try {
      const value = this.delegate.parseValueForToken(token);
      return { value };
    } catch (error2) {
      return { error: error2 };
    }
  }
}

class BindingObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.bindingsByAction = new Map;
  }
  start() {
    if (!this.valueListObserver) {
      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
      this.valueListObserver.start();
    }
  }
  stop() {
    if (this.valueListObserver) {
      this.valueListObserver.stop();
      delete this.valueListObserver;
      this.disconnectAllActions();
    }
  }
  get element() {
    return this.context.element;
  }
  get identifier() {
    return this.context.identifier;
  }
  get actionAttribute() {
    return this.schema.actionAttribute;
  }
  get schema() {
    return this.context.schema;
  }
  get bindings() {
    return Array.from(this.bindingsByAction.values());
  }
  connectAction(action) {
    const binding = new Binding(this.context, action);
    this.bindingsByAction.set(action, binding);
    this.delegate.bindingConnected(binding);
  }
  disconnectAction(action) {
    const binding = this.bindingsByAction.get(action);
    if (binding) {
      this.bindingsByAction.delete(action);
      this.delegate.bindingDisconnected(binding);
    }
  }
  disconnectAllActions() {
    this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
    this.bindingsByAction.clear();
  }
  parseValueForToken(token) {
    const action = Action.forToken(token, this.schema);
    if (action.identifier == this.identifier) {
      return action;
    }
  }
  elementMatchedValue(element, action) {
    this.connectAction(action);
  }
  elementUnmatchedValue(element, action) {
    this.disconnectAction(action);
  }
}

class ValueObserver {
  constructor(context, receiver) {
    this.context = context;
    this.receiver = receiver;
    this.stringMapObserver = new StringMapObserver(this.element, this);
    this.valueDescriptorMap = this.controller.valueDescriptorMap;
  }
  start() {
    this.stringMapObserver.start();
    this.invokeChangedCallbacksForDefaultValues();
  }
  stop() {
    this.stringMapObserver.stop();
  }
  get element() {
    return this.context.element;
  }
  get controller() {
    return this.context.controller;
  }
  getStringMapKeyForAttribute(attributeName) {
    if (attributeName in this.valueDescriptorMap) {
      return this.valueDescriptorMap[attributeName].name;
    }
  }
  stringMapKeyAdded(key, attributeName) {
    const descriptor = this.valueDescriptorMap[attributeName];
    if (!this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
    }
  }
  stringMapValueChanged(value, name, oldValue) {
    const descriptor = this.valueDescriptorNameMap[name];
    if (value === null)
      return;
    if (oldValue === null) {
      oldValue = descriptor.writer(descriptor.defaultValue);
    }
    this.invokeChangedCallback(name, value, oldValue);
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    const descriptor = this.valueDescriptorNameMap[key];
    if (this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
    } else {
      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
    }
  }
  invokeChangedCallbacksForDefaultValues() {
    for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
      if (defaultValue != null && !this.controller.data.has(key)) {
        this.invokeChangedCallback(name, writer(defaultValue), undefined);
      }
    }
  }
  invokeChangedCallback(name, rawValue, rawOldValue) {
    const changedMethodName = `${name}Changed`;
    const changedMethod = this.receiver[changedMethodName];
    if (typeof changedMethod == "function") {
      const descriptor = this.valueDescriptorNameMap[name];
      try {
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      } catch (error2) {
        if (error2 instanceof TypeError) {
          error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
        }
        throw error2;
      }
    }
  }
  get valueDescriptors() {
    const { valueDescriptorMap } = this;
    return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
  }
  get valueDescriptorNameMap() {
    const descriptors = {};
    Object.keys(this.valueDescriptorMap).forEach((key) => {
      const descriptor = this.valueDescriptorMap[key];
      descriptors[descriptor.name] = descriptor;
    });
    return descriptors;
  }
  hasValue(attributeName) {
    const descriptor = this.valueDescriptorNameMap[attributeName];
    const hasMethodName = `has${capitalize(descriptor.name)}`;
    return this.receiver[hasMethodName];
  }
}

class TargetObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.targetsByName = new Multimap;
  }
  start() {
    if (!this.tokenListObserver) {
      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
      this.tokenListObserver.start();
    }
  }
  stop() {
    if (this.tokenListObserver) {
      this.disconnectAllTargets();
      this.tokenListObserver.stop();
      delete this.tokenListObserver;
    }
  }
  tokenMatched({ element, content: name }) {
    if (this.scope.containsElement(element)) {
      this.connectTarget(element, name);
    }
  }
  tokenUnmatched({ element, content: name }) {
    this.disconnectTarget(element, name);
  }
  connectTarget(element, name) {
    var _a;
    if (!this.targetsByName.has(name, element)) {
      this.targetsByName.add(name, element);
      (_a = this.tokenListObserver) === null || _a === undefined || _a.pause(() => this.delegate.targetConnected(element, name));
    }
  }
  disconnectTarget(element, name) {
    var _a;
    if (this.targetsByName.has(name, element)) {
      this.targetsByName.delete(name, element);
      (_a = this.tokenListObserver) === null || _a === undefined || _a.pause(() => this.delegate.targetDisconnected(element, name));
    }
  }
  disconnectAllTargets() {
    for (const name of this.targetsByName.keys) {
      for (const element of this.targetsByName.getValuesForKey(name)) {
        this.disconnectTarget(element, name);
      }
    }
  }
  get attributeName() {
    return `data-${this.context.identifier}-target`;
  }
  get element() {
    return this.context.element;
  }
  get scope() {
    return this.context.scope;
  }
}

class OutletObserver {
  constructor(context, delegate) {
    this.started = false;
    this.context = context;
    this.delegate = delegate;
    this.outletsByName = new Multimap;
    this.outletElementsByName = new Multimap;
    this.selectorObserverMap = new Map;
    this.attributeObserverMap = new Map;
  }
  start() {
    if (!this.started) {
      this.outletDefinitions.forEach((outletName) => {
        this.setupSelectorObserverForOutlet(outletName);
        this.setupAttributeObserverForOutlet(outletName);
      });
      this.started = true;
      this.dependentContexts.forEach((context) => context.refresh());
    }
  }
  refresh() {
    this.selectorObserverMap.forEach((observer) => observer.refresh());
    this.attributeObserverMap.forEach((observer) => observer.refresh());
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.disconnectAllOutlets();
      this.stopSelectorObservers();
      this.stopAttributeObservers();
    }
  }
  stopSelectorObservers() {
    if (this.selectorObserverMap.size > 0) {
      this.selectorObserverMap.forEach((observer) => observer.stop());
      this.selectorObserverMap.clear();
    }
  }
  stopAttributeObservers() {
    if (this.attributeObserverMap.size > 0) {
      this.attributeObserverMap.forEach((observer) => observer.stop());
      this.attributeObserverMap.clear();
    }
  }
  selectorMatched(element, _selector, { outletName }) {
    const outlet = this.getOutlet(element, outletName);
    if (outlet) {
      this.connectOutlet(outlet, element, outletName);
    }
  }
  selectorUnmatched(element, _selector, { outletName }) {
    const outlet = this.getOutletFromMap(element, outletName);
    if (outlet) {
      this.disconnectOutlet(outlet, element, outletName);
    }
  }
  selectorMatchElement(element, { outletName }) {
    const selector = this.selector(outletName);
    const hasOutlet = this.hasOutlet(element, outletName);
    const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
    if (selector) {
      return hasOutlet && hasOutletController && element.matches(selector);
    } else {
      return false;
    }
  }
  elementMatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementAttributeValueChanged(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementUnmatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  connectOutlet(outlet, element, outletName) {
    var _a;
    if (!this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.add(outletName, outlet);
      this.outletElementsByName.add(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === undefined || _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
    }
  }
  disconnectOutlet(outlet, element, outletName) {
    var _a;
    if (this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.delete(outletName, outlet);
      this.outletElementsByName.delete(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === undefined || _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
    }
  }
  disconnectAllOutlets() {
    for (const outletName of this.outletElementsByName.keys) {
      for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
        for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
          this.disconnectOutlet(outlet, element, outletName);
        }
      }
    }
  }
  updateSelectorObserverForOutlet(outletName) {
    const observer = this.selectorObserverMap.get(outletName);
    if (observer) {
      observer.selector = this.selector(outletName);
    }
  }
  setupSelectorObserverForOutlet(outletName) {
    const selector = this.selector(outletName);
    const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
    this.selectorObserverMap.set(outletName, selectorObserver);
    selectorObserver.start();
  }
  setupAttributeObserverForOutlet(outletName) {
    const attributeName = this.attributeNameForOutletName(outletName);
    const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
    this.attributeObserverMap.set(outletName, attributeObserver);
    attributeObserver.start();
  }
  selector(outletName) {
    return this.scope.outlets.getSelectorForOutletName(outletName);
  }
  attributeNameForOutletName(outletName) {
    return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
  }
  getOutletNameFromOutletAttributeName(attributeName) {
    return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
  }
  get outletDependencies() {
    const dependencies = new Multimap;
    this.router.modules.forEach((module) => {
      const constructor = module.definition.controllerConstructor;
      const outlets = readInheritableStaticArrayValues(constructor, "outlets");
      outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
    });
    return dependencies;
  }
  get outletDefinitions() {
    return this.outletDependencies.getKeysForValue(this.identifier);
  }
  get dependentControllerIdentifiers() {
    return this.outletDependencies.getValuesForKey(this.identifier);
  }
  get dependentContexts() {
    const identifiers = this.dependentControllerIdentifiers;
    return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
  }
  hasOutlet(element, outletName) {
    return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
  }
  getOutlet(element, outletName) {
    return this.application.getControllerForElementAndIdentifier(element, outletName);
  }
  getOutletFromMap(element, outletName) {
    return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
  }
  get scope() {
    return this.context.scope;
  }
  get schema() {
    return this.context.schema;
  }
  get identifier() {
    return this.context.identifier;
  }
  get application() {
    return this.context.application;
  }
  get router() {
    return this.application.router;
  }
}

class Context {
  constructor(module, scope) {
    this.logDebugActivity = (functionName, detail = {}) => {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.logDebugActivity(this.identifier, functionName, detail);
    };
    this.module = module;
    this.scope = scope;
    this.controller = new module.controllerConstructor(this);
    this.bindingObserver = new BindingObserver(this, this.dispatcher);
    this.valueObserver = new ValueObserver(this, this.controller);
    this.targetObserver = new TargetObserver(this, this);
    this.outletObserver = new OutletObserver(this, this);
    try {
      this.controller.initialize();
      this.logDebugActivity("initialize");
    } catch (error2) {
      this.handleError(error2, "initializing controller");
    }
  }
  connect() {
    this.bindingObserver.start();
    this.valueObserver.start();
    this.targetObserver.start();
    this.outletObserver.start();
    try {
      this.controller.connect();
      this.logDebugActivity("connect");
    } catch (error2) {
      this.handleError(error2, "connecting controller");
    }
  }
  refresh() {
    this.outletObserver.refresh();
  }
  disconnect() {
    try {
      this.controller.disconnect();
      this.logDebugActivity("disconnect");
    } catch (error2) {
      this.handleError(error2, "disconnecting controller");
    }
    this.outletObserver.stop();
    this.targetObserver.stop();
    this.valueObserver.stop();
    this.bindingObserver.stop();
  }
  get application() {
    return this.module.application;
  }
  get identifier() {
    return this.module.identifier;
  }
  get schema() {
    return this.application.schema;
  }
  get dispatcher() {
    return this.application.dispatcher;
  }
  get element() {
    return this.scope.element;
  }
  get parentElement() {
    return this.element.parentElement;
  }
  handleError(error2, message, detail = {}) {
    const { identifier, controller, element } = this;
    detail = Object.assign({ identifier, controller, element }, detail);
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  targetConnected(element, name) {
    this.invokeControllerMethod(`${name}TargetConnected`, element);
  }
  targetDisconnected(element, name) {
    this.invokeControllerMethod(`${name}TargetDisconnected`, element);
  }
  outletConnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
  }
  outletDisconnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
  }
  invokeControllerMethod(methodName, ...args) {
    const controller = this.controller;
    if (typeof controller[methodName] == "function") {
      controller[methodName](...args);
    }
  }
}
var getOwnKeys = (() => {
  if (typeof Object.getOwnPropertySymbols == "function") {
    return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
  } else {
    return Object.getOwnPropertyNames;
  }
})();
var extend2 = (() => {
  function extendWithReflect(constructor) {
    function extended() {
      return Reflect.construct(constructor, arguments, new.target);
    }
    extended.prototype = Object.create(constructor.prototype, {
      constructor: { value: extended }
    });
    Reflect.setPrototypeOf(extended, constructor);
    return extended;
  }
  function testReflectExtension() {
    const a = function() {
      this.a.call(this);
    };
    const b = extendWithReflect(a);
    b.prototype.a = function() {
    };
    return new b;
  }
  try {
    testReflectExtension();
    return extendWithReflect;
  } catch (error2) {
    return (constructor) => class extended extends constructor {
    };
  }
})();

class Module {
  constructor(application, definition) {
    this.application = application;
    this.definition = blessDefinition(definition);
    this.contextsByScope = new WeakMap;
    this.connectedContexts = new Set;
  }
  get identifier() {
    return this.definition.identifier;
  }
  get controllerConstructor() {
    return this.definition.controllerConstructor;
  }
  get contexts() {
    return Array.from(this.connectedContexts);
  }
  connectContextForScope(scope) {
    const context = this.fetchContextForScope(scope);
    this.connectedContexts.add(context);
    context.connect();
  }
  disconnectContextForScope(scope) {
    const context = this.contextsByScope.get(scope);
    if (context) {
      this.connectedContexts.delete(context);
      context.disconnect();
    }
  }
  fetchContextForScope(scope) {
    let context = this.contextsByScope.get(scope);
    if (!context) {
      context = new Context(this, scope);
      this.contextsByScope.set(scope, context);
    }
    return context;
  }
}

class ClassMap {
  constructor(scope) {
    this.scope = scope;
  }
  has(name) {
    return this.data.has(this.getDataKey(name));
  }
  get(name) {
    return this.getAll(name)[0];
  }
  getAll(name) {
    const tokenString = this.data.get(this.getDataKey(name)) || "";
    return tokenize(tokenString);
  }
  getAttributeName(name) {
    return this.data.getAttributeNameForKey(this.getDataKey(name));
  }
  getDataKey(name) {
    return `${name}-class`;
  }
  get data() {
    return this.scope.data;
  }
}

class DataMap {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.getAttribute(name);
  }
  set(key, value) {
    const name = this.getAttributeNameForKey(key);
    this.element.setAttribute(name, value);
    return this.get(key);
  }
  has(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.hasAttribute(name);
  }
  delete(key) {
    if (this.has(key)) {
      const name = this.getAttributeNameForKey(key);
      this.element.removeAttribute(name);
      return true;
    } else {
      return false;
    }
  }
  getAttributeNameForKey(key) {
    return `data-${this.identifier}-${dasherize(key)}`;
  }
}

class Guide {
  constructor(logger6) {
    this.warnedKeysByObject = new WeakMap;
    this.logger = logger6;
  }
  warn(object, key, message) {
    let warnedKeys = this.warnedKeysByObject.get(object);
    if (!warnedKeys) {
      warnedKeys = new Set;
      this.warnedKeysByObject.set(object, warnedKeys);
    }
    if (!warnedKeys.has(key)) {
      warnedKeys.add(key);
      this.logger.warn(message, object);
    }
  }
}

class TargetSet {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(targetName) {
    return this.find(targetName) != null;
  }
  find(...targetNames) {
    return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);
  }
  findAll(...targetNames) {
    return targetNames.reduce((targets, targetName) => [
      ...targets,
      ...this.findAllTargets(targetName),
      ...this.findAllLegacyTargets(targetName)
    ], []);
  }
  findTarget(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findElement(selector);
  }
  findAllTargets(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findAllElements(selector);
  }
  getSelectorForTargetName(targetName) {
    const attributeName = this.schema.targetAttributeForScope(this.identifier);
    return attributeValueContainsToken(attributeName, targetName);
  }
  findLegacyTarget(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.deprecate(this.scope.findElement(selector), targetName);
  }
  findAllLegacyTargets(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
  }
  getLegacySelectorForTargetName(targetName) {
    const targetDescriptor = `${this.identifier}.${targetName}`;
    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
  }
  deprecate(element, targetName) {
    if (element) {
      const { identifier } = this;
      const attributeName = this.schema.targetAttribute;
      const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
      this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` + `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
    }
    return element;
  }
  get guide() {
    return this.scope.guide;
  }
}

class OutletSet {
  constructor(scope, controllerElement) {
    this.scope = scope;
    this.controllerElement = controllerElement;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(outletName) {
    return this.find(outletName) != null;
  }
  find(...outletNames) {
    return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), undefined);
  }
  findAll(...outletNames) {
    return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
  }
  getSelectorForOutletName(outletName) {
    const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
    return this.controllerElement.getAttribute(attributeName);
  }
  findOutlet(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    if (selector)
      return this.findElement(selector, outletName);
  }
  findAllOutlets(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    return selector ? this.findAllElements(selector, outletName) : [];
  }
  findElement(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
  }
  findAllElements(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter((element) => this.matchesElement(element, selector, outletName));
  }
  matchesElement(element, selector, outletName) {
    const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
    return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
  }
}

class Scope {
  constructor(schema, element, identifier, logger6) {
    this.targets = new TargetSet(this);
    this.classes = new ClassMap(this);
    this.data = new DataMap(this);
    this.containsElement = (element2) => {
      return element2.closest(this.controllerSelector) === this.element;
    };
    this.schema = schema;
    this.element = element;
    this.identifier = identifier;
    this.guide = new Guide(logger6);
    this.outlets = new OutletSet(this.documentScope, element);
  }
  findElement(selector) {
    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
  }
  findAllElements(selector) {
    return [
      ...this.element.matches(selector) ? [this.element] : [],
      ...this.queryElements(selector).filter(this.containsElement)
    ];
  }
  queryElements(selector) {
    return Array.from(this.element.querySelectorAll(selector));
  }
  get controllerSelector() {
    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
  }
  get isDocumentScope() {
    return this.element === document.documentElement;
  }
  get documentScope() {
    return this.isDocumentScope ? this : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
  }
}

class ScopeObserver {
  constructor(element, schema, delegate) {
    this.element = element;
    this.schema = schema;
    this.delegate = delegate;
    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
    this.scopesByIdentifierByElement = new WeakMap;
    this.scopeReferenceCounts = new WeakMap;
  }
  start() {
    this.valueListObserver.start();
  }
  stop() {
    this.valueListObserver.stop();
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  parseValueForToken(token) {
    const { element, content: identifier } = token;
    return this.parseValueForElementAndIdentifier(element, identifier);
  }
  parseValueForElementAndIdentifier(element, identifier) {
    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
    let scope = scopesByIdentifier.get(identifier);
    if (!scope) {
      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
      scopesByIdentifier.set(identifier, scope);
    }
    return scope;
  }
  elementMatchedValue(element, value) {
    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
    this.scopeReferenceCounts.set(value, referenceCount);
    if (referenceCount == 1) {
      this.delegate.scopeConnected(value);
    }
  }
  elementUnmatchedValue(element, value) {
    const referenceCount = this.scopeReferenceCounts.get(value);
    if (referenceCount) {
      this.scopeReferenceCounts.set(value, referenceCount - 1);
      if (referenceCount == 1) {
        this.delegate.scopeDisconnected(value);
      }
    }
  }
  fetchScopesByIdentifierForElement(element) {
    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
    if (!scopesByIdentifier) {
      scopesByIdentifier = new Map;
      this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
    }
    return scopesByIdentifier;
  }
}

class Router {
  constructor(application) {
    this.application = application;
    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
    this.scopesByIdentifier = new Multimap;
    this.modulesByIdentifier = new Map;
  }
  get element() {
    return this.application.element;
  }
  get schema() {
    return this.application.schema;
  }
  get logger() {
    return this.application.logger;
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  get modules() {
    return Array.from(this.modulesByIdentifier.values());
  }
  get contexts() {
    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
  }
  start() {
    this.scopeObserver.start();
  }
  stop() {
    this.scopeObserver.stop();
  }
  loadDefinition(definition) {
    this.unloadIdentifier(definition.identifier);
    const module = new Module(this.application, definition);
    this.connectModule(module);
    const afterLoad = definition.controllerConstructor.afterLoad;
    if (afterLoad) {
      afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
    }
  }
  unloadIdentifier(identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      this.disconnectModule(module);
    }
  }
  getContextForElementAndIdentifier(element, identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      return module.contexts.find((context) => context.element == element);
    }
  }
  proposeToConnectScopeForElementAndIdentifier(element, identifier) {
    const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
    if (scope) {
      this.scopeObserver.elementMatchedValue(scope.element, scope);
    } else {
      console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
    }
  }
  handleError(error2, message, detail) {
    this.application.handleError(error2, message, detail);
  }
  createScopeForElementAndIdentifier(element, identifier) {
    return new Scope(this.schema, element, identifier, this.logger);
  }
  scopeConnected(scope) {
    this.scopesByIdentifier.add(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.connectContextForScope(scope);
    }
  }
  scopeDisconnected(scope) {
    this.scopesByIdentifier.delete(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.disconnectContextForScope(scope);
    }
  }
  connectModule(module) {
    this.modulesByIdentifier.set(module.identifier, module);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.connectContextForScope(scope));
  }
  disconnectModule(module) {
    this.modulesByIdentifier.delete(module.identifier);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.disconnectContextForScope(scope));
  }
}
var defaultSchema = {
  controllerAttribute: "data-controller",
  actionAttribute: "data-action",
  targetAttribute: "data-target",
  targetAttributeForScope: (identifier) => `data-${identifier}-target`,
  outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
  keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
};

class Application {
  constructor(element = document.documentElement, schema = defaultSchema) {
    this.logger = console;
    this.debug = false;
    this.logDebugActivity = (identifier, functionName, detail = {}) => {
      if (this.debug) {
        this.logFormattedMessage(identifier, functionName, detail);
      }
    };
    this.element = element;
    this.schema = schema;
    this.dispatcher = new Dispatcher(this);
    this.router = new Router(this);
    this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
  }
  static start(element, schema) {
    const application = new this(element, schema);
    application.start();
    return application;
  }
  async start() {
    await domReady();
    this.logDebugActivity("application", "starting");
    this.dispatcher.start();
    this.router.start();
    this.logDebugActivity("application", "start");
  }
  stop() {
    this.logDebugActivity("application", "stopping");
    this.dispatcher.stop();
    this.router.stop();
    this.logDebugActivity("application", "stop");
  }
  register(identifier, controllerConstructor) {
    this.load({ identifier, controllerConstructor });
  }
  registerActionOption(name, filter) {
    this.actionDescriptorFilters[name] = filter;
  }
  load(head, ...rest) {
    const definitions = Array.isArray(head) ? head : [head, ...rest];
    definitions.forEach((definition) => {
      if (definition.controllerConstructor.shouldLoad) {
        this.router.loadDefinition(definition);
      }
    });
  }
  unload(head, ...rest) {
    const identifiers = Array.isArray(head) ? head : [head, ...rest];
    identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
  }
  get controllers() {
    return this.router.contexts.map((context) => context.controller);
  }
  getControllerForElementAndIdentifier(element, identifier) {
    const context = this.router.getContextForElementAndIdentifier(element, identifier);
    return context ? context.controller : null;
  }
  handleError(error2, message, detail) {
    var _a;
    this.logger.error(`%s\n\n%o\n\n%o`, message, error2, detail);
    (_a = window.onerror) === null || _a === undefined || _a.call(window, message, "", 0, 0, error2);
  }
  logFormattedMessage(identifier, functionName, detail = {}) {
    detail = Object.assign({ application: this }, detail);
    this.logger.groupCollapsed(`${identifier} #${functionName}`);
    this.logger.log("details:", Object.assign({}, detail));
    this.logger.groupEnd();
  }
}
var defaultValuesByType = {
  get array() {
    return [];
  },
  boolean: false,
  number: 0,
  get object() {
    return {};
  },
  string: ""
};
var readers = {
  array(value) {
    const array = JSON.parse(value);
    if (!Array.isArray(array)) {
      throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
    }
    return array;
  },
  boolean(value) {
    return !(value == "0" || String(value).toLowerCase() == "false");
  },
  number(value) {
    return Number(value.replace(/_/g, ""));
  },
  object(value) {
    const object = JSON.parse(value);
    if (object === null || typeof object != "object" || Array.isArray(object)) {
      throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
    }
    return object;
  },
  string(value) {
    return value;
  }
};
var writers = {
  default: writeString,
  array: writeJSON,
  object: writeJSON
};

class Controller {
  constructor(context) {
    this.context = context;
  }
  static get shouldLoad() {
    return true;
  }
  static afterLoad(_identifier, _application) {
    return;
  }
  get application() {
    return this.context.application;
  }
  get scope() {
    return this.context.scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get targets() {
    return this.scope.targets;
  }
  get outlets() {
    return this.scope.outlets;
  }
  get classes() {
    return this.scope.classes;
  }
  get data() {
    return this.scope.data;
  }
  initialize() {
  }
  connect() {
  }
  disconnect() {
  }
  dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
    const type = prefix ? `${prefix}:${eventName}` : eventName;
    const event = new CustomEvent(type, { detail, bubbles, cancelable });
    target.dispatchEvent(event);
    return event;
  }
}
Controller.blessings = [
  ClassPropertiesBlessing,
  TargetPropertiesBlessing,
  ValuePropertiesBlessing,
  OutletPropertiesBlessing
];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};

// app/javascript/controllers/application.js
var application = Application.start();
application.debug = false;
window.Stimulus = application;

// node_modules/apexcharts/dist/apexcharts.esm.js
var t = function(t2, e) {
  (e == null || e > t2.length) && (e = t2.length);
  for (var i = 0, a = Array(e);i < e; i++)
    a[i] = t2[i];
  return a;
};
var e = function(t2) {
  if (t2 === undefined)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t2;
};
var i = function(t2, e2) {
  if (!(t2 instanceof e2))
    throw new TypeError("Cannot call a class as a function");
};
var a = function(t2, e2) {
  for (var i2 = 0;i2 < e2.length; i2++) {
    var a2 = e2[i2];
    a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(t2, x(a2.key), a2);
  }
};
var s = function(t2, e2, i2) {
  return e2 && a(t2.prototype, e2), i2 && a(t2, i2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
};
var r = function(t2, e2) {
  var i2 = typeof Symbol != "undefined" && t2[Symbol.iterator] || t2["@@iterator"];
  if (!i2) {
    if (Array.isArray(t2) || (i2 = m(t2)) || e2 && t2 && typeof t2.length == "number") {
      i2 && (t2 = i2);
      var a2 = 0, s2 = function() {
      };
      return { s: s2, n: function() {
        return a2 >= t2.length ? { done: true } : { done: false, value: t2[a2++] };
      }, e: function(t3) {
        throw t3;
      }, f: s2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var r2, n = true, o = false;
  return { s: function() {
    i2 = i2.call(t2);
  }, n: function() {
    var t3 = i2.next();
    return n = t3.done, t3;
  }, e: function(t3) {
    o = true, r2 = t3;
  }, f: function() {
    try {
      n || i2.return == null || i2.return();
    } finally {
      if (o)
        throw r2;
    }
  } };
};
var n = function(t2) {
  var i2 = c();
  return function() {
    var a2, s2 = l(t2);
    if (i2) {
      var r2 = l(this).constructor;
      a2 = Reflect.construct(s2, arguments, r2);
    } else
      a2 = s2.apply(this, arguments);
    return function(t3, i3) {
      if (i3 && (typeof i3 == "object" || typeof i3 == "function"))
        return i3;
      if (i3 !== undefined)
        throw new TypeError("Derived constructors may only return object or undefined");
      return e(t3);
    }(this, a2);
  };
};
var o = function(t2, e2, i2) {
  return (e2 = x(e2)) in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
};
var l = function(t2) {
  return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, l(t2);
};
var h = function(t2, e2) {
  if (typeof e2 != "function" && e2 !== null)
    throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, "prototype", { writable: false }), e2 && g(t2, e2);
};
var c = function() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (c = function() {
    return !!t2;
  })();
};
var d = function(t2, e2) {
  var i2 = Object.keys(t2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(t2);
    e2 && (a2 = a2.filter(function(e3) {
      return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
    })), i2.push.apply(i2, a2);
  }
  return i2;
};
var u = function(t2) {
  for (var e2 = 1;e2 < arguments.length; e2++) {
    var i2 = arguments[e2] != null ? arguments[e2] : {};
    e2 % 2 ? d(Object(i2), true).forEach(function(e3) {
      o(t2, e3, i2[e3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i2)) : d(Object(i2)).forEach(function(e3) {
      Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(i2, e3));
    });
  }
  return t2;
};
var g = function(t2, e2) {
  return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, g(t2, e2);
};
var p = function(t2, e2) {
  return function(t3) {
    if (Array.isArray(t3))
      return t3;
  }(t2) || function(t3, e3) {
    var i2 = t3 == null ? null : typeof Symbol != "undefined" && t3[Symbol.iterator] || t3["@@iterator"];
    if (i2 != null) {
      var a2, s2, r2, n2, o2 = [], l2 = true, h2 = false;
      try {
        if (r2 = (i2 = i2.call(t3)).next, e3 === 0) {
          if (Object(i2) !== i2)
            return;
          l2 = false;
        } else
          for (;!(l2 = (a2 = r2.call(i2)).done) && (o2.push(a2.value), o2.length !== e3); l2 = true)
            ;
      } catch (t4) {
        h2 = true, s2 = t4;
      } finally {
        try {
          if (!l2 && i2.return != null && (n2 = i2.return(), Object(n2) !== n2))
            return;
        } finally {
          if (h2)
            throw s2;
        }
      }
      return o2;
    }
  }(t2, e2) || m(t2, e2) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
};
var f = function(e2) {
  return function(e3) {
    if (Array.isArray(e3))
      return t(e3);
  }(e2) || function(t2) {
    if (typeof Symbol != "undefined" && t2[Symbol.iterator] != null || t2["@@iterator"] != null)
      return Array.from(t2);
  }(e2) || m(e2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
};
var x = function(t2) {
  var e2 = function(t3, e3) {
    if (typeof t3 != "object" || !t3)
      return t3;
    var i2 = t3[Symbol.toPrimitive];
    if (i2 !== undefined) {
      var a2 = i2.call(t3, e3 || "default");
      if (typeof a2 != "object")
        return a2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (e3 === "string" ? String : Number)(t3);
  }(t2, "string");
  return typeof e2 == "symbol" ? e2 : e2 + "";
};
var b = function(t2) {
  return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
    return typeof t3;
  } : function(t3) {
    return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
  }, b(t2);
};
var m = function(e2, i2) {
  if (e2) {
    if (typeof e2 == "string")
      return t(e2, i2);
    var a2 = {}.toString.call(e2).slice(8, -1);
    return a2 === "Object" && e2.constructor && (a2 = e2.constructor.name), a2 === "Map" || a2 === "Set" ? Array.from(e2) : a2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a2) ? t(e2, i2) : undefined;
  }
};
var A = function(t2, e2) {
  if (Array.isArray(t2))
    for (const i2 of t2)
      A(i2, e2);
  else if (typeof t2 != "object")
    S(Object.getOwnPropertyNames(e2)), w[t2] = Object.assign(w[t2] || {}, e2);
  else
    for (const e3 in t2)
      A(e3, t2[e3]);
};
var C = function(t2) {
  return w[t2] || {};
};
var S = function(t2) {
  k.push(...t2);
};
var L = function(t2, e2) {
  let i2;
  const a2 = t2.length, s2 = [];
  for (i2 = 0;i2 < a2; i2++)
    s2.push(e2(t2[i2]));
  return s2;
};
var M = function(t2) {
  return t2 % 360 * Math.PI / 180;
};
var P = function(t2) {
  return t2.charAt(0).toUpperCase() + t2.slice(1);
};
var I = function(t2, e2, i2, a2) {
  return e2 != null && i2 != null || (a2 = a2 || t2.bbox(), e2 == null ? e2 = a2.width / a2.height * i2 : i2 == null && (i2 = a2.height / a2.width * e2)), { width: e2, height: i2 };
};
var T = function(t2, e2) {
  const i2 = t2.origin;
  let a2 = t2.ox != null ? t2.ox : t2.originX != null ? t2.originX : "center", s2 = t2.oy != null ? t2.oy : t2.originY != null ? t2.originY : "center";
  i2 != null && ([a2, s2] = Array.isArray(i2) ? i2 : typeof i2 == "object" ? [i2.x, i2.y] : [i2, i2]);
  const r2 = typeof a2 == "string", n2 = typeof s2 == "string";
  if (r2 || n2) {
    const { height: t3, width: i3, x: o2, y: l2 } = e2.bbox();
    r2 && (a2 = a2.includes("left") ? o2 : a2.includes("right") ? o2 + i3 : o2 + i3 / 2), n2 && (s2 = s2.includes("top") ? l2 : s2.includes("bottom") ? l2 + t3 : l2 + t3 / 2);
  }
  return [a2, s2];
};
var F = function() {
  return O.window;
};
var W = function(t2, e2 = E) {
  return O.document.createElementNS(e2, t2);
};
var B = function(t2, e2 = false) {
  if (t2 instanceof D)
    return t2;
  if (typeof t2 == "object")
    return U(t2);
  if (t2 == null)
    return new _[N];
  if (typeof t2 == "string" && t2.charAt(0) !== "<")
    return U(O.document.querySelector(t2));
  const i2 = e2 ? O.document.createElement("div") : W("svg");
  return i2.innerHTML = t2, t2 = U(i2.firstChild), i2.removeChild(i2.firstChild), t2;
};
var G = function(t2, e2) {
  return e2 && (e2 instanceof O.window.Node || e2.ownerDocument && e2 instanceof e2.ownerDocument.defaultView.Node) ? e2 : W(t2);
};
var V = function(t2) {
  if (!t2)
    return null;
  if (t2.instance instanceof D)
    return t2.instance;
  if (t2.nodeName === "#document-fragment")
    return new _.Fragment(t2);
  let e2 = P(t2.nodeName || "Dom");
  return e2 === "LinearGradient" || e2 === "RadialGradient" ? e2 = "Gradient" : _[e2] || (e2 = "Dom"), new _[e2](t2);
};
var q = function(t2, e2 = t2.name, i2 = false) {
  return _[e2] = t2, i2 && (_[N] = t2), S(Object.getOwnPropertyNames(t2.prototype)), t2;
};
var $ = function(t2) {
  return "Svgjs" + P(t2) + Z++;
};
var J = function(t2) {
  for (let e2 = t2.children.length - 1;e2 >= 0; e2--)
    J(t2.children[e2]);
  return t2.id ? (t2.id = $(t2.nodeName), t2) : t2;
};
var Q = function(t2, e2) {
  let i2, a2;
  for (a2 = (t2 = Array.isArray(t2) ? t2 : [t2]).length - 1;a2 >= 0; a2--)
    for (i2 in e2)
      t2[a2].prototype[i2] = e2[i2];
};
var K = function(t2) {
  return function(...e2) {
    const i2 = e2[e2.length - 1];
    return !i2 || i2.constructor !== Object || i2 instanceof Array ? t2.apply(this, e2) : t2.apply(this, e2.slice(0, -1)).attr(i2);
  };
};
var gt = function(t2) {
  const e2 = Math.round(t2), i2 = Math.max(0, Math.min(255, e2)).toString(16);
  return i2.length === 1 ? "0" + i2 : i2;
};
var pt = function(t2, e2) {
  for (let i2 = e2.length;i2--; )
    if (t2[e2[i2]] == null)
      return false;
  return true;
};
var ft = function(t2, e2, i2) {
  return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? t2 + 6 * (e2 - t2) * i2 : i2 < 0.5 ? e2 : i2 < 2 / 3 ? t2 + (e2 - t2) * (2 / 3 - i2) * 6 : t2;
};
var mt = function(t2, e2, i2) {
  return Math.abs(e2 - t2) < (i2 || 0.000001);
};
var yt = function() {
  if (!yt.nodes) {
    const t2 = B().size(2, 0);
    t2.node.style.cssText = ["opacity: 0", "position: absolute", "left: -100%", "top: -100%", "overflow: hidden"].join(";"), t2.attr("focusable", "false"), t2.attr("aria-hidden", "true");
    const e2 = t2.path().node;
    yt.nodes = { svg: t2, path: e2 };
  }
  if (!yt.nodes.svg.node.parentNode) {
    const t2 = O.document.body || O.document.documentElement;
    yt.nodes.svg.addTo(t2);
  }
  return yt.nodes;
};
var wt = function(t2) {
  return !(t2.width || t2.height || t2.x || t2.y);
};
var At = function(t2, e2, i2) {
  let a2;
  try {
    if (a2 = e2(t2.node), wt(a2) && ((s2 = t2.node) !== O.document && !(O.document.documentElement.contains || function(t3) {
      for (;t3.parentNode; )
        t3 = t3.parentNode;
      return t3 === O.document;
    }).call(O.document.documentElement, s2)))
      throw new Error("Element not in the dom");
  } catch (e3) {
    a2 = i2(t2);
  }
  var s2;
  return a2;
};
var Lt = function(t2, e2) {
  return new Ct(L((e2 || O.document).querySelectorAll(t2), function(t3) {
    return V(t3);
  }));
};
var It = function(t2) {
  let e2 = t2.getEventHolder();
  return e2 === O.window && (e2 = Pt), e2.events || (e2.events = {}), e2.events;
};
var Tt = function(t2) {
  return t2.getEventTarget();
};
var zt = function(t2, e2, i2, a2, s2) {
  const r2 = i2.bind(a2 || t2), n2 = B(t2), o2 = It(n2), l2 = Tt(n2);
  e2 = Array.isArray(e2) ? e2 : e2.split(dt), i2._svgjsListenerId || (i2._svgjsListenerId = ++Mt), e2.forEach(function(t3) {
    const e3 = t3.split(".")[0], a3 = t3.split(".")[1] || "*";
    o2[e3] = o2[e3] || {}, o2[e3][a3] = o2[e3][a3] || {}, o2[e3][a3][i2._svgjsListenerId] = r2, l2.addEventListener(e3, r2, s2 || false);
  });
};
var Xt = function(t2, e2, i2, a2) {
  const s2 = B(t2), r2 = It(s2), n2 = Tt(s2);
  (typeof i2 != "function" || (i2 = i2._svgjsListenerId)) && (e2 = Array.isArray(e2) ? e2 : (e2 || "").split(dt)).forEach(function(t3) {
    const e3 = t3 && t3.split(".")[0], o2 = t3 && t3.split(".")[1];
    let l2, h2;
    if (i2)
      r2[e3] && r2[e3][o2 || "*"] && (n2.removeEventListener(e3, r2[e3][o2 || "*"][i2], a2 || false), delete r2[e3][o2 || "*"][i2]);
    else if (e3 && o2) {
      if (r2[e3] && r2[e3][o2]) {
        for (h2 in r2[e3][o2])
          Xt(n2, [e3, o2].join("."), h2);
        delete r2[e3][o2];
      }
    } else if (o2)
      for (t3 in r2)
        for (l2 in r2[t3])
          o2 === l2 && Xt(n2, [t3, o2].join("."));
    else if (e3) {
      if (r2[e3]) {
        for (l2 in r2[e3])
          Xt(n2, [e3, l2].join("."));
        delete r2[e3];
      }
    } else {
      for (t3 in r2)
        Xt(n2, t3);
      (function(t4) {
        let e4 = t4.getEventHolder();
        e4 === O.window && (e4 = Pt), e4.events && (e4.events = {});
      })(s2);
    }
  });
};
var Et = function() {
};
var Zt = function(t2) {
  return this.attr("rx", t2);
};
var $t = function(t2) {
  return this.attr("ry", t2);
};
var Jt = function(t2) {
  return t2 == null ? this.cx() - this.rx() : this.cx(t2 + this.rx());
};
var Qt = function(t2) {
  return t2 == null ? this.cy() - this.ry() : this.cy(t2 + this.ry());
};
var Kt = function(t2) {
  return this.attr("cx", t2);
};
var te = function(t2) {
  return this.attr("cy", t2);
};
var ee = function(t2) {
  return t2 == null ? 2 * this.rx() : this.rx(new _t(t2).divide(2));
};
var ie = function(t2) {
  return t2 == null ? 2 * this.ry() : this.ry(new _t(t2).divide(2));
};
var ne = function(t2, e2) {
  return (this._element || this).type === "radialGradient" ? this.attr({ fx: new _t(t2), fy: new _t(e2) }) : this.attr({ x1: new _t(t2), y1: new _t(e2) });
};
var oe = function(t2, e2) {
  return (this._element || this).type === "radialGradient" ? this.attr({ cx: new _t(t2), cy: new _t(e2) }) : this.attr({ x2: new _t(t2), y2: new _t(e2) });
};
var me = function(t2, e2) {
  return function(i2) {
    return i2 == null ? this[t2] : (this[t2] = i2, e2 && e2.call(this), this);
  };
};
var Ae = function() {
  const t2 = (this._duration || 500) / 1000, e2 = this._overshoot || 0, i2 = Math.PI, a2 = Math.log(e2 / 100 + 0.0000000001), s2 = -a2 / Math.sqrt(i2 * i2 + a2 * a2), r2 = 3.9 / (s2 * t2);
  this.d = 2 * s2 * r2, this.k = r2 * r2;
};
var Me = function(t2) {
  return t2.segment.length && t2.segment.length - 1 === Ce[t2.segment[0].toUpperCase()];
};
var Pe = function(t2, e2) {
  t2.inNumber && Ie(t2, false);
  const i2 = ut.test(e2);
  if (i2)
    t2.segment = [e2];
  else {
    const e3 = t2.lastCommand, i3 = e3.toLowerCase(), a2 = e3 === i3;
    t2.segment = [i3 === "m" ? a2 ? "l" : "L" : e3];
  }
  return t2.inSegment = true, t2.lastCommand = t2.segment[0], i2;
};
var Ie = function(t2, e2) {
  if (!t2.inNumber)
    throw new Error("Parser Error");
  t2.number && t2.segment.push(parseFloat(t2.number)), t2.inNumber = e2, t2.number = "", t2.pointSeen = false, t2.hasExponent = false, Me(t2) && Te(t2);
};
var Te = function(t2) {
  t2.inSegment = false, t2.absolute && (t2.segment = function(t3) {
    const e2 = t3.segment[0];
    return Se[e2](t3.segment.slice(1), t3.p, t3.p0);
  }(t2)), t2.segments.push(t2.segment);
};
var ze = function(t2) {
  if (!t2.segment.length)
    return false;
  const e2 = t2.segment[0].toUpperCase() === "A", i2 = t2.segment.length;
  return e2 && (i2 === 4 || i2 === 5);
};
var Xe = function(t2) {
  return t2.lastToken.toUpperCase() === "E";
};
var ii = function() {
  const t2 = this._transformationRunners.runners.map(ei).reduce(ti, new vt);
  this.transform(t2), this._transformationRunners.merge(), this._transformationRunners.length() === 1 && (this._frameId = null);
};
var Wa = function(t2, e2) {
  return (e2[1] - t2[1]) / (e2[0] - t2[0]);
};
var Qa = function(t2, e2, i2, a2 = null) {
  return function(s2) {
    s2.preventDefault(), s2.stopPropagation();
    var r2 = s2.pageX || s2.touches[0].pageX, n2 = s2.pageY || s2.touches[0].pageY;
    e2.fire(t2, { x: r2, y: n2, event: s2, index: a2, points: i2 });
  };
};
var Ka = function([t2, e2], { a: i2, b: a2, c: s2, d: r2, e: n2, f: o2 }) {
  return [t2 * i2 + e2 * s2 + n2, t2 * a2 + e2 * r2 + o2];
};
var is = function(t2, e2, i2, a2 = null) {
  return function(s2) {
    s2.preventDefault(), s2.stopPropagation();
    var r2 = s2.pageX || s2.touches[0].pageX, n2 = s2.pageY || s2.touches[0].pageY;
    e2.fire(t2, { x: r2, y: n2, event: s2, index: a2, points: i2 });
  };
};
var as = function([t2, e2], { a: i2, b: a2, c: s2, d: r2, e: n2, f: o2 }) {
  return [t2 * i2 + e2 * s2 + n2, t2 * a2 + e2 * r2 + o2];
};
/*!
 * ApexCharts v4.5.0
 * (c) 2018-2025 ApexCharts
 * Released under the MIT License.
 */
var v = function() {
  function t2() {
    i(this, t2);
  }
  return s(t2, [{ key: "shadeRGBColor", value: function(t3, e2) {
    var i2 = e2.split(","), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = parseInt(i2[0].slice(4), 10), n2 = parseInt(i2[1], 10), o2 = parseInt(i2[2], 10);
    return "rgb(" + (Math.round((a2 - r2) * s2) + r2) + "," + (Math.round((a2 - n2) * s2) + n2) + "," + (Math.round((a2 - o2) * s2) + o2) + ")";
  } }, { key: "shadeHexColor", value: function(t3, e2) {
    var i2 = parseInt(e2.slice(1), 16), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = i2 >> 16, n2 = i2 >> 8 & 255, o2 = 255 & i2;
    return "#" + (16777216 + 65536 * (Math.round((a2 - r2) * s2) + r2) + 256 * (Math.round((a2 - n2) * s2) + n2) + (Math.round((a2 - o2) * s2) + o2)).toString(16).slice(1);
  } }, { key: "shadeColor", value: function(e2, i2) {
    return t2.isColorHex(i2) ? this.shadeHexColor(e2, i2) : this.shadeRGBColor(e2, i2);
  } }], [{ key: "bind", value: function(t3, e2) {
    return function() {
      return t3.apply(e2, arguments);
    };
  } }, { key: "isObject", value: function(t3) {
    return t3 && b(t3) === "object" && !Array.isArray(t3) && t3 != null;
  } }, { key: "is", value: function(t3, e2) {
    return Object.prototype.toString.call(e2) === "[object " + t3 + "]";
  } }, { key: "listToArray", value: function(t3) {
    var e2, i2 = [];
    for (e2 = 0;e2 < t3.length; e2++)
      i2[e2] = t3[e2];
    return i2;
  } }, { key: "extend", value: function(t3, e2) {
    var i2 = this;
    typeof Object.assign != "function" && (Object.assign = function(t4) {
      if (t4 == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var e3 = Object(t4), i3 = 1;i3 < arguments.length; i3++) {
        var a3 = arguments[i3];
        if (a3 != null)
          for (var s2 in a3)
            a3.hasOwnProperty(s2) && (e3[s2] = a3[s2]);
      }
      return e3;
    });
    var a2 = Object.assign({}, t3);
    return this.isObject(t3) && this.isObject(e2) && Object.keys(e2).forEach(function(s2) {
      i2.isObject(e2[s2]) && s2 in t3 ? a2[s2] = i2.extend(t3[s2], e2[s2]) : Object.assign(a2, o({}, s2, e2[s2]));
    }), a2;
  } }, { key: "extendArray", value: function(e2, i2) {
    var a2 = [];
    return e2.map(function(e3) {
      a2.push(t2.extend(i2, e3));
    }), e2 = a2;
  } }, { key: "monthMod", value: function(t3) {
    return t3 % 12;
  } }, { key: "clone", value: function(t3) {
    var e2, i2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new WeakMap;
    if (t3 === null || b(t3) !== "object")
      return t3;
    if (i2.has(t3))
      return i2.get(t3);
    if (Array.isArray(t3)) {
      e2 = [], i2.set(t3, e2);
      for (var a2 = 0;a2 < t3.length; a2++)
        e2[a2] = this.clone(t3[a2], i2);
    } else if (t3 instanceof Date)
      e2 = new Date(t3.getTime());
    else
      for (var s2 in e2 = {}, i2.set(t3, e2), t3)
        t3.hasOwnProperty(s2) && (e2[s2] = this.clone(t3[s2], i2));
    return e2;
  } }, { key: "log10", value: function(t3) {
    return Math.log(t3) / Math.LN10;
  } }, { key: "roundToBase10", value: function(t3) {
    return Math.pow(10, Math.floor(Math.log10(t3)));
  } }, { key: "roundToBase", value: function(t3, e2) {
    return Math.pow(e2, Math.floor(Math.log(t3) / Math.log(e2)));
  } }, { key: "parseNumber", value: function(t3) {
    return t3 === null ? t3 : parseFloat(t3);
  } }, { key: "stripNumber", value: function(t3) {
    var e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    return Number.isInteger(t3) ? t3 : parseFloat(t3.toPrecision(e2));
  } }, { key: "randomId", value: function() {
    return (Math.random() + 1).toString(36).substring(4);
  } }, { key: "noExponents", value: function(t3) {
    return t3.toString().includes("e") ? Math.round(t3) : t3;
  } }, { key: "elementExists", value: function(t3) {
    return !(!t3 || !t3.isConnected);
  } }, { key: "getDimensions", value: function(t3) {
    var e2 = getComputedStyle(t3, null), i2 = t3.clientHeight, a2 = t3.clientWidth;
    return i2 -= parseFloat(e2.paddingTop) + parseFloat(e2.paddingBottom), [a2 -= parseFloat(e2.paddingLeft) + parseFloat(e2.paddingRight), i2];
  } }, { key: "getBoundingClientRect", value: function(t3) {
    var e2 = t3.getBoundingClientRect();
    return { top: e2.top, right: e2.right, bottom: e2.bottom, left: e2.left, width: t3.clientWidth, height: t3.clientHeight, x: e2.left, y: e2.top };
  } }, { key: "getLargestStringFromArr", value: function(t3) {
    return t3.reduce(function(t4, e2) {
      return Array.isArray(e2) && (e2 = e2.reduce(function(t5, e3) {
        return t5.length > e3.length ? t5 : e3;
      })), t4.length > e2.length ? t4 : e2;
    }, 0);
  } }, { key: "hexToRgba", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "#999999", e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.6;
    t3.substring(0, 1) !== "#" && (t3 = "#999999");
    var i2 = t3.replace("#", "");
    i2 = i2.match(new RegExp("(.{" + i2.length / 3 + "})", "g"));
    for (var a2 = 0;a2 < i2.length; a2++)
      i2[a2] = parseInt(i2[a2].length === 1 ? i2[a2] + i2[a2] : i2[a2], 16);
    return e2 !== undefined && i2.push(e2), "rgba(" + i2.join(",") + ")";
  } }, { key: "getOpacityFromRGBA", value: function(t3) {
    return parseFloat(t3.replace(/^.*,(.+)\)/, "$1"));
  } }, { key: "rgb2hex", value: function(t3) {
    return (t3 = t3.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && t3.length === 4 ? "#" + ("0" + parseInt(t3[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[3], 10).toString(16)).slice(-2) : "";
  } }, { key: "isColorHex", value: function(t3) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t3);
  } }, { key: "getPolygonPos", value: function(t3, e2) {
    for (var i2 = [], a2 = 2 * Math.PI / e2, s2 = 0;s2 < e2; s2++) {
      var r2 = {};
      r2.x = t3 * Math.sin(s2 * a2), r2.y = -t3 * Math.cos(s2 * a2), i2.push(r2);
    }
    return i2;
  } }, { key: "polarToCartesian", value: function(t3, e2, i2, a2) {
    var s2 = (a2 - 90) * Math.PI / 180;
    return { x: t3 + i2 * Math.cos(s2), y: e2 + i2 * Math.sin(s2) };
  } }, { key: "escapeString", value: function(t3) {
    var e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "x", i2 = t3.toString().slice();
    return i2 = i2.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e2);
  } }, { key: "negToZero", value: function(t3) {
    return t3 < 0 ? 0 : t3;
  } }, { key: "moveIndexInArray", value: function(t3, e2, i2) {
    if (i2 >= t3.length)
      for (var a2 = i2 - t3.length + 1;a2--; )
        t3.push(undefined);
    return t3.splice(i2, 0, t3.splice(e2, 1)[0]), t3;
  } }, { key: "extractNumber", value: function(t3) {
    return parseFloat(t3.replace(/[^\d.]*/g, ""));
  } }, { key: "findAncestor", value: function(t3, e2) {
    for (;(t3 = t3.parentElement) && !t3.classList.contains(e2); )
      ;
    return t3;
  } }, { key: "setELstyles", value: function(t3, e2) {
    for (var i2 in e2)
      e2.hasOwnProperty(i2) && (t3.style.key = e2[i2]);
  } }, { key: "preciseAddition", value: function(t3, e2) {
    var i2 = (String(t3).split(".")[1] || "").length, a2 = (String(e2).split(".")[1] || "").length, s2 = Math.pow(10, Math.max(i2, a2));
    return (Math.round(t3 * s2) + Math.round(e2 * s2)) / s2;
  } }, { key: "isNumber", value: function(t3) {
    return !isNaN(t3) && parseFloat(Number(t3)) === t3 && !isNaN(parseInt(t3, 10));
  } }, { key: "isFloat", value: function(t3) {
    return Number(t3) === t3 && t3 % 1 != 0;
  } }, { key: "isMsEdge", value: function() {
    var t3 = window.navigator.userAgent, e2 = t3.indexOf("Edge/");
    return e2 > 0 && parseInt(t3.substring(e2 + 5, t3.indexOf(".", e2)), 10);
  } }, { key: "getGCD", value: function(t3, e2) {
    var i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 7, a2 = Math.pow(10, i2 - Math.floor(Math.log10(Math.max(t3, e2))));
    for (t3 = Math.round(Math.abs(t3) * a2), e2 = Math.round(Math.abs(e2) * a2);e2; ) {
      var s2 = e2;
      e2 = t3 % e2, t3 = s2;
    }
    return t3 / a2;
  } }, { key: "getPrimeFactors", value: function(t3) {
    for (var e2 = [], i2 = 2;t3 >= 2; )
      t3 % i2 == 0 ? (e2.push(i2), t3 /= i2) : i2++;
    return e2;
  } }, { key: "mod", value: function(t3, e2) {
    var i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 7, a2 = Math.pow(10, i2 - Math.floor(Math.log10(Math.max(t3, e2))));
    return (t3 = Math.round(Math.abs(t3) * a2)) % (e2 = Math.round(Math.abs(e2) * a2)) / a2;
  } }]), t2;
}();
var y = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "animateLine", value: function(t3, e2, i2, a2) {
    t3.attr(e2).animate(a2).attr(i2);
  } }, { key: "animateMarker", value: function(t3, e2, i2, a2) {
    t3.attr({ opacity: 0 }).animate(e2).attr({ opacity: 1 }).after(function() {
      a2();
    });
  } }, { key: "animateRect", value: function(t3, e2, i2, a2, s2) {
    t3.attr(e2).animate(a2).attr(i2).after(function() {
      return s2();
    });
  } }, { key: "animatePathsGradually", value: function(t3) {
    var { el: e2, realIndex: i2, j: a2, fill: s2, pathFrom: r2, pathTo: n2, speed: o2, delay: l2 } = t3, h2 = this.w, c2 = 0;
    h2.config.chart.animations.animateGradually.enabled && (c2 = h2.config.chart.animations.animateGradually.delay), h2.config.chart.animations.dynamicAnimation.enabled && h2.globals.dataChanged && h2.config.chart.type !== "bar" && (c2 = 0), this.morphSVG(e2, i2, a2, h2.config.chart.type !== "line" || h2.globals.comboCharts ? s2 : "stroke", r2, n2, o2, l2 * c2);
  } }, { key: "showDelayedElements", value: function() {
    this.w.globals.delayedElements.forEach(function(t3) {
      var e2 = t3.el;
      e2.classList.remove("apexcharts-element-hidden"), e2.classList.add("apexcharts-hidden-element-shown");
    });
  } }, { key: "animationCompleted", value: function(t3) {
    var e2 = this.w;
    e2.globals.animationEnded || (e2.globals.animationEnded = true, this.showDelayedElements(), typeof e2.config.chart.events.animationEnd == "function" && e2.config.chart.events.animationEnd(this.ctx, { el: t3, w: e2 }));
  } }, { key: "morphSVG", value: function(t3, e2, i2, a2, s2, r2, n2, o2) {
    var l2 = this, h2 = this.w;
    s2 || (s2 = t3.attr("pathFrom")), r2 || (r2 = t3.attr("pathTo"));
    var c2 = function(t4) {
      return h2.config.chart.type === "radar" && (n2 = 1), "M 0 ".concat(h2.globals.gridHeight);
    };
    (!s2 || s2.indexOf("undefined") > -1 || s2.indexOf("NaN") > -1) && (s2 = c2()), (!r2.trim() || r2.indexOf("undefined") > -1 || r2.indexOf("NaN") > -1) && (r2 = c2()), h2.globals.shouldAnimate || (n2 = 1), t3.plot(s2).animate(1, o2).plot(s2).animate(n2, o2).plot(r2).after(function() {
      v.isNumber(i2) ? i2 === h2.globals.series[h2.globals.maxValsInArrayIndex].length - 2 && h2.globals.shouldAnimate && l2.animationCompleted(t3) : a2 !== "none" && h2.globals.shouldAnimate && (!h2.globals.comboCharts && e2 === h2.globals.series.length - 1 || h2.globals.comboCharts) && l2.animationCompleted(t3), l2.showDelayedElements();
    });
  } }]), t2;
}();
var w = {};
var k = [];
var z = new Set(["desc", "metadata", "title"]);
var X = (t2) => z.has(t2.nodeName);
var R = (t2, e2, i2 = {}) => {
  const a2 = { ...e2 };
  for (const t3 in a2)
    a2[t3].valueOf() === i2[t3] && delete a2[t3];
  Object.keys(a2).length ? t2.node.setAttribute("data-svgjs", JSON.stringify(a2)) : (t2.node.removeAttribute("data-svgjs"), t2.node.removeAttribute("svgjs:data"));
};
var E = "http://www.w3.org/2000/svg";
var Y = "http://www.w3.org/2000/xmlns/";
var H = "http://www.w3.org/1999/xlink";
var O = { window: typeof window == "undefined" ? null : window, document: typeof document == "undefined" ? null : document };
var D = class {
};
var _ = {};
var N = "___SYMBOL___ROOT___";
var U = V;
var Z = 1000;
A("Dom", { siblings: function() {
  return this.parent().children();
}, position: function() {
  return this.parent().index(this);
}, next: function() {
  return this.siblings()[this.position() + 1];
}, prev: function() {
  return this.siblings()[this.position() - 1];
}, forward: function() {
  const t2 = this.position();
  return this.parent().add(this.remove(), t2 + 1), this;
}, backward: function() {
  const t2 = this.position();
  return this.parent().add(this.remove(), t2 ? t2 - 1 : 0), this;
}, front: function() {
  return this.parent().add(this.remove()), this;
}, back: function() {
  return this.parent().add(this.remove(), 0), this;
}, before: function(t2) {
  (t2 = B(t2)).remove();
  const e2 = this.position();
  return this.parent().add(t2, e2), this;
}, after: function(t2) {
  (t2 = B(t2)).remove();
  const e2 = this.position();
  return this.parent().add(t2, e2 + 1), this;
}, insertBefore: function(t2) {
  return (t2 = B(t2)).before(this), this;
}, insertAfter: function(t2) {
  return (t2 = B(t2)).after(this), this;
} });
var tt = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i;
var et = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var it = /rgb\((\d+),(\d+),(\d+)\)/;
var at = /(#[a-z_][a-z0-9\-_]*)/i;
var st = /\)\s*,?\s*/;
var rt = /\s/g;
var nt = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;
var ot = /^rgb\(/;
var lt = /^(\s+)?$/;
var ht = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var ct = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i;
var dt = /[\s,]+/;
var ut = /[MLHVCSQTAZ]/i;
A("Dom", { classes: function() {
  const t2 = this.attr("class");
  return t2 == null ? [] : t2.trim().split(dt);
}, hasClass: function(t2) {
  return this.classes().indexOf(t2) !== -1;
}, addClass: function(t2) {
  if (!this.hasClass(t2)) {
    const e2 = this.classes();
    e2.push(t2), this.attr("class", e2.join(" "));
  }
  return this;
}, removeClass: function(t2) {
  return this.hasClass(t2) && this.attr("class", this.classes().filter(function(e2) {
    return e2 !== t2;
  }).join(" ")), this;
}, toggleClass: function(t2) {
  return this.hasClass(t2) ? this.removeClass(t2) : this.addClass(t2);
} }), A("Dom", { css: function(t2, e2) {
  const i2 = {};
  if (arguments.length === 0)
    return this.node.style.cssText.split(/\s*;\s*/).filter(function(t3) {
      return !!t3.length;
    }).forEach(function(t3) {
      const e3 = t3.split(/\s*:\s*/);
      i2[e3[0]] = e3[1];
    }), i2;
  if (arguments.length < 2) {
    if (Array.isArray(t2)) {
      for (const e3 of t2) {
        const t3 = e3;
        i2[e3] = this.node.style.getPropertyValue(t3);
      }
      return i2;
    }
    if (typeof t2 == "string")
      return this.node.style.getPropertyValue(t2);
    if (typeof t2 == "object")
      for (const e3 in t2)
        this.node.style.setProperty(e3, t2[e3] == null || lt.test(t2[e3]) ? "" : t2[e3]);
  }
  return arguments.length === 2 && this.node.style.setProperty(t2, e2 == null || lt.test(e2) ? "" : e2), this;
}, show: function() {
  return this.css("display", "");
}, hide: function() {
  return this.css("display", "none");
}, visible: function() {
  return this.css("display") !== "none";
} }), A("Dom", { data: function(t2, e2, i2) {
  if (t2 == null)
    return this.data(L(function(t3, e3) {
      let i3;
      const a2 = t3.length, s2 = [];
      for (i3 = 0;i3 < a2; i3++)
        e3(t3[i3]) && s2.push(t3[i3]);
      return s2;
    }(this.node.attributes, (t3) => t3.nodeName.indexOf("data-") === 0), (t3) => t3.nodeName.slice(5)));
  if (t2 instanceof Array) {
    const e3 = {};
    for (const i3 of t2)
      e3[i3] = this.data(i3);
    return e3;
  }
  if (typeof t2 == "object")
    for (e2 in t2)
      this.data(e2, t2[e2]);
  else if (arguments.length < 2)
    try {
      return JSON.parse(this.attr("data-" + t2));
    } catch (e3) {
      return this.attr("data-" + t2);
    }
  else
    this.attr("data-" + t2, e2 === null ? null : i2 === true || typeof e2 == "string" || typeof e2 == "number" ? e2 : JSON.stringify(e2));
  return this;
} }), A("Dom", { remember: function(t2, e2) {
  if (typeof arguments[0] == "object")
    for (const e3 in t2)
      this.remember(e3, t2[e3]);
  else {
    if (arguments.length === 1)
      return this.memory()[t2];
    this.memory()[t2] = e2;
  }
  return this;
}, forget: function() {
  if (arguments.length === 0)
    this._memory = {};
  else
    for (let t2 = arguments.length - 1;t2 >= 0; t2--)
      delete this.memory()[arguments[t2]];
  return this;
}, memory: function() {
  return this._memory = this._memory || {};
} });

class xt {
  constructor(...t2) {
    this.init(...t2);
  }
  static isColor(t2) {
    return t2 && (t2 instanceof xt || this.isRgb(t2) || this.test(t2));
  }
  static isRgb(t2) {
    return t2 && typeof t2.r == "number" && typeof t2.g == "number" && typeof t2.b == "number";
  }
  static random(t2 = "vibrant", e2) {
    const { random: i2, round: a2, sin: s2, PI: r2 } = Math;
    if (t2 === "vibrant") {
      const t3 = 24 * i2() + 57, e3 = 38 * i2() + 45, a3 = 360 * i2();
      return new xt(t3, e3, a3, "lch");
    }
    if (t2 === "sine") {
      const t3 = a2(80 * s2(2 * r2 * (e2 = e2 == null ? i2() : e2) / 0.5 + 0.01) + 150), n2 = a2(50 * s2(2 * r2 * e2 / 0.5 + 4.6) + 200), o2 = a2(100 * s2(2 * r2 * e2 / 0.5 + 2.3) + 150);
      return new xt(t3, n2, o2);
    }
    if (t2 === "pastel") {
      const t3 = 8 * i2() + 86, e3 = 17 * i2() + 9, a3 = 360 * i2();
      return new xt(t3, e3, a3, "lch");
    }
    if (t2 === "dark") {
      const t3 = 10 + 10 * i2(), e3 = 50 * i2() + 86, a3 = 360 * i2();
      return new xt(t3, e3, a3, "lch");
    }
    if (t2 === "rgb") {
      const t3 = 255 * i2(), e3 = 255 * i2(), a3 = 255 * i2();
      return new xt(t3, e3, a3);
    }
    if (t2 === "lab") {
      const t3 = 100 * i2(), e3 = 256 * i2() - 128, a3 = 256 * i2() - 128;
      return new xt(t3, e3, a3, "lab");
    }
    if (t2 === "grey") {
      const t3 = 255 * i2();
      return new xt(t3, t3, t3);
    }
    throw new Error("Unsupported random color mode");
  }
  static test(t2) {
    return typeof t2 == "string" && (nt.test(t2) || ot.test(t2));
  }
  cmyk() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map((t3) => t3 / 255), n2 = Math.min(1 - a2, 1 - s2, 1 - r2);
    if (n2 === 1)
      return new xt(0, 0, 0, 1, "cmyk");
    return new xt((1 - a2 - n2) / (1 - n2), (1 - s2 - n2) / (1 - n2), (1 - r2 - n2) / (1 - n2), n2, "cmyk");
  }
  hsl() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map((t3) => t3 / 255), n2 = Math.max(a2, s2, r2), o2 = Math.min(a2, s2, r2), l2 = (n2 + o2) / 2, h2 = n2 === o2, c2 = n2 - o2;
    return new xt(360 * (h2 ? 0 : n2 === a2 ? ((s2 - r2) / c2 + (s2 < r2 ? 6 : 0)) / 6 : n2 === s2 ? ((r2 - a2) / c2 + 2) / 6 : n2 === r2 ? ((a2 - s2) / c2 + 4) / 6 : 0), 100 * (h2 ? 0 : l2 > 0.5 ? c2 / (2 - n2 - o2) : c2 / (n2 + o2)), 100 * l2, "hsl");
  }
  init(t2 = 0, e2 = 0, i2 = 0, a2 = 0, s2 = "rgb") {
    if (t2 = t2 || 0, this.space)
      for (const t3 in this.space)
        delete this[this.space[t3]];
    if (typeof t2 == "number")
      s2 = typeof a2 == "string" ? a2 : s2, a2 = typeof a2 == "string" ? 0 : a2, Object.assign(this, { _a: t2, _b: e2, _c: i2, _d: a2, space: s2 });
    else if (t2 instanceof Array)
      this.space = e2 || (typeof t2[3] == "string" ? t2[3] : t2[4]) || "rgb", Object.assign(this, { _a: t2[0], _b: t2[1], _c: t2[2], _d: t2[3] || 0 });
    else if (t2 instanceof Object) {
      const i3 = function(t3, e3) {
        const i4 = pt(t3, "rgb") ? { _a: t3.r, _b: t3.g, _c: t3.b, _d: 0, space: "rgb" } : pt(t3, "xyz") ? { _a: t3.x, _b: t3.y, _c: t3.z, _d: 0, space: "xyz" } : pt(t3, "hsl") ? { _a: t3.h, _b: t3.s, _c: t3.l, _d: 0, space: "hsl" } : pt(t3, "lab") ? { _a: t3.l, _b: t3.a, _c: t3.b, _d: 0, space: "lab" } : pt(t3, "lch") ? { _a: t3.l, _b: t3.c, _c: t3.h, _d: 0, space: "lch" } : pt(t3, "cmyk") ? { _a: t3.c, _b: t3.m, _c: t3.y, _d: t3.k, space: "cmyk" } : { _a: 0, _b: 0, _c: 0, space: "rgb" };
        return i4.space = e3 || i4.space, i4;
      }(t2, e2);
      Object.assign(this, i3);
    } else if (typeof t2 == "string")
      if (ot.test(t2)) {
        const e3 = t2.replace(rt, ""), [i3, a3, s3] = it.exec(e3).slice(1, 4).map((t3) => parseInt(t3));
        Object.assign(this, { _a: i3, _b: a3, _c: s3, _d: 0, space: "rgb" });
      } else {
        if (!nt.test(t2))
          throw Error("Unsupported string format, can't construct Color");
        {
          const e3 = (t3) => parseInt(t3, 16), [, i3, a3, s3] = et.exec(function(t3) {
            return t3.length === 4 ? ["#", t3.substring(1, 2), t3.substring(1, 2), t3.substring(2, 3), t3.substring(2, 3), t3.substring(3, 4), t3.substring(3, 4)].join("") : t3;
          }(t2)).map(e3);
          Object.assign(this, { _a: i3, _b: a3, _c: s3, _d: 0, space: "rgb" });
        }
      }
    const { _a: r2, _b: n2, _c: o2, _d: l2 } = this, h2 = this.space === "rgb" ? { r: r2, g: n2, b: o2 } : this.space === "xyz" ? { x: r2, y: n2, z: o2 } : this.space === "hsl" ? { h: r2, s: n2, l: o2 } : this.space === "lab" ? { l: r2, a: n2, b: o2 } : this.space === "lch" ? { l: r2, c: n2, h: o2 } : this.space === "cmyk" ? { c: r2, m: n2, y: o2, k: l2 } : {};
    Object.assign(this, h2);
  }
  lab() {
    const { x: t2, y: e2, z: i2 } = this.xyz();
    return new xt(116 * e2 - 16, 500 * (t2 - e2), 200 * (e2 - i2), "lab");
  }
  lch() {
    const { l: t2, a: e2, b: i2 } = this.lab(), a2 = Math.sqrt(e2 ** 2 + i2 ** 2);
    let s2 = 180 * Math.atan2(i2, e2) / Math.PI;
    s2 < 0 && (s2 *= -1, s2 = 360 - s2);
    return new xt(t2, a2, s2, "lch");
  }
  rgb() {
    if (this.space === "rgb")
      return this;
    if ((t2 = this.space) === "lab" || t2 === "xyz" || t2 === "lch") {
      let { x: t3, y: e2, z: i2 } = this;
      if (this.space === "lab" || this.space === "lch") {
        let { l: a3, a: s3, b: r3 } = this;
        if (this.space === "lch") {
          const { c: t4, h: e3 } = this, i3 = Math.PI / 180;
          s3 = t4 * Math.cos(i3 * e3), r3 = t4 * Math.sin(i3 * e3);
        }
        const n3 = (a3 + 16) / 116, o3 = s3 / 500 + n3, l3 = n3 - r3 / 200, h3 = 16 / 116, c3 = 0.008856, d2 = 7.787;
        t3 = 0.95047 * (o3 ** 3 > c3 ? o3 ** 3 : (o3 - h3) / d2), e2 = 1 * (n3 ** 3 > c3 ? n3 ** 3 : (n3 - h3) / d2), i2 = 1.08883 * (l3 ** 3 > c3 ? l3 ** 3 : (l3 - h3) / d2);
      }
      const a2 = 3.2406 * t3 + -1.5372 * e2 + -0.4986 * i2, s2 = -0.9689 * t3 + 1.8758 * e2 + 0.0415 * i2, r2 = 0.0557 * t3 + -0.204 * e2 + 1.057 * i2, n2 = Math.pow, o2 = 0.0031308, l2 = a2 > o2 ? 1.055 * n2(a2, 1 / 2.4) - 0.055 : 12.92 * a2, h2 = s2 > o2 ? 1.055 * n2(s2, 1 / 2.4) - 0.055 : 12.92 * s2, c2 = r2 > o2 ? 1.055 * n2(r2, 1 / 2.4) - 0.055 : 12.92 * r2;
      return new xt(255 * l2, 255 * h2, 255 * c2);
    }
    if (this.space === "hsl") {
      let { h: t3, s: e2, l: i2 } = this;
      if (t3 /= 360, e2 /= 100, i2 /= 100, e2 === 0) {
        i2 *= 255;
        return new xt(i2, i2, i2);
      }
      const a2 = i2 < 0.5 ? i2 * (1 + e2) : i2 + e2 - i2 * e2, s2 = 2 * i2 - a2, r2 = 255 * ft(s2, a2, t3 + 1 / 3), n2 = 255 * ft(s2, a2, t3), o2 = 255 * ft(s2, a2, t3 - 1 / 3);
      return new xt(r2, n2, o2);
    }
    if (this.space === "cmyk") {
      const { c: t3, m: e2, y: i2, k: a2 } = this, s2 = 255 * (1 - Math.min(1, t3 * (1 - a2) + a2)), r2 = 255 * (1 - Math.min(1, e2 * (1 - a2) + a2)), n2 = 255 * (1 - Math.min(1, i2 * (1 - a2) + a2));
      return new xt(s2, r2, n2);
    }
    return this;
    var t2;
  }
  toArray() {
    const { _a: t2, _b: e2, _c: i2, _d: a2, space: s2 } = this;
    return [t2, e2, i2, a2, s2];
  }
  toHex() {
    const [t2, e2, i2] = this._clamped().map(gt);
    return `#${t2}${e2}${i2}`;
  }
  toRgb() {
    const [t2, e2, i2] = this._clamped();
    return `rgb(${t2},${e2},${i2})`;
  }
  toString() {
    return this.toHex();
  }
  xyz() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map((t3) => t3 / 255), n2 = a2 > 0.04045 ? Math.pow((a2 + 0.055) / 1.055, 2.4) : a2 / 12.92, o2 = s2 > 0.04045 ? Math.pow((s2 + 0.055) / 1.055, 2.4) : s2 / 12.92, l2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92, h2 = (0.4124 * n2 + 0.3576 * o2 + 0.1805 * l2) / 0.95047, c2 = (0.2126 * n2 + 0.7152 * o2 + 0.0722 * l2) / 1, d2 = (0.0193 * n2 + 0.1192 * o2 + 0.9505 * l2) / 1.08883, u2 = h2 > 0.008856 ? Math.pow(h2, 1 / 3) : 7.787 * h2 + 16 / 116, g2 = c2 > 0.008856 ? Math.pow(c2, 1 / 3) : 7.787 * c2 + 16 / 116, p2 = d2 > 0.008856 ? Math.pow(d2, 1 / 3) : 7.787 * d2 + 16 / 116;
    return new xt(u2, g2, p2, "xyz");
  }
  _clamped() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), { max: a2, min: s2, round: r2 } = Math;
    return [t2, e2, i2].map((t3) => a2(0, s2(r2(t3), 255)));
  }
}

class bt {
  constructor(...t2) {
    this.init(...t2);
  }
  clone() {
    return new bt(this);
  }
  init(t2, e2) {
    const i2 = 0, a2 = 0, s2 = Array.isArray(t2) ? { x: t2[0], y: t2[1] } : typeof t2 == "object" ? { x: t2.x, y: t2.y } : { x: t2, y: e2 };
    return this.x = s2.x == null ? i2 : s2.x, this.y = s2.y == null ? a2 : s2.y, this;
  }
  toArray() {
    return [this.x, this.y];
  }
  transform(t2) {
    return this.clone().transformO(t2);
  }
  transformO(t2) {
    vt.isMatrixLike(t2) || (t2 = new vt(t2));
    const { x: e2, y: i2 } = this;
    return this.x = t2.a * e2 + t2.c * i2 + t2.e, this.y = t2.b * e2 + t2.d * i2 + t2.f, this;
  }
}

class vt {
  constructor(...t2) {
    this.init(...t2);
  }
  static formatTransforms(t2) {
    const e2 = t2.flip === "both" || t2.flip === true, i2 = t2.flip && (e2 || t2.flip === "x") ? -1 : 1, a2 = t2.flip && (e2 || t2.flip === "y") ? -1 : 1, s2 = t2.skew && t2.skew.length ? t2.skew[0] : isFinite(t2.skew) ? t2.skew : isFinite(t2.skewX) ? t2.skewX : 0, r2 = t2.skew && t2.skew.length ? t2.skew[1] : isFinite(t2.skew) ? t2.skew : isFinite(t2.skewY) ? t2.skewY : 0, n2 = t2.scale && t2.scale.length ? t2.scale[0] * i2 : isFinite(t2.scale) ? t2.scale * i2 : isFinite(t2.scaleX) ? t2.scaleX * i2 : i2, o2 = t2.scale && t2.scale.length ? t2.scale[1] * a2 : isFinite(t2.scale) ? t2.scale * a2 : isFinite(t2.scaleY) ? t2.scaleY * a2 : a2, l2 = t2.shear || 0, h2 = t2.rotate || t2.theta || 0, c2 = new bt(t2.origin || t2.around || t2.ox || t2.originX, t2.oy || t2.originY), d2 = c2.x, u2 = c2.y, g2 = new bt(t2.position || t2.px || t2.positionX || NaN, t2.py || t2.positionY || NaN), p2 = g2.x, f2 = g2.y, x2 = new bt(t2.translate || t2.tx || t2.translateX, t2.ty || t2.translateY), b2 = x2.x, m2 = x2.y, v2 = new bt(t2.relative || t2.rx || t2.relativeX, t2.ry || t2.relativeY);
    return { scaleX: n2, scaleY: o2, skewX: s2, skewY: r2, shear: l2, theta: h2, rx: v2.x, ry: v2.y, tx: b2, ty: m2, ox: d2, oy: u2, px: p2, py: f2 };
  }
  static fromArray(t2) {
    return { a: t2[0], b: t2[1], c: t2[2], d: t2[3], e: t2[4], f: t2[5] };
  }
  static isMatrixLike(t2) {
    return t2.a != null || t2.b != null || t2.c != null || t2.d != null || t2.e != null || t2.f != null;
  }
  static matrixMultiply(t2, e2, i2) {
    const a2 = t2.a * e2.a + t2.c * e2.b, s2 = t2.b * e2.a + t2.d * e2.b, r2 = t2.a * e2.c + t2.c * e2.d, n2 = t2.b * e2.c + t2.d * e2.d, o2 = t2.e + t2.a * e2.e + t2.c * e2.f, l2 = t2.f + t2.b * e2.e + t2.d * e2.f;
    return i2.a = a2, i2.b = s2, i2.c = r2, i2.d = n2, i2.e = o2, i2.f = l2, i2;
  }
  around(t2, e2, i2) {
    return this.clone().aroundO(t2, e2, i2);
  }
  aroundO(t2, e2, i2) {
    const a2 = t2 || 0, s2 = e2 || 0;
    return this.translateO(-a2, -s2).lmultiplyO(i2).translateO(a2, s2);
  }
  clone() {
    return new vt(this);
  }
  decompose(t2 = 0, e2 = 0) {
    const i2 = this.a, a2 = this.b, s2 = this.c, r2 = this.d, n2 = this.e, o2 = this.f, l2 = i2 * r2 - a2 * s2, h2 = l2 > 0 ? 1 : -1, c2 = h2 * Math.sqrt(i2 * i2 + a2 * a2), d2 = Math.atan2(h2 * a2, h2 * i2), u2 = 180 / Math.PI * d2, g2 = Math.cos(d2), p2 = Math.sin(d2), f2 = (i2 * s2 + a2 * r2) / l2, x2 = s2 * c2 / (f2 * i2 - a2) || r2 * c2 / (f2 * a2 + i2);
    return { scaleX: c2, scaleY: x2, shear: f2, rotate: u2, translateX: n2 - t2 + t2 * g2 * c2 + e2 * (f2 * g2 * c2 - p2 * x2), translateY: o2 - e2 + t2 * p2 * c2 + e2 * (f2 * p2 * c2 + g2 * x2), originX: t2, originY: e2, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
  equals(t2) {
    if (t2 === this)
      return true;
    const e2 = new vt(t2);
    return mt(this.a, e2.a) && mt(this.b, e2.b) && mt(this.c, e2.c) && mt(this.d, e2.d) && mt(this.e, e2.e) && mt(this.f, e2.f);
  }
  flip(t2, e2) {
    return this.clone().flipO(t2, e2);
  }
  flipO(t2, e2) {
    return t2 === "x" ? this.scaleO(-1, 1, e2, 0) : t2 === "y" ? this.scaleO(1, -1, 0, e2) : this.scaleO(-1, -1, t2, e2 || t2);
  }
  init(t2) {
    const e2 = vt.fromArray([1, 0, 0, 1, 0, 0]);
    return t2 = t2 instanceof Gt ? t2.matrixify() : typeof t2 == "string" ? vt.fromArray(t2.split(dt).map(parseFloat)) : Array.isArray(t2) ? vt.fromArray(t2) : typeof t2 == "object" && vt.isMatrixLike(t2) ? t2 : typeof t2 == "object" ? new vt().transform(t2) : arguments.length === 6 ? vt.fromArray([].slice.call(arguments)) : e2, this.a = t2.a != null ? t2.a : e2.a, this.b = t2.b != null ? t2.b : e2.b, this.c = t2.c != null ? t2.c : e2.c, this.d = t2.d != null ? t2.d : e2.d, this.e = t2.e != null ? t2.e : e2.e, this.f = t2.f != null ? t2.f : e2.f, this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  inverseO() {
    const t2 = this.a, e2 = this.b, i2 = this.c, a2 = this.d, s2 = this.e, r2 = this.f, n2 = t2 * a2 - e2 * i2;
    if (!n2)
      throw new Error("Cannot invert " + this);
    const o2 = a2 / n2, l2 = -e2 / n2, h2 = -i2 / n2, c2 = t2 / n2, d2 = -(o2 * s2 + h2 * r2), u2 = -(l2 * s2 + c2 * r2);
    return this.a = o2, this.b = l2, this.c = h2, this.d = c2, this.e = d2, this.f = u2, this;
  }
  lmultiply(t2) {
    return this.clone().lmultiplyO(t2);
  }
  lmultiplyO(t2) {
    const e2 = t2 instanceof vt ? t2 : new vt(t2);
    return vt.matrixMultiply(e2, this, this);
  }
  multiply(t2) {
    return this.clone().multiplyO(t2);
  }
  multiplyO(t2) {
    const e2 = t2 instanceof vt ? t2 : new vt(t2);
    return vt.matrixMultiply(this, e2, this);
  }
  rotate(t2, e2, i2) {
    return this.clone().rotateO(t2, e2, i2);
  }
  rotateO(t2, e2 = 0, i2 = 0) {
    t2 = M(t2);
    const a2 = Math.cos(t2), s2 = Math.sin(t2), { a: r2, b: n2, c: o2, d: l2, e: h2, f: c2 } = this;
    return this.a = r2 * a2 - n2 * s2, this.b = n2 * a2 + r2 * s2, this.c = o2 * a2 - l2 * s2, this.d = l2 * a2 + o2 * s2, this.e = h2 * a2 - c2 * s2 + i2 * s2 - e2 * a2 + e2, this.f = c2 * a2 + h2 * s2 - e2 * s2 - i2 * a2 + i2, this;
  }
  scale() {
    return this.clone().scaleO(...arguments);
  }
  scaleO(t2, e2 = t2, i2 = 0, a2 = 0) {
    arguments.length === 3 && (a2 = i2, i2 = e2, e2 = t2);
    const { a: s2, b: r2, c: n2, d: o2, e: l2, f: h2 } = this;
    return this.a = s2 * t2, this.b = r2 * e2, this.c = n2 * t2, this.d = o2 * e2, this.e = l2 * t2 - i2 * t2 + i2, this.f = h2 * e2 - a2 * e2 + a2, this;
  }
  shear(t2, e2, i2) {
    return this.clone().shearO(t2, e2, i2);
  }
  shearO(t2, e2 = 0, i2 = 0) {
    const { a: a2, b: s2, c: r2, d: n2, e: o2, f: l2 } = this;
    return this.a = a2 + s2 * t2, this.c = r2 + n2 * t2, this.e = o2 + l2 * t2 - i2 * t2, this;
  }
  skew() {
    return this.clone().skewO(...arguments);
  }
  skewO(t2, e2 = t2, i2 = 0, a2 = 0) {
    arguments.length === 3 && (a2 = i2, i2 = e2, e2 = t2), t2 = M(t2), e2 = M(e2);
    const s2 = Math.tan(t2), r2 = Math.tan(e2), { a: n2, b: o2, c: l2, d: h2, e: c2, f: d2 } = this;
    return this.a = n2 + o2 * s2, this.b = o2 + n2 * r2, this.c = l2 + h2 * s2, this.d = h2 + l2 * r2, this.e = c2 + d2 * s2 - a2 * s2, this.f = d2 + c2 * r2 - i2 * r2, this;
  }
  skewX(t2, e2, i2) {
    return this.skew(t2, 0, e2, i2);
  }
  skewY(t2, e2, i2) {
    return this.skew(0, t2, e2, i2);
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  toString() {
    return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
  }
  transform(t2) {
    if (vt.isMatrixLike(t2)) {
      return new vt(t2).multiplyO(this);
    }
    const e2 = vt.formatTransforms(t2), { x: i2, y: a2 } = new bt(e2.ox, e2.oy).transform(this), s2 = new vt().translateO(e2.rx, e2.ry).lmultiplyO(this).translateO(-i2, -a2).scaleO(e2.scaleX, e2.scaleY).skewO(e2.skewX, e2.skewY).shearO(e2.shear).rotateO(e2.theta).translateO(i2, a2);
    if (isFinite(e2.px) || isFinite(e2.py)) {
      const t3 = new bt(i2, a2).transform(s2), r2 = isFinite(e2.px) ? e2.px - t3.x : 0, n2 = isFinite(e2.py) ? e2.py - t3.y : 0;
      s2.translateO(r2, n2);
    }
    return s2.translateO(e2.tx, e2.ty), s2;
  }
  translate(t2, e2) {
    return this.clone().translateO(t2, e2);
  }
  translateO(t2, e2) {
    return this.e += t2 || 0, this.f += e2 || 0, this;
  }
  valueOf() {
    return { a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
}
q(vt, "Matrix");

class kt {
  constructor(...t2) {
    this.init(...t2);
  }
  addOffset() {
    return this.x += O.window.pageXOffset, this.y += O.window.pageYOffset, new kt(this);
  }
  init(t2) {
    return t2 = typeof t2 == "string" ? t2.split(dt).map(parseFloat) : Array.isArray(t2) ? t2 : typeof t2 == "object" ? [t2.left != null ? t2.left : t2.x, t2.top != null ? t2.top : t2.y, t2.width, t2.height] : arguments.length === 4 ? [].slice.call(arguments) : [0, 0, 0, 0], this.x = t2[0] || 0, this.y = t2[1] || 0, this.width = this.w = t2[2] || 0, this.height = this.h = t2[3] || 0, this.x2 = this.x + this.w, this.y2 = this.y + this.h, this.cx = this.x + this.w / 2, this.cy = this.y + this.h / 2, this;
  }
  isNulled() {
    return wt(this);
  }
  merge(t2) {
    const e2 = Math.min(this.x, t2.x), i2 = Math.min(this.y, t2.y), a2 = Math.max(this.x + this.width, t2.x + t2.width) - e2, s2 = Math.max(this.y + this.height, t2.y + t2.height) - i2;
    return new kt(e2, i2, a2, s2);
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  toString() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }
  transform(t2) {
    t2 instanceof vt || (t2 = new vt(t2));
    let e2 = 1 / 0, i2 = -1 / 0, a2 = 1 / 0, s2 = -1 / 0;
    return [new bt(this.x, this.y), new bt(this.x2, this.y), new bt(this.x, this.y2), new bt(this.x2, this.y2)].forEach(function(r2) {
      r2 = r2.transform(t2), e2 = Math.min(e2, r2.x), i2 = Math.max(i2, r2.x), a2 = Math.min(a2, r2.y), s2 = Math.max(s2, r2.y);
    }), new kt(e2, a2, i2 - e2, s2 - a2);
  }
}
A({ viewbox: { viewbox(t2, e2, i2, a2) {
  return t2 == null ? new kt(this.attr("viewBox")) : this.attr("viewBox", new kt(t2, e2, i2, a2));
}, zoom(t2, e2) {
  let { width: i2, height: a2 } = this.attr(["width", "height"]);
  if ((i2 || a2) && typeof i2 != "string" && typeof a2 != "string" || (i2 = this.node.clientWidth, a2 = this.node.clientHeight), !i2 || !a2)
    throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");
  const s2 = this.viewbox(), r2 = i2 / s2.width, n2 = a2 / s2.height, o2 = Math.min(r2, n2);
  if (t2 == null)
    return o2;
  let l2 = o2 / t2;
  l2 === 1 / 0 && (l2 = Number.MAX_SAFE_INTEGER / 100), e2 = e2 || new bt(i2 / 2 / r2 + s2.x, a2 / 2 / n2 + s2.y);
  const h2 = new kt(s2).transform(new vt({ scale: l2, origin: e2 }));
  return this.viewbox(h2);
} } }), q(kt, "Box");

class Ct extends Array {
  constructor(t2 = [], ...e2) {
    if (super(t2, ...e2), typeof t2 == "number")
      return this;
    this.length = 0, this.push(...t2);
  }
}
Q([Ct], { each(t2, ...e2) {
  return typeof t2 == "function" ? this.map((e3, i2, a2) => t2.call(e3, e3, i2, a2)) : this.map((i2) => i2[t2](...e2));
}, toArray() {
  return Array.prototype.concat.apply([], this);
} });
var St = ["toArray", "constructor", "each"];
Ct.extend = function(t2) {
  t2 = t2.reduce((t3, e2) => (St.includes(e2) || e2[0] === "_" || ((e2 in Array.prototype) && (t3["$" + e2] = Array.prototype[e2]), t3[e2] = function(...t4) {
    return this.each(e2, ...t4);
  }), t3), {}), Q([Ct], t2);
};
var Mt = 0;
var Pt = {};

class Rt extends D {
  addEventListener() {
  }
  dispatch(t2, e2, i2) {
    return function(t3, e3, i3, a2) {
      const s2 = Tt(t3);
      return e3 instanceof O.window.Event || (e3 = new O.window.CustomEvent(e3, { detail: i3, cancelable: true, ...a2 })), s2.dispatchEvent(e3), e3;
    }(this, t2, e2, i2);
  }
  dispatchEvent(t2) {
    const e2 = this.getEventHolder().events;
    if (!e2)
      return true;
    const i2 = e2[t2.type];
    for (const e3 in i2)
      for (const a2 in i2[e3])
        i2[e3][a2](t2);
    return !t2.defaultPrevented;
  }
  fire(t2, e2, i2) {
    return this.dispatch(t2, e2, i2), this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  off(t2, e2, i2) {
    return Xt(this, t2, e2, i2), this;
  }
  on(t2, e2, i2, a2) {
    return zt(this, t2, e2, i2, a2), this;
  }
  removeEventListener() {
  }
}
q(Rt, "EventTarget");
var Yt = 400;
var Ht = ">";
var Ot = 0;
var Ft = { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "text-anchor": "start" };

class Dt extends Array {
  constructor(...t2) {
    super(...t2), this.init(...t2);
  }
  clone() {
    return new this.constructor(this);
  }
  init(t2) {
    return typeof t2 == "number" || (this.length = 0, this.push(...this.parse(t2))), this;
  }
  parse(t2 = []) {
    return t2 instanceof Array ? t2 : t2.trim().split(dt).map(parseFloat);
  }
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
  toSet() {
    return new Set(this);
  }
  toString() {
    return this.join(" ");
  }
  valueOf() {
    const t2 = [];
    return t2.push(...this), t2;
  }
}

class _t {
  constructor(...t2) {
    this.init(...t2);
  }
  convert(t2) {
    return new _t(this.value, t2);
  }
  divide(t2) {
    return t2 = new _t(t2), new _t(this / t2, this.unit || t2.unit);
  }
  init(t2, e2) {
    return e2 = Array.isArray(t2) ? t2[1] : e2, t2 = Array.isArray(t2) ? t2[0] : t2, this.value = 0, this.unit = e2 || "", typeof t2 == "number" ? this.value = isNaN(t2) ? 0 : isFinite(t2) ? t2 : t2 < 0 ? -340000000000000000000000000000000000000 : 340000000000000000000000000000000000000 : typeof t2 == "string" ? (e2 = t2.match(tt)) && (this.value = parseFloat(e2[1]), e2[5] === "%" ? this.value /= 100 : e2[5] === "s" && (this.value *= 1000), this.unit = e2[5]) : t2 instanceof _t && (this.value = t2.valueOf(), this.unit = t2.unit), this;
  }
  minus(t2) {
    return t2 = new _t(t2), new _t(this - t2, this.unit || t2.unit);
  }
  plus(t2) {
    return t2 = new _t(t2), new _t(this + t2, this.unit || t2.unit);
  }
  times(t2) {
    return t2 = new _t(t2), new _t(this * t2, this.unit || t2.unit);
  }
  toArray() {
    return [this.value, this.unit];
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return (this.unit === "%" ? ~~(1e8 * this.value) / 1e6 : this.unit === "s" ? this.value / 1000 : this.value) + this.unit;
  }
  valueOf() {
    return this.value;
  }
}
var Nt = new Set(["fill", "stroke", "color", "bgcolor", "stop-color", "flood-color", "lighting-color"]);
var Wt = [];

class Bt extends Rt {
  constructor(t2, e2) {
    super(), this.node = t2, this.type = t2.nodeName, e2 && t2 !== e2 && this.attr(e2);
  }
  add(t2, e2) {
    return (t2 = B(t2)).removeNamespace && this.node instanceof O.window.SVGElement && t2.removeNamespace(), e2 == null ? this.node.appendChild(t2.node) : t2.node !== this.node.childNodes[e2] && this.node.insertBefore(t2.node, this.node.childNodes[e2]), this;
  }
  addTo(t2, e2) {
    return B(t2).put(this, e2);
  }
  children() {
    return new Ct(L(this.node.children, function(t2) {
      return V(t2);
    }));
  }
  clear() {
    for (;this.node.hasChildNodes(); )
      this.node.removeChild(this.node.lastChild);
    return this;
  }
  clone(t2 = true, e2 = true) {
    this.writeDataToDom();
    let i2 = this.node.cloneNode(t2);
    return e2 && (i2 = J(i2)), new this.constructor(i2);
  }
  each(t2, e2) {
    const i2 = this.children();
    let a2, s2;
    for (a2 = 0, s2 = i2.length;a2 < s2; a2++)
      t2.apply(i2[a2], [a2, i2]), e2 && i2[a2].each(t2, e2);
    return this;
  }
  element(t2, e2) {
    return this.put(new Bt(W(t2), e2));
  }
  first() {
    return V(this.node.firstChild);
  }
  get(t2) {
    return V(this.node.childNodes[t2]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  has(t2) {
    return this.index(t2) >= 0;
  }
  html(t2, e2) {
    return this.xml(t2, e2, "http://www.w3.org/1999/xhtml");
  }
  id(t2) {
    return t2 !== undefined || this.node.id || (this.node.id = $(this.type)), this.attr("id", t2);
  }
  index(t2) {
    return [].slice.call(this.node.childNodes).indexOf(t2.node);
  }
  last() {
    return V(this.node.lastChild);
  }
  matches(t2) {
    const e2 = this.node, i2 = e2.matches || e2.matchesSelector || e2.msMatchesSelector || e2.mozMatchesSelector || e2.webkitMatchesSelector || e2.oMatchesSelector || null;
    return i2 && i2.call(e2, t2);
  }
  parent(t2) {
    let e2 = this;
    if (!e2.node.parentNode)
      return null;
    if (e2 = V(e2.node.parentNode), !t2)
      return e2;
    do {
      if (typeof t2 == "string" ? e2.matches(t2) : e2 instanceof t2)
        return e2;
    } while (e2 = V(e2.node.parentNode));
    return e2;
  }
  put(t2, e2) {
    return t2 = B(t2), this.add(t2, e2), t2;
  }
  putIn(t2, e2) {
    return B(t2).add(this, e2);
  }
  remove() {
    return this.parent() && this.parent().removeElement(this), this;
  }
  removeElement(t2) {
    return this.node.removeChild(t2.node), this;
  }
  replace(t2) {
    return t2 = B(t2), this.node.parentNode && this.node.parentNode.replaceChild(t2.node, this.node), t2;
  }
  round(t2 = 2, e2 = null) {
    const i2 = 10 ** t2, a2 = this.attr(e2);
    for (const t3 in a2)
      typeof a2[t3] == "number" && (a2[t3] = Math.round(a2[t3] * i2) / i2);
    return this.attr(a2), this;
  }
  svg(t2, e2) {
    return this.xml(t2, e2, E);
  }
  toString() {
    return this.id();
  }
  words(t2) {
    return this.node.textContent = t2, this;
  }
  wrap(t2) {
    const e2 = this.parent();
    if (!e2)
      return this.addTo(t2);
    const i2 = e2.index(this);
    return e2.put(t2, i2).put(this);
  }
  writeDataToDom() {
    return this.each(function() {
      this.writeDataToDom();
    }), this;
  }
  xml(t2, e2, i2) {
    if (typeof t2 == "boolean" && (i2 = e2, e2 = t2, t2 = null), t2 == null || typeof t2 == "function") {
      e2 = e2 == null || e2, this.writeDataToDom();
      let i3 = this;
      if (t2 != null) {
        if (i3 = V(i3.node.cloneNode(true)), e2) {
          const e3 = t2(i3);
          if (i3 = e3 || i3, e3 === false)
            return "";
        }
        i3.each(function() {
          const e3 = t2(this), i4 = e3 || this;
          e3 === false ? this.remove() : e3 && this !== i4 && this.replace(i4);
        }, true);
      }
      return e2 ? i3.node.outerHTML : i3.node.innerHTML;
    }
    e2 = e2 != null && e2;
    const a2 = W("wrapper", i2), s2 = O.document.createDocumentFragment();
    a2.innerHTML = t2;
    for (let t3 = a2.children.length;t3--; )
      s2.appendChild(a2.firstElementChild);
    const r2 = this.parent();
    return e2 ? this.replace(s2) && r2 : this.add(s2);
  }
}
Q(Bt, { attr: function(t2, e2, i2) {
  if (t2 == null) {
    t2 = {}, e2 = this.node.attributes;
    for (const i3 of e2)
      t2[i3.nodeName] = ht.test(i3.nodeValue) ? parseFloat(i3.nodeValue) : i3.nodeValue;
    return t2;
  }
  if (t2 instanceof Array)
    return t2.reduce((t3, e3) => (t3[e3] = this.attr(e3), t3), {});
  if (typeof t2 == "object" && t2.constructor === Object)
    for (e2 in t2)
      this.attr(e2, t2[e2]);
  else if (e2 === null)
    this.node.removeAttribute(t2);
  else {
    if (e2 == null)
      return (e2 = this.node.getAttribute(t2)) == null ? Ft[t2] : ht.test(e2) ? parseFloat(e2) : e2;
    typeof (e2 = Wt.reduce((e3, i3) => i3(t2, e3, this), e2)) == "number" ? e2 = new _t(e2) : Nt.has(t2) && xt.isColor(e2) ? e2 = new xt(e2) : e2.constructor === Array && (e2 = new Dt(e2)), t2 === "leading" ? this.leading && this.leading(e2) : typeof i2 == "string" ? this.node.setAttributeNS(i2, t2, e2.toString()) : this.node.setAttribute(t2, e2.toString()), !this.rebuild || t2 !== "font-size" && t2 !== "x" || this.rebuild();
  }
  return this;
}, find: function(t2) {
  return Lt(t2, this.node);
}, findOne: function(t2) {
  return V(this.node.querySelector(t2));
} }), q(Bt, "Dom");
var Gt = class extends Bt {
  constructor(t2, e2) {
    super(t2, e2), this.dom = {}, this.node.instance = this, (t2.hasAttribute("data-svgjs") || t2.hasAttribute("svgjs:data")) && this.setData(JSON.parse(t2.getAttribute("data-svgjs")) ?? JSON.parse(t2.getAttribute("svgjs:data")) ?? {});
  }
  center(t2, e2) {
    return this.cx(t2).cy(e2);
  }
  cx(t2) {
    return t2 == null ? this.x() + this.width() / 2 : this.x(t2 - this.width() / 2);
  }
  cy(t2) {
    return t2 == null ? this.y() + this.height() / 2 : this.y(t2 - this.height() / 2);
  }
  defs() {
    const t2 = this.root();
    return t2 && t2.defs();
  }
  dmove(t2, e2) {
    return this.dx(t2).dy(e2);
  }
  dx(t2 = 0) {
    return this.x(new _t(t2).plus(this.x()));
  }
  dy(t2 = 0) {
    return this.y(new _t(t2).plus(this.y()));
  }
  getEventHolder() {
    return this;
  }
  height(t2) {
    return this.attr("height", t2);
  }
  move(t2, e2) {
    return this.x(t2).y(e2);
  }
  parents(t2 = this.root()) {
    const e2 = typeof t2 == "string";
    e2 || (t2 = B(t2));
    const i2 = new Ct;
    let a2 = this;
    for (;(a2 = a2.parent()) && a2.node !== O.document && a2.nodeName !== "#document-fragment" && (i2.push(a2), e2 || a2.node !== t2.node) && (!e2 || !a2.matches(t2)); )
      if (a2.node === this.root().node)
        return null;
    return i2;
  }
  reference(t2) {
    if (!(t2 = this.attr(t2)))
      return null;
    const e2 = (t2 + "").match(at);
    return e2 ? B(e2[1]) : null;
  }
  root() {
    const t2 = this.parent(function(t3) {
      return _[t3];
    }(N));
    return t2 && t2.root();
  }
  setData(t2) {
    return this.dom = t2, this;
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.width(new _t(i2.width)).height(new _t(i2.height));
  }
  width(t2) {
    return this.attr("width", t2);
  }
  writeDataToDom() {
    return R(this, this.dom), super.writeDataToDom();
  }
  x(t2) {
    return this.attr("x", t2);
  }
  y(t2) {
    return this.attr("y", t2);
  }
};
Q(Gt, { bbox: function() {
  const t2 = At(this, (t3) => t3.getBBox(), (t3) => {
    try {
      const e2 = t3.clone().addTo(yt().svg).show(), i2 = e2.node.getBBox();
      return e2.remove(), i2;
    } catch (e2) {
      throw new Error(`Getting bbox of element "${t3.node.nodeName}" is not possible: ${e2.toString()}`);
    }
  });
  return new kt(t2);
}, rbox: function(t2) {
  const e2 = At(this, (t3) => t3.getBoundingClientRect(), (t3) => {
    throw new Error(`Getting rbox of element "${t3.node.nodeName}" is not possible`);
  }), i2 = new kt(e2);
  return t2 ? i2.transform(t2.screenCTM().inverseO()) : i2.addOffset();
}, inside: function(t2, e2) {
  const i2 = this.bbox();
  return t2 > i2.x && e2 > i2.y && t2 < i2.x + i2.width && e2 < i2.y + i2.height;
}, point: function(t2, e2) {
  return new bt(t2, e2).transformO(this.screenCTM().inverseO());
}, ctm: function() {
  return new vt(this.node.getCTM());
}, screenCTM: function() {
  try {
    if (typeof this.isRoot == "function" && !this.isRoot()) {
      const t2 = this.rect(1, 1), e2 = t2.node.getScreenCTM();
      return t2.remove(), new vt(e2);
    }
    return new vt(this.node.getScreenCTM());
  } catch (t2) {
    return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`), new vt;
  }
} }), q(Gt, "Element");
var jt = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t2, e2) {
  return e2 === "color" ? t2 : t2 + "-" + e2;
} };
["fill", "stroke"].forEach(function(t2) {
  const e2 = {};
  let i2;
  e2[t2] = function(e3) {
    if (e3 === undefined)
      return this.attr(t2);
    if (typeof e3 == "string" || e3 instanceof xt || xt.isRgb(e3) || e3 instanceof Gt)
      this.attr(t2, e3);
    else
      for (i2 = jt[t2].length - 1;i2 >= 0; i2--)
        e3[jt[t2][i2]] != null && this.attr(jt.prefix(t2, jt[t2][i2]), e3[jt[t2][i2]]);
    return this;
  }, A(["Element", "Runner"], e2);
}), A(["Element", "Runner"], { matrix: function(t2, e2, i2, a2, s2, r2) {
  return t2 == null ? new vt(this) : this.attr("transform", new vt(t2, e2, i2, a2, s2, r2));
}, rotate: function(t2, e2, i2) {
  return this.transform({ rotate: t2, ox: e2, oy: i2 }, true);
}, skew: function(t2, e2, i2, a2) {
  return arguments.length === 1 || arguments.length === 3 ? this.transform({ skew: t2, ox: e2, oy: i2 }, true) : this.transform({ skew: [t2, e2], ox: i2, oy: a2 }, true);
}, shear: function(t2, e2, i2) {
  return this.transform({ shear: t2, ox: e2, oy: i2 }, true);
}, scale: function(t2, e2, i2, a2) {
  return arguments.length === 1 || arguments.length === 3 ? this.transform({ scale: t2, ox: e2, oy: i2 }, true) : this.transform({ scale: [t2, e2], ox: i2, oy: a2 }, true);
}, translate: function(t2, e2) {
  return this.transform({ translate: [t2, e2] }, true);
}, relative: function(t2, e2) {
  return this.transform({ relative: [t2, e2] }, true);
}, flip: function(t2 = "both", e2 = "center") {
  return "xybothtrue".indexOf(t2) === -1 && (e2 = t2, t2 = "both"), this.transform({ flip: t2, origin: e2 }, true);
}, opacity: function(t2) {
  return this.attr("opacity", t2);
} }), A("radius", { radius: function(t2, e2 = t2) {
  return (this._element || this).type === "radialGradient" ? this.attr("r", new _t(t2)) : this.rx(t2).ry(e2);
} }), A("Path", { length: function() {
  return this.node.getTotalLength();
}, pointAt: function(t2) {
  return new bt(this.node.getPointAtLength(t2));
} }), A(["Element", "Runner"], { font: function(t2, e2) {
  if (typeof t2 == "object") {
    for (e2 in t2)
      this.font(e2, t2[e2]);
    return this;
  }
  return t2 === "leading" ? this.leading(e2) : t2 === "anchor" ? this.attr("text-anchor", e2) : t2 === "size" || t2 === "family" || t2 === "weight" || t2 === "stretch" || t2 === "variant" || t2 === "style" ? this.attr("font-" + t2, e2) : this.attr(t2, e2);
} });
A("Element", ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel", "contextmenu", "wheel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel"].reduce(function(t2, e2) {
  return t2[e2] = function(t3) {
    return t3 === null ? this.off(e2) : this.on(e2, t3), this;
  }, t2;
}, {})), A("Element", { untransform: function() {
  return this.attr("transform", null);
}, matrixify: function() {
  const t2 = (this.attr("transform") || "").split(st).slice(0, -1).map(function(t3) {
    const e2 = t3.trim().split("(");
    return [e2[0], e2[1].split(dt).map(function(t4) {
      return parseFloat(t4);
    })];
  }).reverse().reduce(function(t3, e2) {
    return e2[0] === "matrix" ? t3.lmultiply(vt.fromArray(e2[1])) : t3[e2[0]].apply(t3, e2[1]);
  }, new vt);
  return t2;
}, toParent: function(t2, e2) {
  if (this === t2)
    return this;
  if (X(this.node))
    return this.addTo(t2, e2);
  const i2 = this.screenCTM(), a2 = t2.screenCTM().inverse();
  return this.addTo(t2, e2).untransform().transform(a2.multiply(i2)), this;
}, toRoot: function(t2) {
  return this.toParent(this.root(), t2);
}, transform: function(t2, e2) {
  if (t2 == null || typeof t2 == "string") {
    const e3 = new vt(this).decompose();
    return t2 == null ? e3 : e3[t2];
  }
  vt.isMatrixLike(t2) || (t2 = { ...t2, origin: T(t2, this) });
  const i2 = new vt(e2 === true ? this : e2 || false).transform(t2);
  return this.attr("transform", i2);
} });

class Vt extends Gt {
  flatten() {
    return this.each(function() {
      if (this instanceof Vt)
        return this.flatten().ungroup();
    }), this;
  }
  ungroup(t2 = this.parent(), e2 = t2.index(this)) {
    return e2 = e2 === -1 ? t2.children().length : e2, this.each(function(i2, a2) {
      return a2[a2.length - i2 - 1].toParent(t2, e2);
    }), this.remove();
  }
}
q(Vt, "Container");

class Ut extends Vt {
  constructor(t2, e2 = t2) {
    super(G("defs", t2), e2);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
}
q(Ut, "Defs");

class qt extends Gt {
}
q(qt, "Shape");
var ae = Object.freeze({ __proto__: null, cx: Kt, cy: te, height: ie, rx: Zt, ry: $t, width: ee, x: Jt, y: Qt });

class se extends qt {
  constructor(t2, e2 = t2) {
    super(G("ellipse", t2), e2);
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.rx(new _t(i2.width).divide(2)).ry(new _t(i2.height).divide(2));
  }
}
Q(se, ae), A("Container", { ellipse: K(function(t2 = 0, e2 = t2) {
  return this.put(new se).size(t2, e2).move(0, 0);
}) }), q(se, "Ellipse");

class re extends Bt {
  constructor(t2 = O.document.createDocumentFragment()) {
    super(t2);
  }
  xml(t2, e2, i2) {
    if (typeof t2 == "boolean" && (i2 = e2, e2 = t2, t2 = null), t2 == null || typeof t2 == "function") {
      const t3 = new Bt(W("wrapper", i2));
      return t3.add(this.node.cloneNode(true)), t3.xml(false, i2);
    }
    return super.xml(t2, false, i2);
  }
}
q(re, "Fragment");
var le = Object.freeze({ __proto__: null, from: ne, to: oe });

class he extends Vt {
  constructor(t2, e2) {
    super(G(t2 + "Gradient", typeof t2 == "string" ? null : t2), e2);
  }
  attr(t2, e2, i2) {
    return t2 === "transform" && (t2 = "gradientTransform"), super.attr(t2, e2, i2);
  }
  bbox() {
    return new kt;
  }
  targets() {
    return Lt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(t2) {
    return this.clear(), typeof t2 == "function" && t2.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
Q(he, le), A({ Container: { gradient(...t2) {
  return this.defs().gradient(...t2);
} }, Defs: { gradient: K(function(t2, e2) {
  return this.put(new he(t2)).update(e2);
}) } }), q(he, "Gradient");

class ce extends Vt {
  constructor(t2, e2 = t2) {
    super(G("pattern", t2), e2);
  }
  attr(t2, e2, i2) {
    return t2 === "transform" && (t2 = "patternTransform"), super.attr(t2, e2, i2);
  }
  bbox() {
    return new kt;
  }
  targets() {
    return Lt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(t2) {
    return this.clear(), typeof t2 == "function" && t2.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
A({ Container: { pattern(...t2) {
  return this.defs().pattern(...t2);
} }, Defs: { pattern: K(function(t2, e2, i2) {
  return this.put(new ce).update(i2).attr({ x: 0, y: 0, width: t2, height: e2, patternUnits: "userSpaceOnUse" });
}) } }), q(ce, "Pattern");
var de = class extends qt {
  constructor(t2, e2 = t2) {
    super(G("image", t2), e2);
  }
  load(t2, e2) {
    if (!t2)
      return this;
    const i2 = new O.window.Image;
    return zt(i2, "load", function(t3) {
      const a2 = this.parent(ce);
      this.width() === 0 && this.height() === 0 && this.size(i2.width, i2.height), a2 instanceof ce && a2.width() === 0 && a2.height() === 0 && a2.size(this.width(), this.height()), typeof e2 == "function" && e2.call(this, t3);
    }, this), zt(i2, "load error", function() {
      Xt(i2);
    }), this.attr("href", i2.src = t2, H);
  }
};
var ue;
ue = function(t2, e2, i2) {
  return t2 !== "fill" && t2 !== "stroke" || ct.test(e2) && (e2 = i2.root().defs().image(e2)), e2 instanceof de && (e2 = i2.root().defs().pattern(0, 0, (t3) => {
    t3.add(e2);
  })), e2;
}, Wt.push(ue), A({ Container: { image: K(function(t2, e2) {
  return this.put(new de).size(0, 0).load(t2, e2);
}) } }), q(de, "Image");

class ge extends Dt {
  bbox() {
    let t2 = -1 / 0, e2 = -1 / 0, i2 = 1 / 0, a2 = 1 / 0;
    return this.forEach(function(s2) {
      t2 = Math.max(s2[0], t2), e2 = Math.max(s2[1], e2), i2 = Math.min(s2[0], i2), a2 = Math.min(s2[1], a2);
    }), new kt(i2, a2, t2 - i2, e2 - a2);
  }
  move(t2, e2) {
    const i2 = this.bbox();
    if (t2 -= i2.x, e2 -= i2.y, !isNaN(t2) && !isNaN(e2))
      for (let i3 = this.length - 1;i3 >= 0; i3--)
        this[i3] = [this[i3][0] + t2, this[i3][1] + e2];
    return this;
  }
  parse(t2 = [0, 0]) {
    const e2 = [];
    (t2 = t2 instanceof Array ? Array.prototype.concat.apply([], t2) : t2.trim().split(dt).map(parseFloat)).length % 2 != 0 && t2.pop();
    for (let i2 = 0, a2 = t2.length;i2 < a2; i2 += 2)
      e2.push([t2[i2], t2[i2 + 1]]);
    return e2;
  }
  size(t2, e2) {
    let i2;
    const a2 = this.bbox();
    for (i2 = this.length - 1;i2 >= 0; i2--)
      a2.width && (this[i2][0] = (this[i2][0] - a2.x) * t2 / a2.width + a2.x), a2.height && (this[i2][1] = (this[i2][1] - a2.y) * e2 / a2.height + a2.y);
    return this;
  }
  toLine() {
    return { x1: this[0][0], y1: this[0][1], x2: this[1][0], y2: this[1][1] };
  }
  toString() {
    const t2 = [];
    for (let e2 = 0, i2 = this.length;e2 < i2; e2++)
      t2.push(this[e2].join(","));
    return t2.join(" ");
  }
  transform(t2) {
    return this.clone().transformO(t2);
  }
  transformO(t2) {
    vt.isMatrixLike(t2) || (t2 = new vt(t2));
    for (let e2 = this.length;e2--; ) {
      const [i2, a2] = this[e2];
      this[e2][0] = t2.a * i2 + t2.c * a2 + t2.e, this[e2][1] = t2.b * i2 + t2.d * a2 + t2.f;
    }
    return this;
  }
}
var pe = ge;
var fe = Object.freeze({ __proto__: null, MorphArray: pe, height: function(t2) {
  const e2 = this.bbox();
  return t2 == null ? e2.height : this.size(e2.width, t2);
}, width: function(t2) {
  const e2 = this.bbox();
  return t2 == null ? e2.width : this.size(t2, e2.height);
}, x: function(t2) {
  return t2 == null ? this.bbox().x : this.move(t2, this.bbox().y);
}, y: function(t2) {
  return t2 == null ? this.bbox().y : this.move(this.bbox().x, t2);
} });
var xe = class extends qt {
  constructor(t2, e2 = t2) {
    super(G("line", t2), e2);
  }
  array() {
    return new ge([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
  }
  move(t2, e2) {
    return this.attr(this.array().move(t2, e2).toLine());
  }
  plot(t2, e2, i2, a2) {
    return t2 == null ? this.array() : (t2 = e2 !== undefined ? { x1: t2, y1: e2, x2: i2, y2: a2 } : new ge(t2).toLine(), this.attr(t2));
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.attr(this.array().size(i2.width, i2.height).toLine());
  }
};
Q(xe, fe), A({ Container: { line: K(function(...t2) {
  return xe.prototype.plot.apply(this.put(new xe), t2[0] != null ? t2 : [0, 0, 0, 0]);
}) } }), q(xe, "Line");
var be = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G("marker", t2), e2);
  }
  height(t2) {
    return this.attr("markerHeight", t2);
  }
  orient(t2) {
    return this.attr("orient", t2);
  }
  ref(t2, e2) {
    return this.attr("refX", t2).attr("refY", e2);
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
  update(t2) {
    return this.clear(), typeof t2 == "function" && t2.call(this, this), this;
  }
  width(t2) {
    return this.attr("markerWidth", t2);
  }
};
A({ Container: { marker(...t2) {
  return this.defs().marker(...t2);
} }, Defs: { marker: K(function(t2, e2, i2) {
  return this.put(new be).size(t2, e2).ref(t2 / 2, e2 / 2).viewbox(0, 0, t2, e2).attr("orient", "auto").update(i2);
}) }, marker: { marker(t2, e2, i2, a2) {
  let s2 = ["marker"];
  return t2 !== "all" && s2.push(t2), s2 = s2.join("-"), t2 = arguments[1] instanceof be ? arguments[1] : this.defs().marker(e2, i2, a2), this.attr(s2, t2);
} } }), q(be, "Marker");
var ve = { "-": function(t2) {
  return t2;
}, "<>": function(t2) {
  return -Math.cos(t2 * Math.PI) / 2 + 0.5;
}, ">": function(t2) {
  return Math.sin(t2 * Math.PI / 2);
}, "<": function(t2) {
  return 1 - Math.cos(t2 * Math.PI / 2);
}, bezier: function(t2, e2, i2, a2) {
  return function(s2) {
    return s2 < 0 ? t2 > 0 ? e2 / t2 * s2 : i2 > 0 ? a2 / i2 * s2 : 0 : s2 > 1 ? i2 < 1 ? (1 - a2) / (1 - i2) * s2 + (a2 - i2) / (1 - i2) : t2 < 1 ? (1 - e2) / (1 - t2) * s2 + (e2 - t2) / (1 - t2) : 1 : 3 * s2 * (1 - s2) ** 2 * e2 + 3 * s2 ** 2 * (1 - s2) * a2 + s2 ** 3;
  };
}, steps: function(t2, e2 = "end") {
  e2 = e2.split("-").reverse()[0];
  let i2 = t2;
  return e2 === "none" ? --i2 : e2 === "both" && ++i2, (a2, s2 = false) => {
    let r2 = Math.floor(a2 * t2);
    const n2 = a2 * r2 % 1 == 0;
    return e2 !== "start" && e2 !== "both" || ++r2, s2 && n2 && --r2, a2 >= 0 && r2 < 0 && (r2 = 0), a2 <= 1 && r2 > i2 && (r2 = i2), r2 / i2;
  };
} };

class ye {
  done() {
    return false;
  }
}

class we extends ye {
  constructor(t2 = Ht) {
    super(), this.ease = ve[t2] || t2;
  }
  step(t2, e2, i2) {
    return typeof t2 != "number" ? i2 < 1 ? t2 : e2 : t2 + (e2 - t2) * this.ease(i2);
  }
}

class ke extends ye {
  constructor(t2) {
    super(), this.stepper = t2;
  }
  done(t2) {
    return t2.done;
  }
  step(t2, e2, i2, a2) {
    return this.stepper(t2, e2, i2, a2);
  }
}
Q(class extends ke {
  constructor(t2 = 500, e2 = 0) {
    super(), this.duration(t2).overshoot(e2);
  }
  step(t2, e2, i2, a2) {
    if (typeof t2 == "string")
      return t2;
    if (a2.done = i2 === 1 / 0, i2 === 1 / 0)
      return e2;
    if (i2 === 0)
      return t2;
    i2 > 100 && (i2 = 16), i2 /= 1000;
    const s2 = a2.velocity || 0, r2 = -this.d * s2 - this.k * (t2 - e2), n2 = t2 + s2 * i2 + r2 * i2 * i2 / 2;
    return a2.velocity = s2 + r2 * i2, a2.done = Math.abs(e2 - n2) + Math.abs(s2) < 0.002, a2.done ? e2 : n2;
  }
}, { duration: me("_duration", Ae), overshoot: me("_overshoot", Ae) });
Q(class extends ke {
  constructor(t2 = 0.1, e2 = 0.01, i2 = 0, a2 = 1000) {
    super(), this.p(t2).i(e2).d(i2).windup(a2);
  }
  step(t2, e2, i2, a2) {
    if (typeof t2 == "string")
      return t2;
    if (a2.done = i2 === 1 / 0, i2 === 1 / 0)
      return e2;
    if (i2 === 0)
      return t2;
    const s2 = e2 - t2;
    let r2 = (a2.integral || 0) + s2 * i2;
    const n2 = (s2 - (a2.error || 0)) / i2, o2 = this._windup;
    return o2 !== false && (r2 = Math.max(-o2, Math.min(r2, o2))), a2.error = s2, a2.integral = r2, a2.done = Math.abs(s2) < 0.001, a2.done ? e2 : t2 + (this.P * s2 + this.I * r2 + this.D * n2);
  }
}, { windup: me("_windup"), p: me("P"), i: me("I"), d: me("D") });
var Ce = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
var Se = { M: function(t2, e2, i2) {
  return e2.x = i2.x = t2[0], e2.y = i2.y = t2[1], ["M", e2.x, e2.y];
}, L: function(t2, e2) {
  return e2.x = t2[0], e2.y = t2[1], ["L", t2[0], t2[1]];
}, H: function(t2, e2) {
  return e2.x = t2[0], ["H", t2[0]];
}, V: function(t2, e2) {
  return e2.y = t2[0], ["V", t2[0]];
}, C: function(t2, e2) {
  return e2.x = t2[4], e2.y = t2[5], ["C", t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]];
}, S: function(t2, e2) {
  return e2.x = t2[2], e2.y = t2[3], ["S", t2[0], t2[1], t2[2], t2[3]];
}, Q: function(t2, e2) {
  return e2.x = t2[2], e2.y = t2[3], ["Q", t2[0], t2[1], t2[2], t2[3]];
}, T: function(t2, e2) {
  return e2.x = t2[0], e2.y = t2[1], ["T", t2[0], t2[1]];
}, Z: function(t2, e2, i2) {
  return e2.x = i2.x, e2.y = i2.y, ["Z"];
}, A: function(t2, e2) {
  return e2.x = t2[5], e2.y = t2[6], ["A", t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]];
} };
var Le = "mlhvqtcsaz".split("");
for (let t2 = 0, e2 = Le.length;t2 < e2; ++t2)
  Se[Le[t2]] = function(t3) {
    return function(e3, i2, a2) {
      if (t3 === "H")
        e3[0] = e3[0] + i2.x;
      else if (t3 === "V")
        e3[0] = e3[0] + i2.y;
      else if (t3 === "A")
        e3[5] = e3[5] + i2.x, e3[6] = e3[6] + i2.y;
      else
        for (let t4 = 0, a3 = e3.length;t4 < a3; ++t4)
          e3[t4] = e3[t4] + (t4 % 2 ? i2.y : i2.x);
      return Se[t3](e3, i2, a2);
    };
  }(Le[t2].toUpperCase());
var Re = new Set([" ", ",", "\t", "\n", "\r", "\f"]);

class Ee extends Dt {
  bbox() {
    return yt().path.setAttribute("d", this.toString()), new kt(yt.nodes.path.getBBox());
  }
  move(t2, e2) {
    const i2 = this.bbox();
    if (t2 -= i2.x, e2 -= i2.y, !isNaN(t2) && !isNaN(e2))
      for (let i3, a2 = this.length - 1;a2 >= 0; a2--)
        i3 = this[a2][0], i3 === "M" || i3 === "L" || i3 === "T" ? (this[a2][1] += t2, this[a2][2] += e2) : i3 === "H" ? this[a2][1] += t2 : i3 === "V" ? this[a2][1] += e2 : i3 === "C" || i3 === "S" || i3 === "Q" ? (this[a2][1] += t2, this[a2][2] += e2, this[a2][3] += t2, this[a2][4] += e2, i3 === "C" && (this[a2][5] += t2, this[a2][6] += e2)) : i3 === "A" && (this[a2][6] += t2, this[a2][7] += e2);
    return this;
  }
  parse(t2 = "M0 0") {
    return Array.isArray(t2) && (t2 = Array.prototype.concat.apply([], t2).toString()), function(t3, e2 = true) {
      let i2 = 0, a2 = "";
      const s2 = { segment: [], inNumber: false, number: "", lastToken: "", inSegment: false, segments: [], pointSeen: false, hasExponent: false, absolute: e2, p0: new bt, p: new bt };
      for (;s2.lastToken = a2, a2 = t3.charAt(i2++); )
        if (s2.inSegment || !Pe(s2, a2))
          if (a2 !== ".")
            if (isNaN(parseInt(a2)))
              if (Re.has(a2))
                s2.inNumber && Ie(s2, false);
              else if (a2 !== "-" && a2 !== "+")
                if (a2.toUpperCase() !== "E") {
                  if (ut.test(a2)) {
                    if (s2.inNumber)
                      Ie(s2, false);
                    else {
                      if (!Me(s2))
                        throw new Error("parser Error");
                      Te(s2);
                    }
                    --i2;
                  }
                } else
                  s2.number += a2, s2.hasExponent = true;
              else {
                if (s2.inNumber && !Xe(s2)) {
                  Ie(s2, false), --i2;
                  continue;
                }
                s2.number += a2, s2.inNumber = true;
              }
            else {
              if (s2.number === "0" || ze(s2)) {
                s2.inNumber = true, s2.number = a2, Ie(s2, true);
                continue;
              }
              s2.inNumber = true, s2.number += a2;
            }
          else {
            if (s2.pointSeen || s2.hasExponent) {
              Ie(s2, false), --i2;
              continue;
            }
            s2.inNumber = true, s2.pointSeen = true, s2.number += a2;
          }
      return s2.inNumber && Ie(s2, false), s2.inSegment && Me(s2) && Te(s2), s2.segments;
    }(t2);
  }
  size(t2, e2) {
    const i2 = this.bbox();
    let a2, s2;
    for (i2.width = i2.width === 0 ? 1 : i2.width, i2.height = i2.height === 0 ? 1 : i2.height, a2 = this.length - 1;a2 >= 0; a2--)
      s2 = this[a2][0], s2 === "M" || s2 === "L" || s2 === "T" ? (this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x, this[a2][2] = (this[a2][2] - i2.y) * e2 / i2.height + i2.y) : s2 === "H" ? this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x : s2 === "V" ? this[a2][1] = (this[a2][1] - i2.y) * e2 / i2.height + i2.y : s2 === "C" || s2 === "S" || s2 === "Q" ? (this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x, this[a2][2] = (this[a2][2] - i2.y) * e2 / i2.height + i2.y, this[a2][3] = (this[a2][3] - i2.x) * t2 / i2.width + i2.x, this[a2][4] = (this[a2][4] - i2.y) * e2 / i2.height + i2.y, s2 === "C" && (this[a2][5] = (this[a2][5] - i2.x) * t2 / i2.width + i2.x, this[a2][6] = (this[a2][6] - i2.y) * e2 / i2.height + i2.y)) : s2 === "A" && (this[a2][1] = this[a2][1] * t2 / i2.width, this[a2][2] = this[a2][2] * e2 / i2.height, this[a2][6] = (this[a2][6] - i2.x) * t2 / i2.width + i2.x, this[a2][7] = (this[a2][7] - i2.y) * e2 / i2.height + i2.y);
    return this;
  }
  toString() {
    return function(t2) {
      let e2 = "";
      for (let i2 = 0, a2 = t2.length;i2 < a2; i2++)
        e2 += t2[i2][0], t2[i2][1] != null && (e2 += t2[i2][1], t2[i2][2] != null && (e2 += " ", e2 += t2[i2][2], t2[i2][3] != null && (e2 += " ", e2 += t2[i2][3], e2 += " ", e2 += t2[i2][4], t2[i2][5] != null && (e2 += " ", e2 += t2[i2][5], e2 += " ", e2 += t2[i2][6], t2[i2][7] != null && (e2 += " ", e2 += t2[i2][7])))));
      return e2 + " ";
    }(this);
  }
}
var Ye = (t2) => {
  const e2 = typeof t2;
  return e2 === "number" ? _t : e2 === "string" ? xt.isColor(t2) ? xt : dt.test(t2) ? ut.test(t2) ? Ee : Dt : tt.test(t2) ? _t : Oe : Ne.indexOf(t2.constructor) > -1 ? t2.constructor : Array.isArray(t2) ? Dt : e2 === "object" ? _e : Oe;
};

class He {
  constructor(t2) {
    this._stepper = t2 || new we("-"), this._from = null, this._to = null, this._type = null, this._context = null, this._morphObj = null;
  }
  at(t2) {
    return this._morphObj.morph(this._from, this._to, t2, this._stepper, this._context);
  }
  done() {
    return this._context.map(this._stepper.done).reduce(function(t2, e2) {
      return t2 && e2;
    }, true);
  }
  from(t2) {
    return t2 == null ? this._from : (this._from = this._set(t2), this);
  }
  stepper(t2) {
    return t2 == null ? this._stepper : (this._stepper = t2, this);
  }
  to(t2) {
    return t2 == null ? this._to : (this._to = this._set(t2), this);
  }
  type(t2) {
    return t2 == null ? this._type : (this._type = t2, this);
  }
  _set(t2) {
    this._type || this.type(Ye(t2));
    let e2 = new this._type(t2);
    return this._type === xt && (e2 = this._to ? e2[this._to[4]]() : this._from ? e2[this._from[4]]() : e2), this._type === _e && (e2 = this._to ? e2.align(this._to) : this._from ? e2.align(this._from) : e2), e2 = e2.toConsumable(), this._morphObj = this._morphObj || new this._type, this._context = this._context || Array.apply(null, Array(e2.length)).map(Object).map(function(t3) {
      return t3.done = true, t3;
    }), e2;
  }
}

class Oe {
  constructor(...t2) {
    this.init(...t2);
  }
  init(t2) {
    return t2 = Array.isArray(t2) ? t2[0] : t2, this.value = t2, this;
  }
  toArray() {
    return [this.value];
  }
  valueOf() {
    return this.value;
  }
}

class Fe {
  constructor(...t2) {
    this.init(...t2);
  }
  init(t2) {
    return Array.isArray(t2) && (t2 = { scaleX: t2[0], scaleY: t2[1], shear: t2[2], rotate: t2[3], translateX: t2[4], translateY: t2[5], originX: t2[6], originY: t2[7] }), Object.assign(this, Fe.defaults, t2), this;
  }
  toArray() {
    const t2 = this;
    return [t2.scaleX, t2.scaleY, t2.shear, t2.rotate, t2.translateX, t2.translateY, t2.originX, t2.originY];
  }
}
Fe.defaults = { scaleX: 1, scaleY: 1, shear: 0, rotate: 0, translateX: 0, translateY: 0, originX: 0, originY: 0 };
var De = (t2, e2) => t2[0] < e2[0] ? -1 : t2[0] > e2[0] ? 1 : 0;

class _e {
  constructor(...t2) {
    this.init(...t2);
  }
  align(t2) {
    const e2 = this.values;
    for (let i2 = 0, a2 = e2.length;i2 < a2; ++i2) {
      if (e2[i2 + 1] === t2[i2 + 1]) {
        if (e2[i2 + 1] === xt && t2[i2 + 7] !== e2[i2 + 7]) {
          const e3 = t2[i2 + 7], a4 = new xt(this.values.splice(i2 + 3, 5))[e3]().toArray();
          this.values.splice(i2 + 3, 0, ...a4);
        }
        i2 += e2[i2 + 2] + 2;
        continue;
      }
      if (!t2[i2 + 1])
        return this;
      const a3 = new t2[i2 + 1]().toArray(), s2 = e2[i2 + 2] + 3;
      e2.splice(i2, s2, t2[i2], t2[i2 + 1], t2[i2 + 2], ...a3), i2 += e2[i2 + 2] + 2;
    }
    return this;
  }
  init(t2) {
    if (this.values = [], Array.isArray(t2))
      return void (this.values = t2.slice());
    t2 = t2 || {};
    const e2 = [];
    for (const i2 in t2) {
      const a2 = Ye(t2[i2]), s2 = new a2(t2[i2]).toArray();
      e2.push([i2, a2, s2.length, ...s2]);
    }
    return e2.sort(De), this.values = e2.reduce((t3, e3) => t3.concat(e3), []), this;
  }
  toArray() {
    return this.values;
  }
  valueOf() {
    const t2 = {}, e2 = this.values;
    for (;e2.length; ) {
      const i2 = e2.shift(), a2 = e2.shift(), s2 = e2.shift(), r2 = e2.splice(0, s2);
      t2[i2] = new a2(r2);
    }
    return t2;
  }
}
var Ne = [Oe, Fe, _e];

class We extends qt {
  constructor(t2, e2 = t2) {
    super(G("path", t2), e2);
  }
  array() {
    return this._array || (this._array = new Ee(this.attr("d")));
  }
  clear() {
    return delete this._array, this;
  }
  height(t2) {
    return t2 == null ? this.bbox().height : this.size(this.bbox().width, t2);
  }
  move(t2, e2) {
    return this.attr("d", this.array().move(t2, e2));
  }
  plot(t2) {
    return t2 == null ? this.array() : this.clear().attr("d", typeof t2 == "string" ? t2 : this._array = new Ee(t2));
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.attr("d", this.array().size(i2.width, i2.height));
  }
  width(t2) {
    return t2 == null ? this.bbox().width : this.size(t2, this.bbox().height);
  }
  x(t2) {
    return t2 == null ? this.bbox().x : this.move(t2, this.bbox().y);
  }
  y(t2) {
    return t2 == null ? this.bbox().y : this.move(this.bbox().x, t2);
  }
}
We.prototype.MorphArray = Ee, A({ Container: { path: K(function(t2) {
  return this.put(new We).plot(t2 || new Ee);
}) } }), q(We, "Path");
var Be = Object.freeze({ __proto__: null, array: function() {
  return this._array || (this._array = new ge(this.attr("points")));
}, clear: function() {
  return delete this._array, this;
}, move: function(t2, e2) {
  return this.attr("points", this.array().move(t2, e2));
}, plot: function(t2) {
  return t2 == null ? this.array() : this.clear().attr("points", typeof t2 == "string" ? t2 : this._array = new ge(t2));
}, size: function(t2, e2) {
  const i2 = I(this, t2, e2);
  return this.attr("points", this.array().size(i2.width, i2.height));
} });

class Ge extends qt {
  constructor(t2, e2 = t2) {
    super(G("polygon", t2), e2);
  }
}
A({ Container: { polygon: K(function(t2) {
  return this.put(new Ge).plot(t2 || new ge);
}) } }), Q(Ge, fe), Q(Ge, Be), q(Ge, "Polygon");

class je extends qt {
  constructor(t2, e2 = t2) {
    super(G("polyline", t2), e2);
  }
}
A({ Container: { polyline: K(function(t2) {
  return this.put(new je).plot(t2 || new ge);
}) } }), Q(je, fe), Q(je, Be), q(je, "Polyline");

class Ve extends qt {
  constructor(t2, e2 = t2) {
    super(G("rect", t2), e2);
  }
}
Q(Ve, { rx: Zt, ry: $t }), A({ Container: { rect: K(function(t2, e2) {
  return this.put(new Ve).size(t2, e2);
}) } }), q(Ve, "Rect");

class Ue {
  constructor() {
    this._first = null, this._last = null;
  }
  first() {
    return this._first && this._first.value;
  }
  last() {
    return this._last && this._last.value;
  }
  push(t2) {
    const e2 = t2.next !== undefined ? t2 : { value: t2, next: null, prev: null };
    return this._last ? (e2.prev = this._last, this._last.next = e2, this._last = e2) : (this._last = e2, this._first = e2), e2;
  }
  remove(t2) {
    t2.prev && (t2.prev.next = t2.next), t2.next && (t2.next.prev = t2.prev), t2 === this._last && (this._last = t2.prev), t2 === this._first && (this._first = t2.next), t2.prev = null, t2.next = null;
  }
  shift() {
    const t2 = this._first;
    return t2 ? (this._first = t2.next, this._first && (this._first.prev = null), this._last = this._first ? this._last : null, t2.value) : null;
  }
}
var qe = { nextDraw: null, frames: new Ue, timeouts: new Ue, immediates: new Ue, timer: () => O.window.performance || O.window.Date, transforms: [], frame(t2) {
  const e2 = qe.frames.push({ run: t2 });
  return qe.nextDraw === null && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e2;
}, timeout(t2, e2) {
  e2 = e2 || 0;
  const i2 = qe.timer().now() + e2, a2 = qe.timeouts.push({ run: t2, time: i2 });
  return qe.nextDraw === null && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), a2;
}, immediate(t2) {
  const e2 = qe.immediates.push(t2);
  return qe.nextDraw === null && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e2;
}, cancelFrame(t2) {
  t2 != null && qe.frames.remove(t2);
}, clearTimeout(t2) {
  t2 != null && qe.timeouts.remove(t2);
}, cancelImmediate(t2) {
  t2 != null && qe.immediates.remove(t2);
}, _draw(t2) {
  let e2 = null;
  const i2 = qe.timeouts.last();
  for (;(e2 = qe.timeouts.shift()) && (t2 >= e2.time ? e2.run() : qe.timeouts.push(e2), e2 !== i2); )
    ;
  let a2 = null;
  const s2 = qe.frames.last();
  for (;a2 !== s2 && (a2 = qe.frames.shift()); )
    a2.run(t2);
  let r2 = null;
  for (;r2 = qe.immediates.shift(); )
    r2();
  qe.nextDraw = qe.timeouts.first() || qe.frames.first() ? O.window.requestAnimationFrame(qe._draw) : null;
} };
var Ze = function(t2) {
  const e2 = t2.start, i2 = t2.runner.duration();
  return { start: e2, duration: i2, end: e2 + i2, runner: t2.runner };
};
var $e = function() {
  const t2 = O.window;
  return (t2.performance || t2.Date).now();
};

class Je extends Rt {
  constructor(t2 = $e) {
    super(), this._timeSource = t2, this.terminate();
  }
  active() {
    return !!this._nextFrame;
  }
  finish() {
    return this.time(this.getEndTimeOfTimeline() + 1), this.pause();
  }
  getEndTime() {
    const t2 = this.getLastRunnerInfo(), e2 = t2 ? t2.runner.duration() : 0;
    return (t2 ? t2.start : this._time) + e2;
  }
  getEndTimeOfTimeline() {
    const t2 = this._runners.map((t3) => t3.start + t3.runner.duration());
    return Math.max(0, ...t2);
  }
  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }
  getRunnerInfoById(t2) {
    return this._runners[this._runnerIds.indexOf(t2)] || null;
  }
  pause() {
    return this._paused = true, this._continue();
  }
  persist(t2) {
    return t2 == null ? this._persist : (this._persist = t2, this);
  }
  play() {
    return this._paused = false, this.updateTime()._continue();
  }
  reverse(t2) {
    const e2 = this.speed();
    if (t2 == null)
      return this.speed(-e2);
    const i2 = Math.abs(e2);
    return this.speed(t2 ? -i2 : i2);
  }
  schedule(t2, e2, i2) {
    if (t2 == null)
      return this._runners.map(Ze);
    let a2 = 0;
    const s2 = this.getEndTime();
    if (e2 = e2 || 0, i2 == null || i2 === "last" || i2 === "after")
      a2 = s2;
    else if (i2 === "absolute" || i2 === "start")
      a2 = e2, e2 = 0;
    else if (i2 === "now")
      a2 = this._time;
    else if (i2 === "relative") {
      const i3 = this.getRunnerInfoById(t2.id);
      i3 && (a2 = i3.start + e2, e2 = 0);
    } else {
      if (i2 !== "with-last")
        throw new Error('Invalid value for the "when" parameter');
      {
        const t3 = this.getLastRunnerInfo();
        a2 = t3 ? t3.start : this._time;
      }
    }
    t2.unschedule(), t2.timeline(this);
    const r2 = t2.persist(), n2 = { persist: r2 === null ? this._persist : r2, start: a2 + e2, runner: t2 };
    return this._lastRunnerId = t2.id, this._runners.push(n2), this._runners.sort((t3, e3) => t3.start - e3.start), this._runnerIds = this._runners.map((t3) => t3.runner.id), this.updateTime()._continue(), this;
  }
  seek(t2) {
    return this.time(this._time + t2);
  }
  source(t2) {
    return t2 == null ? this._timeSource : (this._timeSource = t2, this);
  }
  speed(t2) {
    return t2 == null ? this._speed : (this._speed = t2, this);
  }
  stop() {
    return this.time(0), this.pause();
  }
  time(t2) {
    return t2 == null ? this._time : (this._time = t2, this._continue(true));
  }
  unschedule(t2) {
    const e2 = this._runnerIds.indexOf(t2.id);
    return e2 < 0 || (this._runners.splice(e2, 1), this._runnerIds.splice(e2, 1), t2.timeline(null)), this;
  }
  updateTime() {
    return this.active() || (this._lastSourceTime = this._timeSource()), this;
  }
  _continue(t2 = false) {
    return qe.cancelFrame(this._nextFrame), this._nextFrame = null, t2 ? this._stepImmediate() : (this._paused || (this._nextFrame = qe.frame(this._step)), this);
  }
  _stepFn(t2 = false) {
    const e2 = this._timeSource();
    let i2 = e2 - this._lastSourceTime;
    t2 && (i2 = 0);
    const a2 = this._speed * i2 + (this._time - this._lastStepTime);
    this._lastSourceTime = e2, t2 || (this._time += a2, this._time = this._time < 0 ? 0 : this._time), this._lastStepTime = this._time, this.fire("time", this._time);
    for (let t3 = this._runners.length;t3--; ) {
      const e3 = this._runners[t3], i3 = e3.runner;
      this._time - e3.start <= 0 && i3.reset();
    }
    let s2 = false;
    for (let t3 = 0, e3 = this._runners.length;t3 < e3; t3++) {
      const i3 = this._runners[t3], r2 = i3.runner;
      let n2 = a2;
      const o2 = this._time - i3.start;
      if (o2 <= 0) {
        s2 = true;
        continue;
      }
      if (o2 < n2 && (n2 = o2), !r2.active())
        continue;
      if (r2.step(n2).done) {
        if (i3.persist !== true) {
          r2.duration() - r2.time() + this._time + i3.persist < this._time && (r2.unschedule(), --t3, --e3);
        }
      } else
        s2 = true;
    }
    return s2 && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0 ? this._continue() : (this.pause(), this.fire("finished")), this;
  }
  terminate() {
    this._startTime = 0, this._speed = 1, this._persist = 0, this._nextFrame = null, this._paused = true, this._runners = [], this._runnerIds = [], this._lastRunnerId = -1, this._time = 0, this._lastSourceTime = 0, this._lastStepTime = 0, this._step = this._stepFn.bind(this, false), this._stepImmediate = this._stepFn.bind(this, true);
  }
}
A({ Element: { timeline: function(t2) {
  return t2 == null ? (this._timeline = this._timeline || new Je, this._timeline) : (this._timeline = t2, this);
} } });

class Qe extends Rt {
  constructor(t2) {
    super(), this.id = Qe.id++, t2 = typeof (t2 = t2 == null ? Yt : t2) == "function" ? new ke(t2) : t2, this._element = null, this._timeline = null, this.done = false, this._queue = [], this._duration = typeof t2 == "number" && t2, this._isDeclarative = t2 instanceof ke, this._stepper = this._isDeclarative ? t2 : new we, this._history = {}, this.enabled = true, this._time = 0, this._lastTime = 0, this._reseted = true, this.transforms = new vt, this.transformId = 1, this._haveReversed = false, this._reverse = false, this._loopsDone = 0, this._swing = false, this._wait = 0, this._times = 1, this._frameId = null, this._persist = !!this._isDeclarative || null;
  }
  static sanitise(t2, e2, i2) {
    let a2 = 1, s2 = false, r2 = 0;
    return e2 = e2 ?? Ot, i2 = i2 || "last", typeof (t2 = t2 ?? Yt) != "object" || t2 instanceof ye || (e2 = t2.delay ?? e2, i2 = t2.when ?? i2, s2 = t2.swing || s2, a2 = t2.times ?? a2, r2 = t2.wait ?? r2, t2 = t2.duration ?? Yt), { duration: t2, delay: e2, swing: s2, times: a2, wait: r2, when: i2 };
  }
  active(t2) {
    return t2 == null ? this.enabled : (this.enabled = t2, this);
  }
  addTransform(t2) {
    return this.transforms.lmultiplyO(t2), this;
  }
  after(t2) {
    return this.on("finished", t2);
  }
  animate(t2, e2, i2) {
    const a2 = Qe.sanitise(t2, e2, i2), s2 = new Qe(a2.duration);
    return this._timeline && s2.timeline(this._timeline), this._element && s2.element(this._element), s2.loop(a2).schedule(a2.delay, a2.when);
  }
  clearTransform() {
    return this.transforms = new vt, this;
  }
  clearTransformsFromQueue() {
    this.done && this._timeline && this._timeline._runnerIds.includes(this.id) || (this._queue = this._queue.filter((t2) => !t2.isTransform));
  }
  delay(t2) {
    return this.animate(0, t2);
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  during(t2) {
    return this.queue(null, t2);
  }
  ease(t2) {
    return this._stepper = new we(t2), this;
  }
  element(t2) {
    return t2 == null ? this._element : (this._element = t2, t2._prepareRunner(), this);
  }
  finish() {
    return this.step(1 / 0);
  }
  loop(t2, e2, i2) {
    return typeof t2 == "object" && (e2 = t2.swing, i2 = t2.wait, t2 = t2.times), this._times = t2 || 1 / 0, this._swing = e2 || false, this._wait = i2 || 0, this._times === true && (this._times = 1 / 0), this;
  }
  loops(t2) {
    const e2 = this._duration + this._wait;
    if (t2 == null) {
      const t3 = Math.floor(this._time / e2), i3 = (this._time - t3 * e2) / this._duration;
      return Math.min(t3 + i3, this._times);
    }
    const i2 = t2 % 1, a2 = e2 * Math.floor(t2) + this._duration * i2;
    return this.time(a2);
  }
  persist(t2) {
    return t2 == null ? this._persist : (this._persist = t2, this);
  }
  position(t2) {
    const e2 = this._time, i2 = this._duration, a2 = this._wait, s2 = this._times, r2 = this._swing, n2 = this._reverse;
    let o2;
    if (t2 == null) {
      const t3 = function(t4) {
        const e3 = r2 * Math.floor(t4 % (2 * (a2 + i2)) / (a2 + i2)), s3 = e3 && !n2 || !e3 && n2, o3 = Math.pow(-1, s3) * (t4 % (a2 + i2)) / i2 + s3;
        return Math.max(Math.min(o3, 1), 0);
      }, l3 = s2 * (a2 + i2) - a2;
      return o2 = e2 <= 0 ? Math.round(t3(0.00001)) : e2 < l3 ? t3(e2) : Math.round(t3(l3 - 0.00001)), o2;
    }
    const l2 = Math.floor(this.loops()), h2 = r2 && l2 % 2 == 0;
    return o2 = l2 + (h2 && !n2 || n2 && h2 ? t2 : 1 - t2), this.loops(o2);
  }
  progress(t2) {
    return t2 == null ? Math.min(1, this._time / this.duration()) : this.time(t2 * this.duration());
  }
  queue(t2, e2, i2, a2) {
    this._queue.push({ initialiser: t2 || Et, runner: e2 || Et, retarget: i2, isTransform: a2, initialised: false, finished: false });
    return this.timeline() && this.timeline()._continue(), this;
  }
  reset() {
    return this._reseted || (this.time(0), this._reseted = true), this;
  }
  reverse(t2) {
    return this._reverse = t2 == null ? !this._reverse : t2, this;
  }
  schedule(t2, e2, i2) {
    if (t2 instanceof Je || (i2 = e2, e2 = t2, t2 = this.timeline()), !t2)
      throw Error("Runner cannot be scheduled without timeline");
    return t2.schedule(this, e2, i2), this;
  }
  step(t2) {
    if (!this.enabled)
      return this;
    t2 = t2 == null ? 16 : t2, this._time += t2;
    const e2 = this.position(), i2 = this._lastPosition !== e2 && this._time >= 0;
    this._lastPosition = e2;
    const a2 = this.duration(), s2 = this._lastTime <= 0 && this._time > 0, r2 = this._lastTime < a2 && this._time >= a2;
    this._lastTime = this._time, s2 && this.fire("start", this);
    const n2 = this._isDeclarative;
    this.done = !n2 && !r2 && this._time >= a2, this._reseted = false;
    let o2 = false;
    return (i2 || n2) && (this._initialise(i2), this.transforms = new vt, o2 = this._run(n2 ? t2 : e2), this.fire("step", this)), this.done = this.done || o2 && n2, r2 && this.fire("finished", this), this;
  }
  time(t2) {
    if (t2 == null)
      return this._time;
    const e2 = t2 - this._time;
    return this.step(e2), this;
  }
  timeline(t2) {
    return t2 === undefined ? this._timeline : (this._timeline = t2, this);
  }
  unschedule() {
    const t2 = this.timeline();
    return t2 && t2.unschedule(this), this;
  }
  _initialise(t2) {
    if (t2 || this._isDeclarative)
      for (let e2 = 0, i2 = this._queue.length;e2 < i2; ++e2) {
        const i3 = this._queue[e2], a2 = this._isDeclarative || !i3.initialised && t2;
        t2 = !i3.finished, a2 && t2 && (i3.initialiser.call(this), i3.initialised = true);
      }
  }
  _rememberMorpher(t2, e2) {
    if (this._history[t2] = { morpher: e2, caller: this._queue[this._queue.length - 1] }, this._isDeclarative) {
      const t3 = this.timeline();
      t3 && t3.play();
    }
  }
  _run(t2) {
    let e2 = true;
    for (let i2 = 0, a2 = this._queue.length;i2 < a2; ++i2) {
      const a3 = this._queue[i2], s2 = a3.runner.call(this, t2);
      a3.finished = a3.finished || s2 === true, e2 = e2 && a3.finished;
    }
    return e2;
  }
  _tryRetarget(t2, e2, i2) {
    if (this._history[t2]) {
      if (!this._history[t2].caller.initialised) {
        const e3 = this._queue.indexOf(this._history[t2].caller);
        return this._queue.splice(e3, 1), false;
      }
      this._history[t2].caller.retarget ? this._history[t2].caller.retarget.call(this, e2, i2) : this._history[t2].morpher.to(e2), this._history[t2].caller.finished = false;
      const a2 = this.timeline();
      return a2 && a2.play(), true;
    }
    return false;
  }
}
Qe.id = 0;

class Ke {
  constructor(t2 = new vt, e2 = -1, i2 = true) {
    this.transforms = t2, this.id = e2, this.done = i2;
  }
  clearTransformsFromQueue() {
  }
}
Q([Qe, Ke], { mergeWith(t2) {
  return new Ke(t2.transforms.lmultiply(this.transforms), t2.id);
} });
var ti = (t2, e2) => t2.lmultiplyO(e2);
var ei = (t2) => t2.transforms;

class ai {
  constructor() {
    this.runners = [], this.ids = [];
  }
  add(t2) {
    if (this.runners.includes(t2))
      return;
    const e2 = t2.id + 1;
    return this.runners.push(t2), this.ids.push(e2), this;
  }
  clearBefore(t2) {
    const e2 = this.ids.indexOf(t2 + 1) || 1;
    return this.ids.splice(0, e2, 0), this.runners.splice(0, e2, new Ke).forEach((t3) => t3.clearTransformsFromQueue()), this;
  }
  edit(t2, e2) {
    const i2 = this.ids.indexOf(t2 + 1);
    return this.ids.splice(i2, 1, t2 + 1), this.runners.splice(i2, 1, e2), this;
  }
  getByID(t2) {
    return this.runners[this.ids.indexOf(t2 + 1)];
  }
  length() {
    return this.ids.length;
  }
  merge() {
    let t2 = null;
    for (let e2 = 0;e2 < this.runners.length; ++e2) {
      const i2 = this.runners[e2];
      if (t2 && i2.done && t2.done && (!i2._timeline || !i2._timeline._runnerIds.includes(i2.id)) && (!t2._timeline || !t2._timeline._runnerIds.includes(t2.id))) {
        this.remove(i2.id);
        const a2 = i2.mergeWith(t2);
        this.edit(t2.id, a2), t2 = a2, --e2;
      } else
        t2 = i2;
    }
    return this;
  }
  remove(t2) {
    const e2 = this.ids.indexOf(t2 + 1);
    return this.ids.splice(e2, 1), this.runners.splice(e2, 1), this;
  }
}
A({ Element: { animate(t2, e2, i2) {
  const a2 = Qe.sanitise(t2, e2, i2), s2 = this.timeline();
  return new Qe(a2.duration).loop(a2).element(this).timeline(s2.play()).schedule(a2.delay, a2.when);
}, delay(t2, e2) {
  return this.animate(0, t2, e2);
}, _clearTransformRunnersBefore(t2) {
  this._transformationRunners.clearBefore(t2.id);
}, _currentTransform(t2) {
  return this._transformationRunners.runners.filter((e2) => e2.id <= t2.id).map(ei).reduce(ti, new vt);
}, _addRunner(t2) {
  this._transformationRunners.add(t2), qe.cancelImmediate(this._frameId), this._frameId = qe.immediate(ii.bind(this));
}, _prepareRunner() {
  this._frameId == null && (this._transformationRunners = new ai().add(new Ke(new vt(this))));
} } });
Q(Qe, { attr(t2, e2) {
  return this.styleAttr("attr", t2, e2);
}, css(t2, e2) {
  return this.styleAttr("css", t2, e2);
}, styleAttr(t2, e2, i2) {
  if (typeof e2 == "string")
    return this.styleAttr(t2, { [e2]: i2 });
  let a2 = e2;
  if (this._tryRetarget(t2, a2))
    return this;
  let s2 = new He(this._stepper).to(a2), r2 = Object.keys(a2);
  return this.queue(function() {
    s2 = s2.from(this.element()[t2](r2));
  }, function(e3) {
    return this.element()[t2](s2.at(e3).valueOf()), s2.done();
  }, function(e3) {
    const i3 = Object.keys(e3), n2 = (o2 = r2, i3.filter((t3) => !o2.includes(t3)));
    var o2;
    if (n2.length) {
      const e4 = this.element()[t2](n2), i4 = new _e(s2.from()).valueOf();
      Object.assign(i4, e4), s2.from(i4);
    }
    const l2 = new _e(s2.to()).valueOf();
    Object.assign(l2, e3), s2.to(l2), r2 = i3, a2 = e3;
  }), this._rememberMorpher(t2, s2), this;
}, zoom(t2, e2) {
  if (this._tryRetarget("zoom", t2, e2))
    return this;
  let i2 = new He(this._stepper).to(new _t(t2));
  return this.queue(function() {
    i2 = i2.from(this.element().zoom());
  }, function(t3) {
    return this.element().zoom(i2.at(t3), e2), i2.done();
  }, function(t3, a2) {
    e2 = a2, i2.to(t3);
  }), this._rememberMorpher("zoom", i2), this;
}, transform(t2, e2, i2) {
  if (e2 = t2.relative || e2, this._isDeclarative && !e2 && this._tryRetarget("transform", t2))
    return this;
  const a2 = vt.isMatrixLike(t2);
  i2 = t2.affine != null ? t2.affine : i2 != null ? i2 : !a2;
  const s2 = new He(this._stepper).type(i2 ? Fe : vt);
  let r2, n2, o2, l2, h2;
  return this.queue(function() {
    n2 = n2 || this.element(), r2 = r2 || T(t2, n2), h2 = new vt(e2 ? undefined : n2), n2._addRunner(this), e2 || n2._clearTransformRunnersBefore(this);
  }, function(c2) {
    e2 || this.clearTransform();
    const { x: d2, y: u2 } = new bt(r2).transform(n2._currentTransform(this));
    let g2 = new vt({ ...t2, origin: [d2, u2] }), p2 = this._isDeclarative && o2 ? o2 : h2;
    if (i2) {
      g2 = g2.decompose(d2, u2), p2 = p2.decompose(d2, u2);
      const t3 = g2.rotate, e3 = p2.rotate, i3 = [t3 - 360, t3, t3 + 360], a3 = i3.map((t4) => Math.abs(t4 - e3)), s3 = Math.min(...a3), r3 = a3.indexOf(s3);
      g2.rotate = i3[r3];
    }
    e2 && (a2 || (g2.rotate = t2.rotate || 0), this._isDeclarative && l2 && (p2.rotate = l2)), s2.from(p2), s2.to(g2);
    const f2 = s2.at(c2);
    return l2 = f2.rotate, o2 = new vt(f2), this.addTransform(o2), n2._addRunner(this), s2.done();
  }, function(e3) {
    (e3.origin || "center").toString() !== (t2.origin || "center").toString() && (r2 = T(e3, n2)), t2 = { ...e3, origin: r2 };
  }, true), this._isDeclarative && this._rememberMorpher("transform", s2), this;
}, x(t2) {
  return this._queueNumber("x", t2);
}, y(t2) {
  return this._queueNumber("y", t2);
}, ax(t2) {
  return this._queueNumber("ax", t2);
}, ay(t2) {
  return this._queueNumber("ay", t2);
}, dx(t2 = 0) {
  return this._queueNumberDelta("x", t2);
}, dy(t2 = 0) {
  return this._queueNumberDelta("y", t2);
}, dmove(t2, e2) {
  return this.dx(t2).dy(e2);
}, _queueNumberDelta(t2, e2) {
  if (e2 = new _t(e2), this._tryRetarget(t2, e2))
    return this;
  const i2 = new He(this._stepper).to(e2);
  let a2 = null;
  return this.queue(function() {
    a2 = this.element()[t2](), i2.from(a2), i2.to(a2 + e2);
  }, function(e3) {
    return this.element()[t2](i2.at(e3)), i2.done();
  }, function(t3) {
    i2.to(a2 + new _t(t3));
  }), this._rememberMorpher(t2, i2), this;
}, _queueObject(t2, e2) {
  if (this._tryRetarget(t2, e2))
    return this;
  const i2 = new He(this._stepper).to(e2);
  return this.queue(function() {
    i2.from(this.element()[t2]());
  }, function(e3) {
    return this.element()[t2](i2.at(e3)), i2.done();
  }), this._rememberMorpher(t2, i2), this;
}, _queueNumber(t2, e2) {
  return this._queueObject(t2, new _t(e2));
}, cx(t2) {
  return this._queueNumber("cx", t2);
}, cy(t2) {
  return this._queueNumber("cy", t2);
}, move(t2, e2) {
  return this.x(t2).y(e2);
}, amove(t2, e2) {
  return this.ax(t2).ay(e2);
}, center(t2, e2) {
  return this.cx(t2).cy(e2);
}, size(t2, e2) {
  let i2;
  return t2 && e2 || (i2 = this._element.bbox()), t2 || (t2 = i2.width / i2.height * e2), e2 || (e2 = i2.height / i2.width * t2), this.width(t2).height(e2);
}, width(t2) {
  return this._queueNumber("width", t2);
}, height(t2) {
  return this._queueNumber("height", t2);
}, plot(t2, e2, i2, a2) {
  if (arguments.length === 4)
    return this.plot([t2, e2, i2, a2]);
  if (this._tryRetarget("plot", t2))
    return this;
  const s2 = new He(this._stepper).type(this._element.MorphArray).to(t2);
  return this.queue(function() {
    s2.from(this._element.array());
  }, function(t3) {
    return this._element.plot(s2.at(t3)), s2.done();
  }), this._rememberMorpher("plot", s2), this;
}, leading(t2) {
  return this._queueNumber("leading", t2);
}, viewbox(t2, e2, i2, a2) {
  return this._queueObject("viewbox", new kt(t2, e2, i2, a2));
}, update(t2) {
  return typeof t2 != "object" ? this.update({ offset: arguments[0], color: arguments[1], opacity: arguments[2] }) : (t2.opacity != null && this.attr("stop-opacity", t2.opacity), t2.color != null && this.attr("stop-color", t2.color), t2.offset != null && this.attr("offset", t2.offset), this);
} }), Q(Qe, { rx: Zt, ry: $t, from: ne, to: oe }), q(Qe, "Runner");

class si extends Vt {
  constructor(t2, e2 = t2) {
    super(G("svg", t2), e2), this.namespace();
  }
  defs() {
    return this.isRoot() ? V(this.node.querySelector("defs")) || this.put(new Ut) : this.root().defs();
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof O.window.SVGElement) && this.node.parentNode.nodeName !== "#document-fragment";
  }
  namespace() {
    return this.isRoot() ? this.attr({ xmlns: E, version: "1.1" }).attr("xmlns:xlink", H, Y) : this.root().namespace();
  }
  removeNamespace() {
    return this.attr({ xmlns: null, version: null }).attr("xmlns:xlink", null, Y).attr("xmlns:svgjs", null, Y);
  }
  root() {
    return this.isRoot() ? this : super.root();
  }
}
A({ Container: { nested: K(function() {
  return this.put(new si);
}) } }), q(si, "Svg", true);
var ri = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G("symbol", t2), e2);
  }
};
A({ Container: { symbol: K(function() {
  return this.put(new ri);
}) } }), q(ri, "Symbol");
var ni = Object.freeze({ __proto__: null, amove: function(t2, e2) {
  return this.ax(t2).ay(e2);
}, ax: function(t2) {
  return this.attr("x", t2);
}, ay: function(t2) {
  return this.attr("y", t2);
}, build: function(t2) {
  return this._build = !!t2, this;
}, center: function(t2, e2, i2 = this.bbox()) {
  return this.cx(t2, i2).cy(e2, i2);
}, cx: function(t2, e2 = this.bbox()) {
  return t2 == null ? e2.cx : this.attr("x", this.attr("x") + t2 - e2.cx);
}, cy: function(t2, e2 = this.bbox()) {
  return t2 == null ? e2.cy : this.attr("y", this.attr("y") + t2 - e2.cy);
}, length: function() {
  return this.node.getComputedTextLength();
}, move: function(t2, e2, i2 = this.bbox()) {
  return this.x(t2, i2).y(e2, i2);
}, plain: function(t2) {
  return this._build === false && this.clear(), this.node.appendChild(O.document.createTextNode(t2)), this;
}, x: function(t2, e2 = this.bbox()) {
  return t2 == null ? e2.x : this.attr("x", this.attr("x") + t2 - e2.x);
}, y: function(t2, e2 = this.bbox()) {
  return t2 == null ? e2.y : this.attr("y", this.attr("y") + t2 - e2.y);
} });

class oi extends qt {
  constructor(t2, e2 = t2) {
    super(G("text", t2), e2), this.dom.leading = this.dom.leading ?? new _t(1.3), this._rebuild = true, this._build = false;
  }
  leading(t2) {
    return t2 == null ? this.dom.leading : (this.dom.leading = new _t(t2), this.rebuild());
  }
  rebuild(t2) {
    if (typeof t2 == "boolean" && (this._rebuild = t2), this._rebuild) {
      const t3 = this;
      let e2 = 0;
      const i2 = this.dom.leading;
      this.each(function(a2) {
        if (X(this.node))
          return;
        const s2 = O.window.getComputedStyle(this.node).getPropertyValue("font-size"), r2 = i2 * new _t(s2);
        this.dom.newLined && (this.attr("x", t3.attr("x")), this.text() === "\n" ? e2 += r2 : (this.attr("dy", a2 ? r2 + e2 : 0), e2 = 0));
      }), this.fire("rebuild");
    }
    return this;
  }
  setData(t2) {
    return this.dom = t2, this.dom.leading = new _t(t2.leading || 1.3), this;
  }
  writeDataToDom() {
    return R(this, this.dom, { leading: 1.3 }), this;
  }
  text(t2) {
    if (t2 === undefined) {
      const e2 = this.node.childNodes;
      let i2 = 0;
      t2 = "";
      for (let a2 = 0, s2 = e2.length;a2 < s2; ++a2)
        e2[a2].nodeName === "textPath" || X(e2[a2]) ? a2 === 0 && (i2 = a2 + 1) : (a2 !== i2 && e2[a2].nodeType !== 3 && V(e2[a2]).dom.newLined === true && (t2 += "\n"), t2 += e2[a2].textContent);
      return t2;
    }
    if (this.clear().build(true), typeof t2 == "function")
      t2.call(this, this);
    else
      for (let e2 = 0, i2 = (t2 = (t2 + "").split("\n")).length;e2 < i2; e2++)
        this.newLine(t2[e2]);
    return this.build(false).rebuild();
  }
}
Q(oi, ni), A({ Container: { text: K(function(t2 = "") {
  return this.put(new oi).text(t2);
}), plain: K(function(t2 = "") {
  return this.put(new oi).plain(t2);
}) } }), q(oi, "Text");

class li extends qt {
  constructor(t2, e2 = t2) {
    super(G("tspan", t2), e2), this._build = false;
  }
  dx(t2) {
    return this.attr("dx", t2);
  }
  dy(t2) {
    return this.attr("dy", t2);
  }
  newLine() {
    this.dom.newLined = true;
    const t2 = this.parent();
    if (!(t2 instanceof oi))
      return this;
    const e2 = t2.index(this), i2 = O.window.getComputedStyle(this.node).getPropertyValue("font-size"), a2 = t2.dom.leading * new _t(i2);
    return this.dy(e2 ? a2 : 0).attr("x", t2.x());
  }
  text(t2) {
    return t2 == null ? this.node.textContent + (this.dom.newLined ? "\n" : "") : (typeof t2 == "function" ? (this.clear().build(true), t2.call(this, this), this.build(false)) : this.plain(t2), this);
  }
}
Q(li, ni), A({ Tspan: { tspan: K(function(t2 = "") {
  const e2 = new li;
  return this._build || this.clear(), this.put(e2).text(t2);
}) }, Text: { newLine: function(t2 = "") {
  return this.tspan(t2).newLine();
} } }), q(li, "Tspan");

class hi extends qt {
  constructor(t2, e2 = t2) {
    super(G("circle", t2), e2);
  }
  radius(t2) {
    return this.attr("r", t2);
  }
  rx(t2) {
    return this.attr("r", t2);
  }
  ry(t2) {
    return this.rx(t2);
  }
  size(t2) {
    return this.radius(new _t(t2).divide(2));
  }
}
Q(hi, { x: Jt, y: Qt, cx: Kt, cy: te, width: ee, height: ie }), A({ Container: { circle: K(function(t2 = 0) {
  return this.put(new hi).size(t2).move(0, 0);
}) } }), q(hi, "Circle");

class ci extends Vt {
  constructor(t2, e2 = t2) {
    super(G("clipPath", t2), e2);
  }
  remove() {
    return this.targets().forEach(function(t2) {
      t2.unclip();
    }), super.remove();
  }
  targets() {
    return Lt("svg [clip-path*=" + this.id() + "]");
  }
}
A({ Container: { clip: K(function() {
  return this.defs().put(new ci);
}) }, Element: { clipper() {
  return this.reference("clip-path");
}, clipWith(t2) {
  const e2 = t2 instanceof ci ? t2 : this.parent().clip().add(t2);
  return this.attr("clip-path", "url(#" + e2.id() + ")");
}, unclip() {
  return this.attr("clip-path", null);
} } }), q(ci, "ClipPath");

class di extends Gt {
  constructor(t2, e2 = t2) {
    super(G("foreignObject", t2), e2);
  }
}
A({ Container: { foreignObject: K(function(t2, e2) {
  return this.put(new di).size(t2, e2);
}) } }), q(di, "ForeignObject");
var ui = Object.freeze({ __proto__: null, dmove: function(t2, e2) {
  return this.children().forEach((i2) => {
    let a2;
    try {
      a2 = i2.node instanceof F().SVGSVGElement ? new kt(i2.attr(["x", "y", "width", "height"])) : i2.bbox();
    } catch (t3) {
      return;
    }
    const s2 = new vt(i2), r2 = s2.translate(t2, e2).transform(s2.inverse()), n2 = new bt(a2.x, a2.y).transform(r2);
    i2.move(n2.x, n2.y);
  }), this;
}, dx: function(t2) {
  return this.dmove(t2, 0);
}, dy: function(t2) {
  return this.dmove(0, t2);
}, height: function(t2, e2 = this.bbox()) {
  return t2 == null ? e2.height : this.size(e2.width, t2, e2);
}, move: function(t2 = 0, e2 = 0, i2 = this.bbox()) {
  const a2 = t2 - i2.x, s2 = e2 - i2.y;
  return this.dmove(a2, s2);
}, size: function(t2, e2, i2 = this.bbox()) {
  const a2 = I(this, t2, e2, i2), s2 = a2.width / i2.width, r2 = a2.height / i2.height;
  return this.children().forEach((t3) => {
    const e3 = new bt(i2).transform(new vt(t3).inverse());
    t3.scale(s2, r2, e3.x, e3.y);
  }), this;
}, width: function(t2, e2 = this.bbox()) {
  return t2 == null ? e2.width : this.size(t2, e2.height, e2);
}, x: function(t2, e2 = this.bbox()) {
  return t2 == null ? e2.x : this.move(t2, e2.y, e2);
}, y: function(t2, e2 = this.bbox()) {
  return t2 == null ? e2.y : this.move(e2.x, t2, e2);
} });

class gi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("g", t2), e2);
  }
}
Q(gi, ui), A({ Container: { group: K(function() {
  return this.put(new gi);
}) } }), q(gi, "G");

class pi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("a", t2), e2);
  }
  target(t2) {
    return this.attr("target", t2);
  }
  to(t2) {
    return this.attr("href", t2, H);
  }
}
Q(pi, ui), A({ Container: { link: K(function(t2) {
  return this.put(new pi).to(t2);
}) }, Element: { unlink() {
  const t2 = this.linker();
  if (!t2)
    return this;
  const e2 = t2.parent();
  if (!e2)
    return this.remove();
  const i2 = e2.index(t2);
  return e2.add(this, i2), t2.remove(), this;
}, linkTo(t2) {
  let e2 = this.linker();
  return e2 || (e2 = new pi, this.wrap(e2)), typeof t2 == "function" ? t2.call(e2, e2) : e2.to(t2), this;
}, linker() {
  const t2 = this.parent();
  return t2 && t2.node.nodeName.toLowerCase() === "a" ? t2 : null;
} } }), q(pi, "A");

class fi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("mask", t2), e2);
  }
  remove() {
    return this.targets().forEach(function(t2) {
      t2.unmask();
    }), super.remove();
  }
  targets() {
    return Lt("svg [mask*=" + this.id() + "]");
  }
}
A({ Container: { mask: K(function() {
  return this.defs().put(new fi);
}) }, Element: { masker() {
  return this.reference("mask");
}, maskWith(t2) {
  const e2 = t2 instanceof fi ? t2 : this.parent().mask().add(t2);
  return this.attr("mask", "url(#" + e2.id() + ")");
}, unmask() {
  return this.attr("mask", null);
} } }), q(fi, "Mask");

class xi extends Gt {
  constructor(t2, e2 = t2) {
    super(G("stop", t2), e2);
  }
  update(t2) {
    return (typeof t2 == "number" || t2 instanceof _t) && (t2 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), t2.opacity != null && this.attr("stop-opacity", t2.opacity), t2.color != null && this.attr("stop-color", t2.color), t2.offset != null && this.attr("offset", new _t(t2.offset)), this;
  }
}
A({ Gradient: { stop: function(t2, e2, i2) {
  return this.put(new xi).update(t2, e2, i2);
} } }), q(xi, "Stop");

class bi extends Gt {
  constructor(t2, e2 = t2) {
    super(G("style", t2), e2);
  }
  addText(t2 = "") {
    return this.node.textContent += t2, this;
  }
  font(t2, e2, i2 = {}) {
    return this.rule("@font-face", { fontFamily: t2, src: e2, ...i2 });
  }
  rule(t2, e2) {
    return this.addText(function(t3, e3) {
      if (!t3)
        return "";
      if (!e3)
        return t3;
      let i2 = t3 + "{";
      for (const t4 in e3)
        i2 += t4.replace(/([A-Z])/g, function(t5, e4) {
          return "-" + e4.toLowerCase();
        }) + ":" + e3[t4] + ";";
      return i2 += "}", i2;
    }(t2, e2));
  }
}
A("Dom", { style(t2, e2) {
  return this.put(new bi).rule(t2, e2);
}, fontface(t2, e2, i2) {
  return this.put(new bi).font(t2, e2, i2);
} }), q(bi, "Style");

class mi extends oi {
  constructor(t2, e2 = t2) {
    super(G("textPath", t2), e2);
  }
  array() {
    const t2 = this.track();
    return t2 ? t2.array() : null;
  }
  plot(t2) {
    const e2 = this.track();
    let i2 = null;
    return e2 && (i2 = e2.plot(t2)), t2 == null ? i2 : this;
  }
  track() {
    return this.reference("href");
  }
}
A({ Container: { textPath: K(function(t2, e2) {
  return t2 instanceof oi || (t2 = this.text(t2)), t2.path(e2);
}) }, Text: { path: K(function(t2, e2 = true) {
  const i2 = new mi;
  let a2;
  if (t2 instanceof We || (t2 = this.defs().path(t2)), i2.attr("href", "#" + t2, H), e2)
    for (;a2 = this.node.firstChild; )
      i2.node.appendChild(a2);
  return this.put(i2);
}), textPath() {
  return this.findOne("textPath");
} }, Path: { text: K(function(t2) {
  return t2 instanceof oi || (t2 = new oi().addTo(this.parent()).text(t2)), t2.path(this);
}), targets() {
  return Lt("svg textPath").filter((t2) => (t2.attr("href") || "").includes(this.id()));
} } }), mi.prototype.MorphArray = Ee, q(mi, "TextPath");

class vi extends qt {
  constructor(t2, e2 = t2) {
    super(G("use", t2), e2);
  }
  use(t2, e2) {
    return this.attr("href", (e2 || "") + "#" + t2, H);
  }
}
A({ Container: { use: K(function(t2, e2) {
  return this.put(new vi).use(t2, e2);
}) } }), q(vi, "Use");
var yi = B;
Q([si, ri, de, ce, be], C("viewbox")), Q([xe, je, Ge, We], C("marker")), Q(oi, C("Text")), Q(We, C("Path")), Q(Ut, C("Defs")), Q([oi, li], C("Tspan")), Q([Ve, se, he, Qe], C("radius")), Q(Rt, C("EventTarget")), Q(Bt, C("Dom")), Q(Gt, C("Element")), Q(qt, C("Shape")), Q([Vt, re], C("Container")), Q(he, C("Gradient")), Q(Qe, C("Runner")), Ct.extend([...new Set(k)]), function(t2 = []) {
  Ne.push(...[].concat(t2));
}([_t, xt, kt, vt, Dt, ge, Ee, bt]), Q(Ne, { to(t2) {
  return new He().type(this.constructor).from(this.toArray()).to(t2);
}, fromArray(t2) {
  return this.init(t2), this;
}, toConsumable() {
  return this.toArray();
}, morph(t2, e2, i2, a2, s2) {
  return this.fromArray(t2.map(function(t3, r2) {
    return a2.step(t3, e2[r2], i2, s2[r2], s2);
  }));
} });

class wi extends Gt {
  constructor(t2) {
    super(G("filter", t2), t2), this.$source = "SourceGraphic", this.$sourceAlpha = "SourceAlpha", this.$background = "BackgroundImage", this.$backgroundAlpha = "BackgroundAlpha", this.$fill = "FillPaint", this.$stroke = "StrokePaint", this.$autoSetIn = true;
  }
  put(t2, e2) {
    return !(t2 = super.put(t2, e2)).attr("in") && this.$autoSetIn && t2.attr("in", this.$source), t2.attr("result") || t2.attr("result", t2.id()), t2;
  }
  remove() {
    return this.targets().each("unfilter"), super.remove();
  }
  targets() {
    return Lt('svg [filter*="' + this.id() + '"]');
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
}

class ki extends Gt {
  constructor(t2, e2) {
    super(t2, e2), this.result(this.id());
  }
  in(t2) {
    if (t2 == null) {
      const t3 = this.attr("in");
      return this.parent() && this.parent().find(`[result="${t3}"]`)[0] || t3;
    }
    return this.attr("in", t2);
  }
  result(t2) {
    return this.attr("result", t2);
  }
  toString() {
    return this.result();
  }
}
var Ai = (t2) => function(...e2) {
  for (let i2 = t2.length;i2--; )
    e2[i2] != null && this.attr(t2[i2], e2[i2]);
};
var Ci = { blend: Ai(["in", "in2", "mode"]), colorMatrix: Ai(["type", "values"]), composite: Ai(["in", "in2", "operator"]), convolveMatrix: function(t2) {
  t2 = new Dt(t2).toString(), this.attr({ order: Math.sqrt(t2.split(" ").length), kernelMatrix: t2 });
}, diffuseLighting: Ai(["surfaceScale", "lightingColor", "diffuseConstant", "kernelUnitLength"]), displacementMap: Ai(["in", "in2", "scale", "xChannelSelector", "yChannelSelector"]), dropShadow: Ai(["in", "dx", "dy", "stdDeviation"]), flood: Ai(["flood-color", "flood-opacity"]), gaussianBlur: function(t2 = 0, e2 = t2) {
  this.attr("stdDeviation", t2 + " " + e2);
}, image: function(t2) {
  this.attr("href", t2, H);
}, morphology: Ai(["operator", "radius"]), offset: Ai(["dx", "dy"]), specularLighting: Ai(["surfaceScale", "lightingColor", "diffuseConstant", "specularExponent", "kernelUnitLength"]), tile: Ai([]), turbulence: Ai(["baseFrequency", "numOctaves", "seed", "stitchTiles", "type"]) };
["blend", "colorMatrix", "componentTransfer", "composite", "convolveMatrix", "diffuseLighting", "displacementMap", "dropShadow", "flood", "gaussianBlur", "image", "merge", "morphology", "offset", "specularLighting", "tile", "turbulence"].forEach((t2) => {
  const e2 = P(t2), i2 = Ci[t2];
  wi[e2 + "Effect"] = class extends ki {
    constructor(t3) {
      super(G("fe" + e2, t3), t3);
    }
    update(t3) {
      return i2.apply(this, t3), this;
    }
  }, wi.prototype[t2] = K(function(t3, ...i3) {
    const a2 = new wi[e2 + "Effect"];
    return t3 == null ? this.put(a2) : (typeof t3 == "function" ? t3.call(a2, a2) : i3.unshift(t3), this.put(a2).update(i3));
  });
}), Q(wi, { merge(t2) {
  const e2 = this.put(new wi.MergeEffect);
  if (typeof t2 == "function")
    return t2.call(e2, e2), e2;
  return (t2 instanceof Array ? t2 : [...arguments]).forEach((t3) => {
    t3 instanceof wi.MergeNode ? e2.put(t3) : e2.mergeNode(t3);
  }), e2;
}, componentTransfer(t2 = {}) {
  const e2 = this.put(new wi.ComponentTransferEffect);
  if (typeof t2 == "function")
    return t2.call(e2, e2), e2;
  if (!(t2.r || t2.g || t2.b || t2.a)) {
    t2 = { r: t2, g: t2, b: t2, a: t2 };
  }
  for (const i2 in t2)
    e2.add(new wi["Func" + i2.toUpperCase()](t2[i2]));
  return e2;
} });
["distantLight", "pointLight", "spotLight", "mergeNode", "FuncR", "FuncG", "FuncB", "FuncA"].forEach((t2) => {
  const e2 = P(t2);
  wi[e2] = class extends ki {
    constructor(t3) {
      super(G("fe" + e2, t3), t3);
    }
  };
});
["funcR", "funcG", "funcB", "funcA"].forEach(function(t2) {
  const e2 = wi[P(t2)], i2 = K(function() {
    return this.put(new e2);
  });
  wi.ComponentTransferEffect.prototype[t2] = i2;
});
["distantLight", "pointLight", "spotLight"].forEach((t2) => {
  const e2 = wi[P(t2)], i2 = K(function() {
    return this.put(new e2);
  });
  wi.DiffuseLightingEffect.prototype[t2] = i2, wi.SpecularLightingEffect.prototype[t2] = i2;
}), Q(wi.MergeEffect, { mergeNode(t2) {
  return this.put(new wi.MergeNode).attr("in", t2);
} }), Q(Ut, { filter: function(t2) {
  const e2 = this.put(new wi);
  return typeof t2 == "function" && t2.call(e2, e2), e2;
} }), Q(Vt, { filter: function(t2) {
  return this.defs().filter(t2);
} }), Q(Gt, { filterWith: function(t2) {
  const e2 = t2 instanceof wi ? t2 : this.defs().filter(t2);
  return this.attr("filter", e2);
}, unfilter: function(t2) {
  return this.attr("filter", null);
}, filterer() {
  return this.reference("filter");
} });
var Si = { blend: function(t2, e2) {
  return this.parent() && this.parent().blend(this, t2, e2);
}, colorMatrix: function(t2, e2) {
  return this.parent() && this.parent().colorMatrix(t2, e2).in(this);
}, componentTransfer: function(t2) {
  return this.parent() && this.parent().componentTransfer(t2).in(this);
}, composite: function(t2, e2) {
  return this.parent() && this.parent().composite(this, t2, e2);
}, convolveMatrix: function(t2) {
  return this.parent() && this.parent().convolveMatrix(t2).in(this);
}, diffuseLighting: function(t2, e2, i2, a2) {
  return this.parent() && this.parent().diffuseLighting(t2, i2, a2).in(this);
}, displacementMap: function(t2, e2, i2, a2) {
  return this.parent() && this.parent().displacementMap(this, t2, e2, i2, a2);
}, dropShadow: function(t2, e2, i2) {
  return this.parent() && this.parent().dropShadow(this, t2, e2, i2).in(this);
}, flood: function(t2, e2) {
  return this.parent() && this.parent().flood(t2, e2);
}, gaussianBlur: function(t2, e2) {
  return this.parent() && this.parent().gaussianBlur(t2, e2).in(this);
}, image: function(t2) {
  return this.parent() && this.parent().image(t2);
}, merge: function(t2) {
  return t2 = t2 instanceof Array ? t2 : [...t2], this.parent() && this.parent().merge(this, ...t2);
}, morphology: function(t2, e2) {
  return this.parent() && this.parent().morphology(t2, e2).in(this);
}, offset: function(t2, e2) {
  return this.parent() && this.parent().offset(t2, e2).in(this);
}, specularLighting: function(t2, e2, i2, a2, s2) {
  return this.parent() && this.parent().specularLighting(t2, i2, a2, s2).in(this);
}, tile: function() {
  return this.parent() && this.parent().tile().in(this);
}, turbulence: function(t2, e2, i2, a2, s2) {
  return this.parent() && this.parent().turbulence(t2, e2, i2, a2, s2).in(this);
} };
Q(ki, Si), Q(wi.MergeEffect, { in: function(t2) {
  return t2 instanceof wi.MergeNode ? this.add(t2, 0) : this.add(new wi.MergeNode().in(t2), 0), this;
} }), Q([wi.CompositeEffect, wi.BlendEffect, wi.DisplacementMapEffect], { in2: function(t2) {
  if (t2 == null) {
    const t3 = this.attr("in2");
    return this.parent() && this.parent().find(`[result="${t3}"]`)[0] || t3;
  }
  return this.attr("in2", t2);
} }), wi.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
var Li = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getDefaultFilter", value: function(t3, e2) {
    var i2 = this.w;
    t3.unfilter(true), new wi().size("120%", "180%", "-5%", "-40%"), i2.config.chart.dropShadow.enabled && this.dropShadow(t3, i2.config.chart.dropShadow, e2);
  } }, { key: "applyFilter", value: function(t3, e2, i2) {
    var a2, s2 = this, r2 = this.w;
    if (t3.unfilter(true), i2 !== "none") {
      var n2, o2, l2 = r2.config.chart.dropShadow, h2 = i2 === "lighten" ? 2 : 0.3;
      if (t3.filterWith(function(t4) {
        t4.colorMatrix({ type: "matrix", values: "\n          ".concat(h2, " 0 0 0 0\n          0 ").concat(h2, " 0 0 0\n          0 0 ").concat(h2, " 0 0\n          0 0 0 1 0\n        "), in: "SourceGraphic", result: "brightness" }), l2.enabled && s2.addShadow(t4, e2, l2, "brightness");
      }), !l2.noUserSpaceOnUse)
        (n2 = t3.filterer()) === null || n2 === undefined || (o2 = n2.node) === null || o2 === undefined || o2.setAttribute("filterUnits", "userSpaceOnUse");
      this._scaleFilterSize((a2 = t3.filterer()) === null || a2 === undefined ? undefined : a2.node);
    } else
      this.getDefaultFilter(t3, e2);
  } }, { key: "addShadow", value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w, n2 = i2.blur, o2 = i2.top, l2 = i2.left, h2 = i2.color, c2 = i2.opacity;
    if (h2 = Array.isArray(h2) ? h2[e2] : h2, ((s2 = r2.config.chart.dropShadow.enabledOnSeries) === null || s2 === undefined ? undefined : s2.length) > 0 && r2.config.chart.dropShadow.enabledOnSeries.indexOf(e2) === -1)
      return t3;
    t3.offset({ in: a2, dx: l2, dy: o2, result: "offset" }), t3.gaussianBlur({ in: "offset", stdDeviation: n2, result: "blur" }), t3.flood({ "flood-color": h2, "flood-opacity": c2, result: "flood" }), t3.composite({ in: "flood", in2: "blur", operator: "in", result: "shadow" }), t3.merge(["shadow", a2]);
  } }, { key: "dropShadow", value: function(t3, e2) {
    var i2, a2, s2, r2, n2, o2 = this, l2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0, h2 = this.w;
    if (t3.unfilter(true), v.isMsEdge() && h2.config.chart.type === "radialBar")
      return t3;
    if (((i2 = h2.config.chart.dropShadow.enabledOnSeries) === null || i2 === undefined ? undefined : i2.length) > 0 && ((s2 = h2.config.chart.dropShadow.enabledOnSeries) === null || s2 === undefined ? undefined : s2.indexOf(l2)) === -1)
      return t3;
    (t3.filterWith(function(t4) {
      o2.addShadow(t4, l2, e2, "SourceGraphic");
    }), e2.noUserSpaceOnUse) || ((r2 = t3.filterer()) === null || r2 === undefined || (n2 = r2.node) === null || n2 === undefined || n2.setAttribute("filterUnits", "userSpaceOnUse"));
    return this._scaleFilterSize((a2 = t3.filterer()) === null || a2 === undefined ? undefined : a2.node), t3;
  } }, { key: "setSelectionFilter", value: function(t3, e2, i2) {
    var a2 = this.w;
    if (a2.globals.selectedDataPoints[e2] !== undefined && a2.globals.selectedDataPoints[e2].indexOf(i2) > -1) {
      t3.node.setAttribute("selected", true);
      var s2 = a2.config.states.active.filter;
      s2 !== "none" && this.applyFilter(t3, e2, s2.type);
    }
  } }, { key: "_scaleFilterSize", value: function(t3) {
    if (t3) {
      (function(e2) {
        for (var i2 in e2)
          e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
      })({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    }
  } }]), t2;
}();
var Mi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "roundPathCorners", value: function(t3, e2) {
    function i2(t4, e3, i3) {
      var s3 = e3.x - t4.x, r3 = e3.y - t4.y, n3 = Math.sqrt(s3 * s3 + r3 * r3);
      return a2(t4, e3, Math.min(1, i3 / n3));
    }
    function a2(t4, e3, i3) {
      return { x: t4.x + (e3.x - t4.x) * i3, y: t4.y + (e3.y - t4.y) * i3 };
    }
    function s2(t4, e3) {
      t4.length > 2 && (t4[t4.length - 2] = e3.x, t4[t4.length - 1] = e3.y);
    }
    function r2(t4) {
      return { x: parseFloat(t4[t4.length - 2]), y: parseFloat(t4[t4.length - 1]) };
    }
    t3.indexOf("NaN") > -1 && (t3 = "");
    var n2 = t3.split(/[,\s]/).reduce(function(t4, e3) {
      var i3 = e3.match("([a-zA-Z])(.+)");
      return i3 ? (t4.push(i3[1]), t4.push(i3[2])) : t4.push(e3), t4;
    }, []).reduce(function(t4, e3) {
      return parseFloat(e3) == e3 && t4.length ? t4[t4.length - 1].push(e3) : t4.push([e3]), t4;
    }, []), o2 = [];
    if (n2.length > 1) {
      var l2 = r2(n2[0]), h2 = null;
      n2[n2.length - 1][0] == "Z" && n2[0].length > 2 && (h2 = ["L", l2.x, l2.y], n2[n2.length - 1] = h2), o2.push(n2[0]);
      for (var c2 = 1;c2 < n2.length; c2++) {
        var d2 = o2[o2.length - 1], u2 = n2[c2], g2 = u2 == h2 ? n2[1] : n2[c2 + 1];
        if (g2 && d2 && d2.length > 2 && u2[0] == "L" && g2.length > 2 && g2[0] == "L") {
          var p2, f2, x2 = r2(d2), b2 = r2(u2), m2 = r2(g2);
          p2 = i2(b2, x2, e2), f2 = i2(b2, m2, e2), s2(u2, p2), u2.origPoint = b2, o2.push(u2);
          var v2 = a2(p2, b2, 0.5), y2 = a2(b2, f2, 0.5), w2 = ["C", v2.x, v2.y, y2.x, y2.y, f2.x, f2.y];
          w2.origPoint = b2, o2.push(w2);
        } else
          o2.push(u2);
      }
      if (h2) {
        var k2 = r2(o2[o2.length - 1]);
        o2.push(["Z"]), s2(o2[0], k2);
      }
    } else
      o2 = n2;
    return o2.reduce(function(t4, e3) {
      return t4 + e3.join(" ") + " ";
    }, "");
  } }, { key: "drawLine", value: function(t3, e2, i2, a2) {
    var s2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "#a8a8a8", r2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0, n2 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null, o2 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : "butt";
    return this.w.globals.dom.Paper.line().attr({ x1: t3, y1: e2, x2: i2, y2: a2, stroke: s2, "stroke-dasharray": r2, "stroke-width": n2, "stroke-linecap": o2 });
  } }, { key: "drawRect", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0, e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0, i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0, a2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0, s2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0, r2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "#fefefe", n2 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1, o2 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null, l2 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null, h2 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0, c2 = this.w.globals.dom.Paper.rect();
    return c2.attr({ x: t3, y: e2, width: i2 > 0 ? i2 : 0, height: a2 > 0 ? a2 : 0, rx: s2, ry: s2, opacity: n2, "stroke-width": o2 !== null ? o2 : 0, stroke: l2 !== null ? l2 : "none", "stroke-dasharray": h2 }), c2.node.setAttribute("fill", r2), c2;
  } }, { key: "drawPolygon", value: function(t3) {
    var e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#e1e1e1", i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1, a2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "none";
    return this.w.globals.dom.Paper.polygon(t3).attr({ fill: a2, stroke: e2, "stroke-width": i2 });
  } }, { key: "drawCircle", value: function(t3) {
    var e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    t3 < 0 && (t3 = 0);
    var i2 = this.w.globals.dom.Paper.circle(2 * t3);
    return e2 !== null && i2.attr(e2), i2;
  } }, { key: "drawPath", value: function(t3) {
    var e2 = t3.d, i2 = e2 === undefined ? "" : e2, a2 = t3.stroke, s2 = a2 === undefined ? "#a8a8a8" : a2, r2 = t3.strokeWidth, n2 = r2 === undefined ? 1 : r2, o2 = t3.fill, l2 = t3.fillOpacity, h2 = l2 === undefined ? 1 : l2, c2 = t3.strokeOpacity, d2 = c2 === undefined ? 1 : c2, u2 = t3.classes, g2 = t3.strokeLinecap, p2 = g2 === undefined ? null : g2, f2 = t3.strokeDashArray, x2 = f2 === undefined ? 0 : f2, b2 = this.w;
    return p2 === null && (p2 = b2.config.stroke.lineCap), (i2.indexOf("undefined") > -1 || i2.indexOf("NaN") > -1) && (i2 = "M 0 ".concat(b2.globals.gridHeight)), b2.globals.dom.Paper.path(i2).attr({ fill: o2, "fill-opacity": h2, stroke: s2, "stroke-opacity": d2, "stroke-linecap": p2, "stroke-width": n2, "stroke-dasharray": x2, class: u2 });
  } }, { key: "group", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null, e2 = this.w.globals.dom.Paper.group();
    return t3 !== null && e2.attr(t3), e2;
  } }, { key: "move", value: function(t3, e2) {
    var i2 = ["M", t3, e2].join(" ");
    return i2;
  } }, { key: "line", value: function(t3, e2) {
    var i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null, a2 = null;
    return i2 === null ? a2 = [" L", t3, e2].join(" ") : i2 === "H" ? a2 = [" H", t3].join(" ") : i2 === "V" && (a2 = [" V", e2].join(" ")), a2;
  } }, { key: "curve", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = ["C", t3, e2, i2, a2, s2, r2].join(" ");
    return n2;
  } }, { key: "quadraticCurve", value: function(t3, e2, i2, a2) {
    return ["Q", t3, e2, i2, a2].join(" ");
  } }, { key: "arc", value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = "A";
    arguments.length > 7 && arguments[7] !== undefined && arguments[7] && (o2 = "a");
    var l2 = [o2, t3, e2, i2, a2, s2, r2, n2].join(" ");
    return l2;
  } }, { key: "renderPaths", value: function(t3) {
    var e2, i2 = t3.j, a2 = t3.realIndex, s2 = t3.pathFrom, r2 = t3.pathTo, n2 = t3.stroke, o2 = t3.strokeWidth, l2 = t3.strokeLinecap, h2 = t3.fill, c2 = t3.animationDelay, d2 = t3.initialSpeed, g2 = t3.dataChangeSpeed, p2 = t3.className, f2 = t3.chartType, x2 = t3.shouldClipToGrid, b2 = x2 === undefined || x2, m2 = t3.bindEventsOnPaths, v2 = m2 === undefined || m2, w2 = t3.drawShadow, k2 = w2 === undefined || w2, A2 = this.w, C2 = new Li(this.ctx), S2 = new y(this.ctx), L2 = this.w.config.chart.animations.enabled, M2 = L2 && this.w.config.chart.animations.dynamicAnimation.enabled, P2 = !!(L2 && !A2.globals.resized || M2 && A2.globals.dataChanged && A2.globals.shouldAnimate);
    P2 ? e2 = s2 : (e2 = r2, A2.globals.animationEnded = true);
    var I2 = A2.config.stroke.dashArray, T2 = 0;
    T2 = Array.isArray(I2) ? I2[a2] : A2.config.stroke.dashArray;
    var z2 = this.drawPath({ d: e2, stroke: n2, strokeWidth: o2, fill: h2, fillOpacity: 1, classes: p2, strokeLinecap: l2, strokeDashArray: T2 });
    z2.attr("index", a2), b2 && (f2 === "bar" && !A2.globals.isHorizontal || A2.globals.comboCharts ? z2.attr({ "clip-path": "url(#gridRectBarMask".concat(A2.globals.cuid, ")") }) : z2.attr({ "clip-path": "url(#gridRectMask".concat(A2.globals.cuid, ")") })), A2.config.chart.dropShadow.enabled && k2 && C2.dropShadow(z2, A2.config.chart.dropShadow, a2), v2 && (z2.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z2)), z2.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z2)), z2.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z2))), z2.attr({ pathTo: r2, pathFrom: s2 });
    var X2 = { el: z2, j: i2, realIndex: a2, pathFrom: s2, pathTo: r2, fill: h2, strokeWidth: o2, delay: c2 };
    return !L2 || A2.globals.resized || A2.globals.dataChanged ? !A2.globals.resized && A2.globals.dataChanged || S2.showDelayedElements() : S2.animatePathsGradually(u(u({}, X2), {}, { speed: d2 })), A2.globals.dataChanged && M2 && P2 && S2.animatePathsGradually(u(u({}, X2), {}, { speed: g2 })), z2;
  } }, { key: "drawPattern", value: function(t3, e2, i2) {
    var a2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "#a8a8a8", s2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    return this.w.globals.dom.Paper.pattern(e2, i2, function(r2) {
      t3 === "horizontalLines" ? r2.line(0, 0, i2, 0).stroke({ color: a2, width: s2 + 1 }) : t3 === "verticalLines" ? r2.line(0, 0, 0, e2).stroke({ color: a2, width: s2 + 1 }) : t3 === "slantedLines" ? r2.line(0, 0, e2, i2).stroke({ color: a2, width: s2 }) : t3 === "squares" ? r2.rect(e2, i2).fill("none").stroke({ color: a2, width: s2 }) : t3 === "circles" && r2.circle(e2).fill("none").stroke({ color: a2, width: s2 });
    });
  } }, { key: "drawGradient", value: function(t3, e2, i2, a2, s2) {
    var r2, n2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null, o2 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null, l2 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [], h2 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0, c2 = this.w;
    e2.length < 9 && e2.indexOf("#") === 0 && (e2 = v.hexToRgba(e2, a2)), i2.length < 9 && i2.indexOf("#") === 0 && (i2 = v.hexToRgba(i2, s2));
    var d2 = 0, u2 = 1, g2 = 1, p2 = null;
    o2 !== null && (d2 = o2[0] !== undefined ? o2[0] / 100 : 0, u2 = o2[1] !== undefined ? o2[1] / 100 : 1, g2 = o2[2] !== undefined ? o2[2] / 100 : 1, p2 = o2[3] !== undefined ? o2[3] / 100 : null);
    var f2 = !(c2.config.chart.type !== "donut" && c2.config.chart.type !== "pie" && c2.config.chart.type !== "polarArea" && c2.config.chart.type !== "bubble");
    if (r2 = l2 && l2.length !== 0 ? c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
      (Array.isArray(l2[h2]) ? l2[h2] : l2).forEach(function(e3) {
        t4.stop(e3.offset / 100, e3.color, e3.opacity);
      });
    }) : c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
      t4.stop(d2, e2, a2), t4.stop(u2, i2, s2), t4.stop(g2, i2, s2), p2 !== null && t4.stop(p2, e2, a2);
    }), f2) {
      var x2 = c2.globals.gridWidth / 2, b2 = c2.globals.gridHeight / 2;
      c2.config.chart.type !== "bubble" ? r2.attr({ gradientUnits: "userSpaceOnUse", cx: x2, cy: b2, r: n2 }) : r2.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
    } else
      t3 === "vertical" ? r2.from(0, 0).to(0, 1) : t3 === "diagonal" ? r2.from(0, 0).to(1, 1) : t3 === "horizontal" ? r2.from(0, 1).to(1, 1) : t3 === "diagonal2" && r2.from(1, 0).to(0, 1);
    return r2;
  } }, { key: "getTextBasedOnMaxWidth", value: function(t3) {
    var { text: e2, maxWidth: i2, fontSize: a2, fontFamily: s2 } = t3, r2 = this.getTextRects(e2, a2, s2), n2 = r2.width / e2.length, o2 = Math.floor(i2 / n2);
    return i2 < r2.width ? e2.slice(0, o2 - 3) + "..." : e2;
  } }, { key: "drawText", value: function(t3) {
    var e2 = this, i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, n2 = t3.fontSize, o2 = t3.fontFamily, l2 = t3.fontWeight, h2 = t3.foreColor, c2 = t3.opacity, d2 = t3.maxWidth, g2 = t3.cssClass, p2 = g2 === undefined ? "" : g2, f2 = t3.isPlainText, x2 = f2 === undefined || f2, b2 = t3.dominantBaseline, m2 = b2 === undefined ? "auto" : b2, v2 = this.w;
    s2 === undefined && (s2 = "");
    var y2 = s2;
    r2 || (r2 = "start"), h2 && h2.length || (h2 = v2.config.chart.foreColor), o2 = o2 || v2.config.chart.fontFamily, l2 = l2 || "regular";
    var w2, k2 = { maxWidth: d2, fontSize: n2 = n2 || "11px", fontFamily: o2 };
    return Array.isArray(s2) ? w2 = v2.globals.dom.Paper.text(function(t4) {
      for (var i3 = 0;i3 < s2.length; i3++)
        y2 = s2[i3], d2 && (y2 = e2.getTextBasedOnMaxWidth(u({ text: s2[i3] }, k2))), i3 === 0 ? t4.tspan(y2) : t4.tspan(y2).newLine();
    }) : (d2 && (y2 = this.getTextBasedOnMaxWidth(u({ text: s2 }, k2))), w2 = x2 ? v2.globals.dom.Paper.plain(s2) : v2.globals.dom.Paper.text(function(t4) {
      return t4.tspan(y2);
    })), w2.attr({ x: i2, y: a2, "text-anchor": r2, "dominant-baseline": m2, "font-size": n2, "font-family": o2, "font-weight": l2, fill: h2, class: "apexcharts-text " + p2 }), w2.node.style.fontFamily = o2, w2.node.style.opacity = c2, w2;
  } }, { key: "getMarkerPath", value: function(t3, e2, i2, a2) {
    var s2 = "";
    switch (i2) {
      case "cross":
        s2 = "M ".concat(t3 - (a2 /= 1.4), " ").concat(e2 - a2, " L ").concat(t3 + a2, " ").concat(e2 + a2, "  M ").concat(t3 - a2, " ").concat(e2 + a2, " L ").concat(t3 + a2, " ").concat(e2 - a2);
        break;
      case "plus":
        s2 = "M ".concat(t3 - (a2 /= 1.12), " ").concat(e2, " L ").concat(t3 + a2, " ").concat(e2, "  M ").concat(t3, " ").concat(e2 - a2, " L ").concat(t3, " ").concat(e2 + a2);
        break;
      case "star":
      case "sparkle":
        var r2 = 5;
        a2 *= 1.15, i2 === "sparkle" && (a2 /= 1.1, r2 = 4);
        for (var n2 = Math.PI / r2, o2 = 0;o2 <= 2 * r2; o2++) {
          var l2 = o2 * n2, h2 = o2 % 2 == 0 ? a2 : a2 / 2;
          s2 += (o2 === 0 ? "M" : "L") + (t3 + h2 * Math.sin(l2)) + "," + (e2 - h2 * Math.cos(l2));
        }
        s2 += "Z";
        break;
      case "triangle":
        s2 = "M ".concat(t3, " ").concat(e2 - a2, " \n             L ").concat(t3 + a2, " ").concat(e2 + a2, " \n             L ").concat(t3 - a2, " ").concat(e2 + a2, " \n             Z");
        break;
      case "square":
      case "rect":
        s2 = "M ".concat(t3 - (a2 /= 1.125), " ").concat(e2 - a2, " \n           L ").concat(t3 + a2, " ").concat(e2 - a2, " \n           L ").concat(t3 + a2, " ").concat(e2 + a2, " \n           L ").concat(t3 - a2, " ").concat(e2 + a2, " \n           Z");
        break;
      case "diamond":
        a2 *= 1.05, s2 = "M ".concat(t3, " ").concat(e2 - a2, " \n             L ").concat(t3 + a2, " ").concat(e2, " \n             L ").concat(t3, " ").concat(e2 + a2, " \n             L ").concat(t3 - a2, " ").concat(e2, " \n            Z");
        break;
      case "line":
        s2 = "M ".concat(t3 - (a2 /= 1.1), " ").concat(e2, " \n           L ").concat(t3 + a2, " ").concat(e2);
        break;
      default:
        a2 *= 2, s2 = "M ".concat(t3, ", ").concat(e2, " \n           m -").concat(a2 / 2, ", 0 \n           a ").concat(a2 / 2, ",").concat(a2 / 2, " 0 1,0 ").concat(a2, ",0 \n           a ").concat(a2 / 2, ",").concat(a2 / 2, " 0 1,0 -").concat(a2, ",0");
    }
    return s2;
  } }, { key: "drawMarkerShape", value: function(t3, e2, i2, a2, s2) {
    var r2 = this.drawPath({ d: this.getMarkerPath(t3, e2, i2, a2, s2), stroke: s2.pointStrokeColor, strokeDashArray: s2.pointStrokeDashArray, strokeWidth: s2.pointStrokeWidth, fill: s2.pointFillColor, fillOpacity: s2.pointFillOpacity, strokeOpacity: s2.pointStrokeOpacity });
    return r2.attr({ cx: t3, cy: e2, shape: s2.shape, class: s2.class ? s2.class : "" }), r2;
  } }, { key: "drawMarker", value: function(t3, e2, i2) {
    t3 = t3 || 0;
    var a2 = i2.pSize || 0;
    return v.isNumber(e2) || (a2 = 0, e2 = 0), this.drawMarkerShape(t3, e2, i2 == null ? undefined : i2.shape, a2, u(u({}, i2), i2.shape === "line" || i2.shape === "plus" || i2.shape === "cross" ? { pointStrokeColor: i2.pointFillColor, pointStrokeOpacity: i2.pointFillOpacity } : {}));
  } }, { key: "pathMouseEnter", value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
    if (typeof i2.config.chart.events.dataPointMouseEnter == "function" && i2.config.chart.events.dataPointMouseEnter(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseEnter", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), (i2.config.states.active.filter.type === "none" || t3.node.getAttribute("selected") !== "true") && i2.config.states.hover.filter.type !== "none" && !i2.globals.isTouchDevice) {
      var n2 = i2.config.states.hover.filter;
      a2.applyFilter(t3, s2, n2.type);
    }
  } }, { key: "pathMouseLeave", value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
    typeof i2.config.chart.events.dataPointMouseLeave == "function" && i2.config.chart.events.dataPointMouseLeave(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseLeave", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), i2.config.states.active.filter.type !== "none" && t3.node.getAttribute("selected") === "true" || i2.config.states.hover.filter.type !== "none" && a2.getDefaultFilter(t3, s2);
  } }, { key: "pathMouseDown", value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10), n2 = "false";
    if (t3.node.getAttribute("selected") === "true") {
      if (t3.node.setAttribute("selected", "false"), i2.globals.selectedDataPoints[s2].indexOf(r2) > -1) {
        var o2 = i2.globals.selectedDataPoints[s2].indexOf(r2);
        i2.globals.selectedDataPoints[s2].splice(o2, 1);
      }
    } else {
      if (!i2.config.states.active.allowMultipleDataPointsSelection && i2.globals.selectedDataPoints.length > 0) {
        i2.globals.selectedDataPoints = [];
        var l2 = i2.globals.dom.Paper.find(".apexcharts-series path:not(.apexcharts-decoration-element)"), h2 = i2.globals.dom.Paper.find(".apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)"), c2 = function(t4) {
          Array.prototype.forEach.call(t4, function(t5) {
            t5.node.setAttribute("selected", "false"), a2.getDefaultFilter(t5, s2);
          });
        };
        c2(l2), c2(h2);
      }
      t3.node.setAttribute("selected", "true"), n2 = "true", i2.globals.selectedDataPoints[s2] === undefined && (i2.globals.selectedDataPoints[s2] = []), i2.globals.selectedDataPoints[s2].push(r2);
    }
    if (n2 === "true") {
      var d2 = i2.config.states.active.filter;
      if (d2 !== "none")
        a2.applyFilter(t3, s2, d2.type);
      else if (i2.config.states.hover.filter !== "none" && !i2.globals.isTouchDevice) {
        var u2 = i2.config.states.hover.filter;
        a2.applyFilter(t3, s2, u2.type);
      }
    } else if (i2.config.states.active.filter.type !== "none")
      if (i2.config.states.hover.filter.type === "none" || i2.globals.isTouchDevice)
        a2.getDefaultFilter(t3, s2);
      else {
        u2 = i2.config.states.hover.filter;
        a2.applyFilter(t3, s2, u2.type);
      }
    typeof i2.config.chart.events.dataPointSelection == "function" && i2.config.chart.events.dataPointSelection(e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }), e2 && this.ctx.events.fireEvent("dataPointSelection", [e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }]);
  } }, { key: "rotateAroundCenter", value: function(t3) {
    var e2 = {};
    return t3 && typeof t3.getBBox == "function" && (e2 = t3.getBBox()), { x: e2.x + e2.width / 2, y: e2.y + e2.height / 2 };
  } }, { key: "getTextRects", value: function(t3, e2, i2, a2) {
    var s2 = !(arguments.length > 4 && arguments[4] !== undefined) || arguments[4], r2 = this.w, n2 = this.drawText({ x: -200, y: -200, text: t3, textAnchor: "start", fontSize: e2, fontFamily: i2, foreColor: "#fff", opacity: 0 });
    a2 && n2.attr("transform", a2), r2.globals.dom.Paper.add(n2);
    var o2 = n2.bbox();
    return s2 || (o2 = n2.node.getBoundingClientRect()), n2.remove(), { width: o2.width, height: o2.height };
  } }, { key: "placeTextWithEllipsis", value: function(t3, e2, i2) {
    if (typeof t3.getComputedTextLength == "function" && (t3.textContent = e2, e2.length > 0 && t3.getComputedTextLength() >= i2 / 1.1)) {
      for (var a2 = e2.length - 3;a2 > 0; a2 -= 3)
        if (t3.getSubStringLength(0, a2) <= i2 / 1.1)
          return void (t3.textContent = e2.substring(0, a2) + "...");
      t3.textContent = ".";
    }
  } }], [{ key: "setAttrs", value: function(t3, e2) {
    for (var i2 in e2)
      e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
  } }]), t2;
}();
var Pi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getStackedSeriesTotals", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [], e2 = this.w, i2 = [];
    if (e2.globals.series.length === 0)
      return i2;
    for (var a2 = 0;a2 < e2.globals.series[e2.globals.maxValsInArrayIndex].length; a2++) {
      for (var s2 = 0, r2 = 0;r2 < e2.globals.series.length; r2++)
        e2.globals.series[r2][a2] !== undefined && t3.indexOf(r2) === -1 && (s2 += e2.globals.series[r2][a2]);
      i2.push(s2);
    }
    return i2;
  } }, { key: "getSeriesTotalByIndex", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return t3 === null ? this.w.config.series.reduce(function(t4, e2) {
      return t4 + e2;
    }, 0) : this.w.globals.series[t3].reduce(function(t4, e2) {
      return t4 + e2;
    }, 0);
  } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    return e2.globals.seriesGroups.forEach(function(a2) {
      var s2 = [];
      e2.config.series.forEach(function(t4, i3) {
        a2.indexOf(e2.globals.seriesNames[i3]) > -1 && s2.push(i3);
      });
      var r2 = e2.globals.series.map(function(t4, e3) {
        return s2.indexOf(e3) === -1 ? e3 : -1;
      }).filter(function(t4) {
        return t4 !== -1;
      });
      i2.push(t3.getStackedSeriesTotals(r2));
    }), i2;
  } }, { key: "setSeriesYAxisMappings", value: function() {
    var t3 = this.w.globals, e2 = this.w.config, i2 = [], a2 = [], s2 = [], r2 = t3.series.length > e2.yaxis.length || e2.yaxis.some(function(t4) {
      return Array.isArray(t4.seriesName);
    });
    e2.series.forEach(function(t4, e3) {
      s2.push(e3), a2.push(null);
    }), e2.yaxis.forEach(function(t4, e3) {
      i2[e3] = [];
    });
    var n2 = [];
    e2.yaxis.forEach(function(t4, a3) {
      var o3 = false;
      if (t4.seriesName) {
        var l3 = [];
        Array.isArray(t4.seriesName) ? l3 = t4.seriesName : l3.push(t4.seriesName), l3.forEach(function(t5) {
          e2.series.forEach(function(e3, n3) {
            if (e3.name === t5) {
              var l4 = n3;
              a3 === n3 || r2 ? !r2 || s2.indexOf(n3) > -1 ? i2[a3].push([a3, n3]) : console.warn("Series '" + e3.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i2[n3].push([n3, a3]), l4 = a3), o3 = true, (l4 = s2.indexOf(l4)) !== -1 && s2.splice(l4, 1);
            }
          });
        });
      }
      o3 || n2.push(a3);
    }), i2 = i2.map(function(t4, e3) {
      var i3 = [];
      return t4.forEach(function(t5) {
        a2[t5[1]] = t5[0], i3.push(t5[1]);
      }), i3;
    });
    for (var o2 = e2.yaxis.length - 1, l2 = 0;l2 < n2.length && (o2 = n2[l2], i2[o2] = [], s2); l2++) {
      var h2 = s2[0];
      s2.shift(), i2[o2].push(h2), a2[h2] = o2;
    }
    s2.forEach(function(t4) {
      i2[o2].push(t4), a2[t4] = o2;
    }), t3.seriesYAxisMap = i2.map(function(t4) {
      return t4;
    }), t3.seriesYAxisReverseMap = a2.map(function(t4) {
      return t4;
    }), t3.seriesYAxisMap.forEach(function(t4, i3) {
      t4.forEach(function(t5) {
        e2.series[t5] && e2.series[t5].group === undefined && (e2.series[t5].group = "apexcharts-axis-".concat(i3.toString()));
      });
    });
  } }, { key: "isSeriesNull", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return (t3 === null ? this.w.config.series.filter(function(t4) {
      return t4 !== null;
    }) : this.w.config.series[t3].data.filter(function(t4) {
      return t4 !== null;
    })).length === 0;
  } }, { key: "seriesHaveSameValues", value: function(t3) {
    return this.w.globals.series[t3].every(function(t4, e2, i2) {
      return t4 === i2[0];
    });
  } }, { key: "getCategoryLabels", value: function(t3) {
    var e2 = this.w, i2 = t3.slice();
    return e2.config.xaxis.convertedCatToNumeric && (i2 = t3.map(function(t4, i3) {
      return e2.config.xaxis.labels.formatter(t4 - e2.globals.minX + 1);
    })), i2;
  } }, { key: "getLargestSeries", value: function() {
    var t3 = this.w;
    t3.globals.maxValsInArrayIndex = t3.globals.series.map(function(t4) {
      return t4.length;
    }).indexOf(Math.max.apply(Math, t3.globals.series.map(function(t4) {
      return t4.length;
    })));
  } }, { key: "getLargestMarkerSize", value: function() {
    var t3 = this.w, e2 = 0;
    return t3.globals.markers.size.forEach(function(t4) {
      e2 = Math.max(e2, t4);
    }), t3.config.markers.discrete && t3.config.markers.discrete.length && t3.config.markers.discrete.forEach(function(t4) {
      e2 = Math.max(e2, t4.size);
    }), e2 > 0 && (t3.config.markers.hover.size > 0 ? e2 = t3.config.markers.hover.size : e2 += t3.config.markers.hover.sizeOffset), t3.globals.markers.largestSize = e2, e2;
  } }, { key: "getSeriesTotals", value: function() {
    var t3 = this.w;
    t3.globals.seriesTotals = t3.globals.series.map(function(t4, e2) {
      var i2 = 0;
      if (Array.isArray(t4))
        for (var a2 = 0;a2 < t4.length; a2++)
          i2 += t4[a2];
      else
        i2 += t4;
      return i2;
    });
  } }, { key: "getSeriesTotalsXRange", value: function(t3, e2) {
    var i2 = this.w;
    return i2.globals.series.map(function(a2, s2) {
      for (var r2 = 0, n2 = 0;n2 < a2.length; n2++)
        i2.globals.seriesX[s2][n2] > t3 && i2.globals.seriesX[s2][n2] < e2 && (r2 += a2[n2]);
      return r2;
    });
  } }, { key: "getPercentSeries", value: function() {
    var t3 = this.w;
    t3.globals.seriesPercent = t3.globals.series.map(function(e2, i2) {
      var a2 = [];
      if (Array.isArray(e2))
        for (var s2 = 0;s2 < e2.length; s2++) {
          var r2 = t3.globals.stackedSeriesTotals[s2], n2 = 0;
          r2 && (n2 = 100 * e2[s2] / r2), a2.push(n2);
        }
      else {
        var o2 = 100 * e2 / t3.globals.seriesTotals.reduce(function(t4, e3) {
          return t4 + e3;
        }, 0);
        a2.push(o2);
      }
      return a2;
    });
  } }, { key: "getCalculatedRatios", value: function() {
    var t3, e2, i2, a2 = this, s2 = this.w, r2 = s2.globals, n2 = [], o2 = 0, l2 = [], h2 = 0.1, c2 = 0;
    if (r2.yRange = [], r2.isMultipleYAxis)
      for (var d2 = 0;d2 < r2.minYArr.length; d2++)
        r2.yRange.push(Math.abs(r2.minYArr[d2] - r2.maxYArr[d2])), l2.push(0);
    else
      r2.yRange.push(Math.abs(r2.minY - r2.maxY));
    r2.xRange = Math.abs(r2.maxX - r2.minX), r2.zRange = Math.abs(r2.maxZ - r2.minZ);
    for (var u2 = 0;u2 < r2.yRange.length; u2++)
      n2.push(r2.yRange[u2] / r2.gridHeight);
    if (e2 = r2.xRange / r2.gridWidth, t3 = r2.yRange / r2.gridWidth, i2 = r2.xRange / r2.gridHeight, (o2 = r2.zRange / r2.gridHeight * 16) || (o2 = 1), r2.minY !== Number.MIN_VALUE && Math.abs(r2.minY) !== 0 && (r2.hasNegs = true), s2.globals.seriesYAxisReverseMap.length > 0) {
      var g2 = function(t4, e3) {
        var i3 = s2.config.yaxis[s2.globals.seriesYAxisReverseMap[e3]], r3 = t4 < 0 ? -1 : 1;
        return t4 = Math.abs(t4), i3.logarithmic && (t4 = a2.getBaseLog(i3.logBase, t4)), -r3 * t4 / n2[e3];
      };
      if (r2.isMultipleYAxis) {
        l2 = [];
        for (var p2 = 0;p2 < n2.length; p2++)
          l2.push(g2(r2.minYArr[p2], p2));
      } else
        (l2 = []).push(g2(r2.minY, 0)), r2.minY !== Number.MIN_VALUE && Math.abs(r2.minY) !== 0 && (h2 = -r2.minY / t3, c2 = r2.minX / e2);
    } else
      (l2 = []).push(0), h2 = 0, c2 = 0;
    return { yRatio: n2, invertedYRatio: t3, zRatio: o2, xRatio: e2, invertedXRatio: i2, baseLineInvertedY: h2, baseLineY: l2, baseLineX: c2 };
  } }, { key: "getLogSeries", value: function(t3) {
    var e2 = this, i2 = this.w;
    return i2.globals.seriesLog = t3.map(function(t4, a2) {
      var s2 = i2.globals.seriesYAxisReverseMap[a2];
      return i2.config.yaxis[s2] && i2.config.yaxis[s2].logarithmic ? t4.map(function(t5) {
        return t5 === null ? null : e2.getLogVal(i2.config.yaxis[s2].logBase, t5, a2);
      }) : t4;
    }), i2.globals.invalidLogScale ? t3 : i2.globals.seriesLog;
  } }, { key: "getLogValAtSeriesIndex", value: function(t3, e2) {
    if (t3 === null)
      return null;
    var i2 = this.w, a2 = i2.globals.seriesYAxisReverseMap[e2];
    return i2.config.yaxis[a2] && i2.config.yaxis[a2].logarithmic ? this.getLogVal(i2.config.yaxis[a2].logBase, t3, e2) : t3;
  } }, { key: "getBaseLog", value: function(t3, e2) {
    return Math.log(e2) / Math.log(t3);
  } }, { key: "getLogVal", value: function(t3, e2, i2) {
    if (e2 <= 0)
      return 0;
    var a2 = this.w, s2 = a2.globals.minYArr[i2] === 0 ? -1 : this.getBaseLog(t3, a2.globals.minYArr[i2]), r2 = (a2.globals.maxYArr[i2] === 0 ? 0 : this.getBaseLog(t3, a2.globals.maxYArr[i2])) - s2;
    return e2 < 1 ? e2 / r2 : (this.getBaseLog(t3, e2) - s2) / r2;
  } }, { key: "getLogYRatios", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = this.w.globals;
    return a2.yLogRatio = t3.slice(), a2.logYRange = a2.yRange.map(function(t4, s2) {
      var r2 = i2.globals.seriesYAxisReverseMap[s2];
      if (i2.config.yaxis[r2] && e2.w.config.yaxis[r2].logarithmic) {
        var n2, o2 = -Number.MAX_VALUE, l2 = Number.MIN_VALUE;
        return a2.seriesLog.forEach(function(t5, e3) {
          t5.forEach(function(t6) {
            i2.config.yaxis[e3] && i2.config.yaxis[e3].logarithmic && (o2 = Math.max(t6, o2), l2 = Math.min(t6, l2));
          });
        }), n2 = Math.pow(a2.yRange[s2], Math.abs(l2 - o2) / a2.yRange[s2]), a2.yLogRatio[s2] = n2 / a2.gridHeight, n2;
      }
    }), a2.invalidLogScale ? t3.slice() : a2.yLogRatio;
  } }, { key: "drawSeriesByGroup", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = [];
    return t3.series.length > 0 && e2.forEach(function(e3) {
      var n2 = [], o2 = [];
      t3.i.forEach(function(i3, a3) {
        s2.config.series[i3].group === e3 && (n2.push(t3.series[a3]), o2.push(i3));
      }), n2.length > 0 && r2.push(a2.draw(n2, i2, o2));
    }), r2;
  } }], [{ key: "checkComboSeries", value: function(t3, e2) {
    var i2 = false, a2 = 0, s2 = 0;
    return e2 === undefined && (e2 = "line"), t3.length && t3[0].type !== undefined && t3.forEach(function(t4) {
      t4.type !== "bar" && t4.type !== "column" && t4.type !== "candlestick" && t4.type !== "boxPlot" || a2++, t4.type !== undefined && t4.type !== e2 && s2++;
    }), s2 > 0 && (i2 = true), { comboBarCount: a2, comboCharts: i2 };
  } }, { key: "extendArrayProps", value: function(t3, e2, i2) {
    var a2, s2, r2, n2, o2, l2;
    ((a2 = e2) !== null && a2 !== undefined && a2.yaxis && (e2 = t3.extendYAxis(e2, i2)), (s2 = e2) !== null && s2 !== undefined && s2.annotations) && (e2.annotations.yaxis && (e2 = t3.extendYAxisAnnotations(e2)), (r2 = e2) !== null && r2 !== undefined && (n2 = r2.annotations) !== null && n2 !== undefined && n2.xaxis && (e2 = t3.extendXAxisAnnotations(e2)), (o2 = e2) !== null && o2 !== undefined && (l2 = o2.annotations) !== null && l2 !== undefined && l2.points && (e2 = t3.extendPointAnnotations(e2)));
    return e2;
  } }]), t2;
}();
var Ii = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2;
  }
  return s(t2, [{ key: "setOrientations", value: function(t3) {
    var e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null, i2 = this.w;
    if (t3.label.orientation === "vertical") {
      var a2 = e2 !== null ? e2 : 0, s2 = i2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a2, "']"));
      if (s2 !== null) {
        var r2 = s2.getBoundingClientRect();
        s2.setAttribute("x", parseFloat(s2.getAttribute("x")) - r2.height + 4);
        var n2 = t3.label.position === "top" ? r2.width : -r2.width;
        s2.setAttribute("y", parseFloat(s2.getAttribute("y")) + n2);
        var o2 = this.annoCtx.graphics.rotateAroundCenter(s2), l2 = o2.x, h2 = o2.y;
        s2.setAttribute("transform", "rotate(-90 ".concat(l2, " ").concat(h2, ")"));
      }
    }
  } }, { key: "addBackgroundToAnno", value: function(t3, e2) {
    var i2 = this.w;
    if (!t3 || !e2.label.text || !String(e2.label.text).trim())
      return null;
    var a2 = i2.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s2 = t3.getBoundingClientRect(), r2 = e2.label.style.padding, n2 = r2.left, o2 = r2.right, l2 = r2.top, h2 = r2.bottom;
    if (e2.label.orientation === "vertical") {
      var c2 = [n2, o2, l2, h2];
      l2 = c2[0], h2 = c2[1], n2 = c2[2], o2 = c2[3];
    }
    var d2 = s2.left - a2.left - n2, u2 = s2.top - a2.top - l2, g2 = this.annoCtx.graphics.drawRect(d2 - i2.globals.barPadForNumericAxis, u2, s2.width + n2 + o2, s2.height + l2 + h2, e2.label.borderRadius, e2.label.style.background, 1, e2.label.borderWidth, e2.label.borderColor, 0);
    return e2.id && g2.node.classList.add(e2.id), g2;
  } }, { key: "annotationsBackground", value: function() {
    var t3 = this, e2 = this.w, i2 = function(i3, a2, s2) {
      var r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(a2, "']"));
      if (r2) {
        var n2 = r2.parentNode, o2 = t3.addBackgroundToAnno(r2, i3);
        o2 && (n2.insertBefore(o2.node, r2), i3.label.mouseEnter && o2.node.addEventListener("mouseenter", i3.label.mouseEnter.bind(t3, i3)), i3.label.mouseLeave && o2.node.addEventListener("mouseleave", i3.label.mouseLeave.bind(t3, i3)), i3.label.click && o2.node.addEventListener("click", i3.label.click.bind(t3, i3)));
      }
    };
    e2.config.annotations.xaxis.forEach(function(t4, e3) {
      return i2(t4, e3, "xaxis");
    }), e2.config.annotations.yaxis.forEach(function(t4, e3) {
      return i2(t4, e3, "yaxis");
    }), e2.config.annotations.points.forEach(function(t4, e3) {
      return i2(t4, e3, "point");
    });
  } }, { key: "getY1Y2", value: function(t3, e2) {
    var i2, a2 = this.w, s2 = t3 === "y1" ? e2.y : e2.y2, r2 = false;
    if (this.annoCtx.invertAxis) {
      var n2 = a2.config.xaxis.convertedCatToNumeric ? a2.globals.categoryLabels : a2.globals.labels, o2 = n2.indexOf(s2), l2 = a2.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(o2 + 1, ")"));
      i2 = l2 ? parseFloat(l2.getAttribute("y")) : (a2.globals.gridHeight / n2.length - 1) * (o2 + 1) - a2.globals.barHeight, e2.seriesIndex !== undefined && a2.globals.barHeight && (i2 -= a2.globals.barHeight / 2 * (a2.globals.series.length - 1) - a2.globals.barHeight * e2.seriesIndex);
    } else {
      var h2, c2 = a2.globals.seriesYAxisMap[e2.yAxisIndex][0], d2 = a2.config.yaxis[e2.yAxisIndex].logarithmic ? new Pi(this.annoCtx.ctx).getLogVal(a2.config.yaxis[e2.yAxisIndex].logBase, s2, c2) / a2.globals.yLogRatio[c2] : (s2 - a2.globals.minYArr[c2]) / (a2.globals.yRange[c2] / a2.globals.gridHeight);
      i2 = a2.globals.gridHeight - Math.min(Math.max(d2, 0), a2.globals.gridHeight), r2 = d2 > a2.globals.gridHeight || d2 < 0, !e2.marker || e2.y !== undefined && e2.y !== null || (i2 = 0), (h2 = a2.config.yaxis[e2.yAxisIndex]) !== null && h2 !== undefined && h2.reversed && (i2 = d2);
    }
    return typeof s2 == "string" && s2.includes("px") && (i2 = parseFloat(s2)), { yP: i2, clipped: r2 };
  } }, { key: "getX1X2", value: function(t3, e2) {
    var i2 = this.w, a2 = t3 === "x1" ? e2.x : e2.x2, s2 = this.annoCtx.invertAxis ? i2.globals.minY : i2.globals.minX, r2 = this.annoCtx.invertAxis ? i2.globals.maxY : i2.globals.maxX, n2 = this.annoCtx.invertAxis ? i2.globals.yRange[0] : i2.globals.xRange, o2 = false, l2 = this.annoCtx.inversedReversedAxis ? (r2 - a2) / (n2 / i2.globals.gridWidth) : (a2 - s2) / (n2 / i2.globals.gridWidth);
    return i2.config.xaxis.type !== "category" && !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || i2.config.chart.sparkline.enabled || (l2 = this.getStringX(a2)), typeof a2 == "string" && a2.includes("px") && (l2 = parseFloat(a2)), a2 == null && e2.marker && (l2 = i2.globals.gridWidth), e2.seriesIndex !== undefined && i2.globals.barWidth && !this.annoCtx.invertAxis && (l2 -= i2.globals.barWidth / 2 * (i2.globals.series.length - 1) - i2.globals.barWidth * e2.seriesIndex), l2 > i2.globals.gridWidth ? (l2 = i2.globals.gridWidth, o2 = true) : l2 < 0 && (l2 = 0, o2 = true), { x: l2, clipped: o2 };
  } }, { key: "getStringX", value: function(t3) {
    var e2 = this.w, i2 = t3;
    e2.config.xaxis.convertedCatToNumeric && e2.globals.categoryLabels.length && (t3 = e2.globals.categoryLabels.indexOf(t3) + 1);
    var a2 = e2.globals.labels.map(function(t4) {
      return Array.isArray(t4) ? t4.join(" ") : t4;
    }).indexOf(t3), s2 = e2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(a2 + 1, ")"));
    return s2 && (i2 = parseFloat(s2.getAttribute("x"))), i2;
  } }]), t2;
}();
var Ti = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Ii(this.annoCtx);
  }
  return s(t2, [{ key: "addXaxisAnnotation", value: function(t3, e2, i2) {
    var a2, s2 = this.w, r2 = this.helpers.getX1X2("x1", t3), n2 = r2.x, o2 = r2.clipped, l2 = true, h2 = t3.label.text, c2 = t3.strokeDashArray;
    if (v.isNumber(n2)) {
      if (t3.x2 === null || t3.x2 === undefined) {
        if (!o2) {
          var d2 = this.annoCtx.graphics.drawLine(n2 + t3.offsetX, 0 + t3.offsetY, n2 + t3.offsetX, s2.globals.gridHeight + t3.offsetY, t3.borderColor, c2, t3.borderWidth);
          e2.appendChild(d2.node), t3.id && d2.node.classList.add(t3.id);
        }
      } else {
        var u2 = this.helpers.getX1X2("x2", t3);
        if (a2 = u2.x, l2 = u2.clipped, a2 < n2) {
          var g2 = n2;
          n2 = a2, a2 = g2;
        }
        var p2 = this.annoCtx.graphics.drawRect(n2 + t3.offsetX, 0 + t3.offsetY, a2 - n2, s2.globals.gridHeight + t3.offsetY, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, c2);
        p2.node.classList.add("apexcharts-annotation-rect"), p2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(p2.node), t3.id && p2.node.classList.add(t3.id);
      }
      if (!o2 || !l2) {
        var f2 = this.annoCtx.graphics.getTextRects(h2, parseFloat(t3.label.style.fontSize)), x2 = t3.label.position === "top" ? 4 : t3.label.position === "center" ? s2.globals.gridHeight / 2 + (t3.label.orientation === "vertical" ? f2.width / 2 : 0) : s2.globals.gridHeight, b2 = this.annoCtx.graphics.drawText({ x: n2 + t3.label.offsetX, y: x2 + t3.label.offsetY - (t3.label.orientation === "vertical" ? t3.label.position === "top" ? f2.width / 2 - 12 : -f2.width / 2 : 0), text: h2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        b2.attr({ rel: i2 }), e2.appendChild(b2.node), this.annoCtx.helpers.setOrientations(t3, i2);
      }
    }
  } }, { key: "drawXAxisAnnotations", value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
    return e2.config.annotations.xaxis.map(function(e3, a2) {
      t3.addXaxisAnnotation(e3, i2.node, a2);
    }), i2;
  } }]), t2;
}();
var zi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  return s(t2, [{ key: "isValidDate", value: function(t3) {
    return typeof t3 != "number" && !isNaN(this.parseDate(t3));
  } }, { key: "getTimeStamp", value: function(t3) {
    return Date.parse(t3) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toISOString().substr(0, 25)).getTime() : new Date(t3).getTime() : t3;
  } }, { key: "getDate", value: function(t3) {
    return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toUTCString()) : new Date(t3);
  } }, { key: "parseDate", value: function(t3) {
    var e2 = Date.parse(t3);
    if (!isNaN(e2))
      return this.getTimeStamp(t3);
    var i2 = Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    return i2 = this.getTimeStamp(i2);
  } }, { key: "parseDateWithTimezone", value: function(t3) {
    return Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
  } }, { key: "formatDate", value: function(t3, e2) {
    var i2 = this.w.globals.locale, a2 = this.w.config.xaxis.labels.datetimeUTC, s2 = ["\0"].concat(f(i2.months)), r2 = ["\x01"].concat(f(i2.shortMonths)), n2 = ["\x02"].concat(f(i2.days)), o2 = ["\x03"].concat(f(i2.shortDays));
    function l2(t4, e3) {
      var i3 = t4 + "";
      for (e3 = e3 || 2;i3.length < e3; )
        i3 = "0" + i3;
      return i3;
    }
    var h2 = a2 ? t3.getUTCFullYear() : t3.getFullYear();
    e2 = (e2 = (e2 = e2.replace(/(^|[^\\])yyyy+/g, "$1" + h2)).replace(/(^|[^\\])yy/g, "$1" + h2.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h2);
    var c2 = (a2 ? t3.getUTCMonth() : t3.getMonth()) + 1;
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])MMMM+/g, "$1" + s2[0])).replace(/(^|[^\\])MMM/g, "$1" + r2[0])).replace(/(^|[^\\])MM/g, "$1" + l2(c2))).replace(/(^|[^\\])M/g, "$1" + c2);
    var d2 = a2 ? t3.getUTCDate() : t3.getDate();
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])dddd+/g, "$1" + n2[0])).replace(/(^|[^\\])ddd/g, "$1" + o2[0])).replace(/(^|[^\\])dd/g, "$1" + l2(d2))).replace(/(^|[^\\])d/g, "$1" + d2);
    var u2 = a2 ? t3.getUTCHours() : t3.getHours(), g2 = u2 > 12 ? u2 - 12 : u2 === 0 ? 12 : u2;
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])HH+/g, "$1" + l2(u2))).replace(/(^|[^\\])H/g, "$1" + u2)).replace(/(^|[^\\])hh+/g, "$1" + l2(g2))).replace(/(^|[^\\])h/g, "$1" + g2);
    var p2 = a2 ? t3.getUTCMinutes() : t3.getMinutes();
    e2 = (e2 = e2.replace(/(^|[^\\])mm+/g, "$1" + l2(p2))).replace(/(^|[^\\])m/g, "$1" + p2);
    var x2 = a2 ? t3.getUTCSeconds() : t3.getSeconds();
    e2 = (e2 = e2.replace(/(^|[^\\])ss+/g, "$1" + l2(x2))).replace(/(^|[^\\])s/g, "$1" + x2);
    var b2 = a2 ? t3.getUTCMilliseconds() : t3.getMilliseconds();
    e2 = e2.replace(/(^|[^\\])fff+/g, "$1" + l2(b2, 3)), b2 = Math.round(b2 / 10), e2 = e2.replace(/(^|[^\\])ff/g, "$1" + l2(b2)), b2 = Math.round(b2 / 10);
    var m2 = u2 < 12 ? "AM" : "PM";
    e2 = (e2 = (e2 = e2.replace(/(^|[^\\])f/g, "$1" + b2)).replace(/(^|[^\\])TT+/g, "$1" + m2)).replace(/(^|[^\\])T/g, "$1" + m2.charAt(0));
    var v2 = m2.toLowerCase();
    e2 = (e2 = e2.replace(/(^|[^\\])tt+/g, "$1" + v2)).replace(/(^|[^\\])t/g, "$1" + v2.charAt(0));
    var y2 = -t3.getTimezoneOffset(), w2 = a2 || !y2 ? "Z" : y2 > 0 ? "+" : "-";
    if (!a2) {
      var k2 = (y2 = Math.abs(y2)) % 60;
      w2 += l2(Math.floor(y2 / 60)) + ":" + l2(k2);
    }
    e2 = e2.replace(/(^|[^\\])K/g, "$1" + w2);
    var A2 = (a2 ? t3.getUTCDay() : t3.getDay()) + 1;
    return e2 = (e2 = (e2 = (e2 = (e2 = e2.replace(new RegExp(n2[0], "g"), n2[A2])).replace(new RegExp(o2[0], "g"), o2[A2])).replace(new RegExp(s2[0], "g"), s2[c2])).replace(new RegExp(r2[0], "g"), r2[c2])).replace(/\\(.)/g, "$1");
  } }, { key: "getTimeUnitsfromTimestamp", value: function(t3, e2, i2) {
    var a2 = this.w;
    a2.config.xaxis.min !== undefined && (t3 = a2.config.xaxis.min), a2.config.xaxis.max !== undefined && (e2 = a2.config.xaxis.max);
    var s2 = this.getDate(t3), r2 = this.getDate(e2), n2 = this.formatDate(s2, "yyyy MM dd HH mm ss fff").split(" "), o2 = this.formatDate(r2, "yyyy MM dd HH mm ss fff").split(" ");
    return { minMillisecond: parseInt(n2[6], 10), maxMillisecond: parseInt(o2[6], 10), minSecond: parseInt(n2[5], 10), maxSecond: parseInt(o2[5], 10), minMinute: parseInt(n2[4], 10), maxMinute: parseInt(o2[4], 10), minHour: parseInt(n2[3], 10), maxHour: parseInt(o2[3], 10), minDate: parseInt(n2[2], 10), maxDate: parseInt(o2[2], 10), minMonth: parseInt(n2[1], 10) - 1, maxMonth: parseInt(o2[1], 10) - 1, minYear: parseInt(n2[0], 10), maxYear: parseInt(o2[0], 10) };
  } }, { key: "isLeapYear", value: function(t3) {
    return t3 % 4 == 0 && t3 % 100 != 0 || t3 % 400 == 0;
  } }, { key: "calculcateLastDaysOfMonth", value: function(t3, e2, i2) {
    return this.determineDaysOfMonths(t3, e2) - i2;
  } }, { key: "determineDaysOfYear", value: function(t3) {
    var e2 = 365;
    return this.isLeapYear(t3) && (e2 = 366), e2;
  } }, { key: "determineRemainingDaysOfYear", value: function(t3, e2, i2) {
    var a2 = this.daysCntOfYear[e2] + i2;
    return e2 > 1 && this.isLeapYear() && a2++, a2;
  } }, { key: "determineDaysOfMonths", value: function(t3, e2) {
    var i2 = 30;
    switch (t3 = v.monthMod(t3), true) {
      case this.months30.indexOf(t3) > -1:
        t3 === 2 && (i2 = this.isLeapYear(e2) ? 29 : 28);
        break;
      case this.months31.indexOf(t3) > -1:
      default:
        i2 = 31;
    }
    return i2;
  } }]), t2;
}();
var Xi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.tooltipKeyFormat = "dd MMM";
  }
  return s(t2, [{ key: "xLabelFormat", value: function(t3, e2, i2, a2) {
    var s2 = this.w;
    if (s2.config.xaxis.type === "datetime" && s2.config.xaxis.labels.formatter === undefined && s2.config.tooltip.x.formatter === undefined) {
      var r2 = new zi(this.ctx);
      return r2.formatDate(r2.getDate(e2), s2.config.tooltip.x.format);
    }
    return t3(e2, i2, a2);
  } }, { key: "defaultGeneralFormatter", value: function(t3) {
    return Array.isArray(t3) ? t3.map(function(t4) {
      return t4;
    }) : t3;
  } }, { key: "defaultYFormatter", value: function(t3, e2, i2) {
    var a2 = this.w;
    if (v.isNumber(t3))
      if (a2.globals.yValueDecimal !== 0)
        t3 = t3.toFixed(e2.decimalsInFloat !== undefined ? e2.decimalsInFloat : a2.globals.yValueDecimal);
      else {
        var s2 = t3.toFixed(0);
        t3 = t3 == s2 ? s2 : t3.toFixed(1);
      }
    return t3;
  } }, { key: "setLabelFormatters", value: function() {
    var t3 = this, e2 = this.w;
    return e2.globals.xaxisTooltipFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.globals.ttKeyFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.globals.ttZFormatter = function(t4) {
      return t4;
    }, e2.globals.legendFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.config.xaxis.labels.formatter !== undefined ? e2.globals.xLabelFormatter = e2.config.xaxis.labels.formatter : e2.globals.xLabelFormatter = function(t4) {
      if (v.isNumber(t4)) {
        if (!e2.config.xaxis.convertedCatToNumeric && e2.config.xaxis.type === "numeric") {
          if (v.isNumber(e2.config.xaxis.decimalsInFloat))
            return t4.toFixed(e2.config.xaxis.decimalsInFloat);
          var i2 = e2.globals.maxX - e2.globals.minX;
          return i2 > 0 && i2 < 100 ? t4.toFixed(1) : t4.toFixed(0);
        }
        if (e2.globals.isBarHorizontal) {
          if (e2.globals.maxY - e2.globals.minYArr < 4)
            return t4.toFixed(1);
        }
        return t4.toFixed(0);
      }
      return t4;
    }, typeof e2.config.tooltip.x.formatter == "function" ? e2.globals.ttKeyFormatter = e2.config.tooltip.x.formatter : e2.globals.ttKeyFormatter = e2.globals.xLabelFormatter, typeof e2.config.xaxis.tooltip.formatter == "function" && (e2.globals.xaxisTooltipFormatter = e2.config.xaxis.tooltip.formatter), (Array.isArray(e2.config.tooltip.y) || e2.config.tooltip.y.formatter !== undefined) && (e2.globals.ttVal = e2.config.tooltip.y), e2.config.tooltip.z.formatter !== undefined && (e2.globals.ttZFormatter = e2.config.tooltip.z.formatter), e2.config.legend.formatter !== undefined && (e2.globals.legendFormatter = e2.config.legend.formatter), e2.config.yaxis.forEach(function(i2, a2) {
      i2.labels.formatter !== undefined ? e2.globals.yLabelFormatters[a2] = i2.labels.formatter : e2.globals.yLabelFormatters[a2] = function(s2) {
        return e2.globals.xyCharts ? Array.isArray(s2) ? s2.map(function(e3) {
          return t3.defaultYFormatter(e3, i2, a2);
        }) : t3.defaultYFormatter(s2, i2, a2) : s2;
      };
    }), e2.globals;
  } }, { key: "heatmapLabelFormatters", value: function() {
    var t3 = this.w;
    if (t3.config.chart.type === "heatmap") {
      t3.globals.yAxisScale[0].result = t3.globals.seriesNames.slice();
      var e2 = t3.globals.seriesNames.reduce(function(t4, e3) {
        return t4.length > e3.length ? t4 : e3;
      }, 0);
      t3.globals.yAxisScale[0].niceMax = e2, t3.globals.yAxisScale[0].niceMin = e2;
    }
  } }]), t2;
}();
var Ri = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getLabel", value: function(t3, e2, i2, a2) {
    var s2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [], r2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "12px", n2 = !(arguments.length > 6 && arguments[6] !== undefined) || arguments[6], o2 = this.w, l2 = t3[a2] === undefined ? "" : t3[a2], h2 = l2, c2 = o2.globals.xLabelFormatter, d2 = o2.config.xaxis.labels.formatter, u2 = false, g2 = new Xi(this.ctx), p2 = l2;
    n2 && (h2 = g2.xLabelFormat(c2, l2, p2, { i: a2, dateFormatter: new zi(this.ctx).formatDate, w: o2 }), d2 !== undefined && (h2 = d2(l2, t3[a2], { i: a2, dateFormatter: new zi(this.ctx).formatDate, w: o2 })));
    var f2, x2;
    e2.length > 0 ? (f2 = e2[a2].unit, x2 = null, e2.forEach(function(t4) {
      t4.unit === "month" ? x2 = "year" : t4.unit === "day" ? x2 = "month" : t4.unit === "hour" ? x2 = "day" : t4.unit === "minute" && (x2 = "hour");
    }), u2 = x2 === f2, i2 = e2[a2].position, h2 = e2[a2].value) : o2.config.xaxis.type === "datetime" && d2 === undefined && (h2 = ""), h2 === undefined && (h2 = ""), h2 = Array.isArray(h2) ? h2 : h2.toString();
    var b2 = new Mi(this.ctx), m2 = {};
    m2 = o2.globals.rotateXLabels && n2 ? b2.getTextRects(h2, parseInt(r2, 10), null, "rotate(".concat(o2.config.xaxis.labels.rotate, " 0 0)"), false) : b2.getTextRects(h2, parseInt(r2, 10));
    var v2 = !o2.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
    return !Array.isArray(h2) && (String(h2) === "NaN" || s2.indexOf(h2) >= 0 && v2) && (h2 = ""), { x: i2, text: h2, textRect: m2, isBold: u2 };
  } }, { key: "checkLabelBasedOnTickamount", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.config.xaxis.tickAmount;
    return s2 === "dataPoints" && (s2 = Math.round(a2.globals.gridWidth / 120)), s2 > i2 || t3 % Math.round(i2 / (s2 + 1)) == 0 || (e2.text = ""), e2;
  } }, { key: "checkForOverflowingLabels", value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w;
    if (t3 === 0 && r2.globals.skipFirstTimelinelabel && (e2.text = ""), t3 === i2 - 1 && r2.globals.skipLastTimelinelabel && (e2.text = ""), r2.config.xaxis.labels.hideOverlappingLabels && a2.length > 0) {
      var n2 = s2[s2.length - 1];
      e2.x < n2.textRect.width / (r2.globals.rotateXLabels ? Math.abs(r2.config.xaxis.labels.rotate) / 12 : 1.01) + n2.x && (e2.text = "");
    }
    return e2;
  } }, { key: "checkForReversedLabels", value: function(t3, e2) {
    var i2 = this.w;
    return i2.config.yaxis[t3] && i2.config.yaxis[t3].reversed && e2.reverse(), e2;
  } }, { key: "yAxisAllSeriesCollapsed", value: function(t3) {
    var e2 = this.w.globals;
    return !e2.seriesYAxisMap[t3].some(function(t4) {
      return e2.collapsedSeriesIndices.indexOf(t4) === -1;
    });
  } }, { key: "translateYAxisIndex", value: function(t3) {
    var e2 = this.w, i2 = e2.globals, a2 = e2.config.yaxis;
    return i2.series.length > a2.length || a2.some(function(t4) {
      return Array.isArray(t4.seriesName);
    }) ? t3 : i2.seriesYAxisReverseMap[t3];
  } }, { key: "isYAxisHidden", value: function(t3) {
    var e2 = this.w, i2 = e2.config.yaxis[t3];
    if (!i2.show || this.yAxisAllSeriesCollapsed(t3))
      return true;
    if (!i2.showForNullSeries) {
      var a2 = e2.globals.seriesYAxisMap[t3], s2 = new Pi(this.ctx);
      return a2.every(function(t4) {
        return s2.isSeriesNull(t4);
      });
    }
    return false;
  } }, { key: "getYAxisForeColor", value: function(t3, e2) {
    var i2 = this.w;
    return Array.isArray(t3) && i2.globals.yAxisScale[e2] && this.ctx.theme.pushExtraColors(t3, i2.globals.yAxisScale[e2].result.length, false), t3;
  } }, { key: "drawYAxisTicks", value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = this.w, l2 = new Mi(this.ctx), h2 = o2.globals.translateY + o2.config.yaxis[s2].labels.offsetY;
    if (o2.globals.isBarHorizontal ? h2 = 0 : o2.config.chart.type === "heatmap" && (h2 += r2 / 2), a2.show && e2 > 0) {
      o2.config.yaxis[s2].opposite === true && (t3 += a2.width);
      for (var c2 = e2;c2 >= 0; c2--) {
        var d2 = l2.drawLine(t3 + i2.offsetX - a2.width + a2.offsetX, h2 + a2.offsetY, t3 + i2.offsetX + a2.offsetX, h2 + a2.offsetY, a2.color);
        n2.add(d2), h2 += r2;
      }
    }
  } }]), t2;
}();
var Ei = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new Ii(this.annoCtx), this.axesUtils = new Ri(this.annoCtx);
  }
  return s(t2, [{ key: "addYaxisAnnotation", value: function(t3, e2, i2) {
    var a2, s2 = this.w, r2 = t3.strokeDashArray, n2 = this.helpers.getY1Y2("y1", t3), o2 = n2.yP, l2 = n2.clipped, h2 = true, c2 = false, d2 = t3.label.text;
    if (t3.y2 === null || t3.y2 === undefined) {
      if (!l2) {
        c2 = true;
        var u2 = this.annoCtx.graphics.drawLine(0 + t3.offsetX, o2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 + t3.offsetY, t3.borderColor, r2, t3.borderWidth);
        e2.appendChild(u2.node), t3.id && u2.node.classList.add(t3.id);
      }
    } else {
      if (a2 = (n2 = this.helpers.getY1Y2("y2", t3)).yP, h2 = n2.clipped, a2 > o2) {
        var g2 = o2;
        o2 = a2, a2 = g2;
      }
      if (!l2 || !h2) {
        c2 = true;
        var p2 = this.annoCtx.graphics.drawRect(0 + t3.offsetX, a2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 - a2, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, r2);
        p2.node.classList.add("apexcharts-annotation-rect"), p2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(p2.node), t3.id && p2.node.classList.add(t3.id);
      }
    }
    if (c2) {
      var f2 = t3.label.position === "right" ? s2.globals.gridWidth : t3.label.position === "center" ? s2.globals.gridWidth / 2 : 0, x2 = this.annoCtx.graphics.drawText({ x: f2 + t3.label.offsetX, y: (a2 != null ? a2 : o2) + t3.label.offsetY - 3, text: d2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
      x2.attr({ rel: i2 }), e2.appendChild(x2.node);
    }
  } }, { key: "_getYAxisAnnotationWidth", value: function(t3) {
    var e2 = this.w;
    e2.globals.gridWidth;
    return (t3.width.indexOf("%") > -1 ? e2.globals.gridWidth * parseInt(t3.width, 10) / 100 : parseInt(t3.width, 10)) + t3.offsetX;
  } }, { key: "drawYAxisAnnotations", value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
    return e2.config.annotations.yaxis.forEach(function(e3, a2) {
      e3.yAxisIndex = t3.axesUtils.translateYAxisIndex(e3.yAxisIndex), t3.axesUtils.isYAxisHidden(e3.yAxisIndex) && t3.axesUtils.yAxisAllSeriesCollapsed(e3.yAxisIndex) || t3.addYaxisAnnotation(e3, i2.node, a2);
    }), i2;
  } }]), t2;
}();
var Yi = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new Ii(this.annoCtx);
  }
  return s(t2, [{ key: "addPointAnnotation", value: function(t3, e2, i2) {
    if (!(this.w.globals.collapsedSeriesIndices.indexOf(t3.seriesIndex) > -1)) {
      var a2 = this.helpers.getX1X2("x1", t3), s2 = a2.x, r2 = a2.clipped, n2 = (a2 = this.helpers.getY1Y2("y1", t3)).yP, o2 = a2.clipped;
      if (v.isNumber(s2) && !o2 && !r2) {
        var l2 = { pSize: t3.marker.size, pointStrokeWidth: t3.marker.strokeWidth, pointFillColor: t3.marker.fillColor, pointStrokeColor: t3.marker.strokeColor, shape: t3.marker.shape, pRadius: t3.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t3.marker.cssClass, " ").concat(t3.id ? t3.id : "") }, h2 = this.annoCtx.graphics.drawMarker(s2 + t3.marker.offsetX, n2 + t3.marker.offsetY, l2);
        e2.appendChild(h2.node);
        var c2 = t3.label.text ? t3.label.text : "", d2 = this.annoCtx.graphics.drawText({ x: s2 + t3.label.offsetX, y: n2 + t3.label.offsetY - t3.marker.size - parseFloat(t3.label.style.fontSize) / 1.6, text: c2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        if (d2.attr({ rel: i2 }), e2.appendChild(d2.node), t3.customSVG.SVG) {
          var u2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t3.customSVG.cssClass });
          u2.attr({ transform: "translate(".concat(s2 + t3.customSVG.offsetX, ", ").concat(n2 + t3.customSVG.offsetY, ")") }), u2.node.innerHTML = t3.customSVG.SVG, e2.appendChild(u2.node);
        }
        if (t3.image.path) {
          var g2 = t3.image.width ? t3.image.width : 20, p2 = t3.image.height ? t3.image.height : 20;
          h2 = this.annoCtx.addImage({ x: s2 + t3.image.offsetX - g2 / 2, y: n2 + t3.image.offsetY - p2 / 2, width: g2, height: p2, path: t3.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        t3.mouseEnter && h2.node.addEventListener("mouseenter", t3.mouseEnter.bind(this, t3)), t3.mouseLeave && h2.node.addEventListener("mouseleave", t3.mouseLeave.bind(this, t3)), t3.click && h2.node.addEventListener("click", t3.click.bind(this, t3));
      }
    }
  } }, { key: "drawPointAnnotations", value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
    return e2.config.annotations.points.map(function(e3, a2) {
      t3.addPointAnnotation(e3, i2.node, a2);
    }), i2;
  } }]), t2;
}();
var Hi = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } };
var Oi = function() {
  function t2() {
    i(this, t2), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: undefined, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: undefined, stepSize: undefined, forceNiceScale: false, max: undefined, min: undefined, floating: false, decimalsInFloat: undefined, labels: { show: true, showDuplicates: false, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: undefined, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: undefined, cssClass: "" }, formatter: undefined }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: undefined, rotate: -90, offsetY: 0, offsetX: 0, style: { color: undefined, fontSize: "11px", fontWeight: 900, fontFamily: undefined, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: undefined, x: 0, y: null, yAxisIndex: 0, seriesIndex: undefined, mouseEnter: undefined, mouseLeave: undefined, click: undefined, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: undefined, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: undefined, mouseLeave: undefined, click: undefined, style: { background: "#fff", color: undefined, fontSize: "11px", fontFamily: undefined, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: undefined, cssClass: undefined, offsetX: 0, offsetY: 0 }, image: { path: undefined, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: undefined, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: undefined, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: undefined, mouseLeave: undefined, click: undefined, style: { background: "#fff", color: undefined, fontSize: "11px", fontFamily: undefined, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: undefined, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: undefined, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: undefined, mouseLeave: undefined, click: undefined, style: { background: "#fff", color: undefined, fontSize: "11px", fontFamily: undefined, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: undefined, fontSize: "13px", fontFamily: undefined, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
  }
  return s(t2, [{ key: "init", value: function() {
    return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "", locales: [Hi], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: undefined, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.7 }, events: { animationEnd: undefined, beforeMount: undefined, mounted: undefined, updated: undefined, click: undefined, mouseMove: undefined, mouseLeave: undefined, xAxisLabelClick: undefined, legendClick: undefined, markerClick: undefined, selection: undefined, dataPointSelection: undefined, dataPointMouseEnter: undefined, dataPointMouseLeave: undefined, beforeZoom: undefined, beforeResetZoom: undefined, zoomed: undefined, scrolled: undefined, brushScrolled: undefined }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: undefined, group: undefined, nonce: undefined, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: undefined, max: undefined }, yaxis: { min: undefined, max: undefined } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: undefined, targets: undefined }, stacked: false, stackOnlyBar: true, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: undefined, columnDelimiter: ",", headerCategory: "category", headerValue: "value", categoryFormatter: undefined, valueFormatter: undefined }, png: { filename: undefined }, svg: { filename: undefined }, scale: undefined, width: undefined }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, allowMouseWheelZoom: true, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: false, colors: { threshold: 0, colorAboveThreshold: undefined, colorBelowThreshold: undefined } }, area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: undefined, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: undefined, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: undefined, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: undefined, maxBubbleRadius: undefined }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: undefined, max: undefined } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: undefined, max: undefined }, seriesTitle: { show: true, offsetY: 1, offsetX: 1, borderColor: "#000", borderWidth: 1, borderRadius: 2, style: { background: "rgba(0, 0, 0, 0.6)", color: "#fff", fontSize: "12px", fontFamily: undefined, fontWeight: 400, cssClass: "", padding: { left: 6, right: 6, top: 2, bottom: 2 } } } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: undefined, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: undefined, endAngle: undefined, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: undefined, fontWeight: 600, color: undefined, offsetY: 0, formatter: function(t3) {
      return t3;
    } }, value: { show: true, fontSize: "14px", fontFamily: undefined, fontWeight: 400, color: undefined, offsetY: 16, formatter: function(t3) {
      return t3 + "%";
    } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: undefined, color: undefined, formatter: function(t3) {
      return t3.globals.seriesTotals.reduce(function(t4, e2) {
        return t4 + e2;
      }, 0) / t3.globals.series.length + "%";
    } } }, barLabels: { enabled: false, offsetX: 0, offsetY: 0, useSeriesColors: true, fontFamily: undefined, fontWeight: 600, fontSize: "16px", formatter: function(t3) {
      return t3;
    }, onClick: undefined } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: undefined, fontWeight: 600, color: undefined, offsetY: -10, formatter: function(t3) {
      return t3;
    } }, value: { show: true, fontSize: "20px", fontFamily: undefined, fontWeight: 400, color: undefined, offsetY: 10, formatter: function(t3) {
      return t3;
    } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: undefined, color: undefined, formatter: function(t3) {
      return t3.globals.seriesTotals.reduce(function(t4, e2) {
        return t4 + e2;
      }, 0);
    } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: undefined, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: undefined } } } }, colors: undefined, dataLabels: { enabled: true, enabledOnSeries: undefined, formatter: function(t3) {
      return t3 !== null ? t3 : "";
    }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: undefined, fontWeight: 600, colors: undefined }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, fill: { type: "solid", colors: undefined, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: undefined, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: undefined, height: undefined }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: undefined, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: undefined, opacity: 0.5 }, column: { colors: undefined, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: undefined, fontWeight: 400, width: undefined, height: undefined, formatter: undefined, tooltipHoverFormatter: undefined, offsetX: -20, offsetY: 4, customLegendItems: [], clusterGroupedSeries: true, clusterGroupedSeriesOrientation: "vertical", labels: { colors: undefined, useSeriesColors: false }, markers: { size: 7, fillColors: undefined, strokeWidth: 1, shape: undefined, offsetX: 0, offsetY: 0, customHTML: undefined, onClick: undefined }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: undefined, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", offsetX: 0, offsetY: 0, showNullDataPoints: true, onClick: undefined, onDblClick: undefined, hover: { size: undefined, sizeOffset: 3 } }, noData: { text: undefined, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: undefined, fontSize: "14px", fontFamily: undefined } }, responsive: [], series: undefined, states: { hover: { filter: { type: "lighten" } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken" } } }, title: { text: undefined, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: undefined, color: undefined } }, subtitle: { text: undefined, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: undefined, color: undefined } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: undefined, dashArray: 0, fill: { type: "solid", colors: undefined, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: undefined, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: undefined, shared: true, hideEmptySeries: false, followCursor: false, intersect: false, inverseOrder: false, custom: undefined, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: undefined }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: undefined }, y: { formatter: undefined, title: { formatter: function(t3) {
      return t3 ? t3 + ": " : "";
    } } }, z: { formatter: undefined, title: "Size: " }, marker: { show: true, fillColors: undefined }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: undefined, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: undefined, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: undefined, cssClass: "" }, offsetX: 0, offsetY: 0, format: undefined, formatter: undefined, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: undefined, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: undefined, tickAmount: undefined, tickPlacement: "on", min: undefined, max: undefined, range: undefined, floating: false, decimalsInFloat: undefined, position: "bottom", title: { text: undefined, offsetX: 0, offsetY: 0, style: { color: undefined, fontSize: "12px", fontWeight: 900, fontFamily: undefined, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.8 } }, tooltip: { enabled: true, offsetY: 0, formatter: undefined, style: { fontSize: "12px", fontFamily: undefined } } }, yaxis: this.yAxis, theme: { mode: "", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
  } }]), t2;
}();
var Fi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.graphics = new Mi(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new Ii(this), this.xAxisAnnotations = new Ti(this), this.yAxisAnnotations = new Ei(this), this.pointsAnnotations = new Yi(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  return s(t2, [{ key: "drawAxesAnnotations", value: function() {
    var t3 = this.w;
    if (t3.globals.axisCharts && t3.globals.dataPoints) {
      for (var e2 = this.yAxisAnnotations.drawYAxisAnnotations(), i2 = this.xAxisAnnotations.drawXAxisAnnotations(), a2 = this.pointsAnnotations.drawPointAnnotations(), s2 = t3.config.chart.animations.enabled, r2 = [e2, i2, a2], n2 = [i2.node, e2.node, a2.node], o2 = 0;o2 < 3; o2++)
        t3.globals.dom.elGraphical.add(r2[o2]), !s2 || t3.globals.resized || t3.globals.dataChanged || t3.config.chart.type !== "scatter" && t3.config.chart.type !== "bubble" && t3.globals.dataPoints > 1 && n2[o2].classList.add("apexcharts-element-hidden"), t3.globals.delayedElements.push({ el: n2[o2], index: 0 });
      this.helpers.annotationsBackground();
    }
  } }, { key: "drawImageAnnos", value: function() {
    var t3 = this;
    this.w.config.annotations.images.map(function(e2, i2) {
      t3.addImage(e2, i2);
    });
  } }, { key: "drawTextAnnos", value: function() {
    var t3 = this;
    this.w.config.annotations.texts.map(function(e2, i2) {
      t3.addText(e2, i2);
    });
  } }, { key: "addXaxisAnnotation", value: function(t3, e2, i2) {
    this.xAxisAnnotations.addXaxisAnnotation(t3, e2, i2);
  } }, { key: "addYaxisAnnotation", value: function(t3, e2, i2) {
    this.yAxisAnnotations.addYaxisAnnotation(t3, e2, i2);
  } }, { key: "addPointAnnotation", value: function(t3, e2, i2) {
    this.pointsAnnotations.addPointAnnotation(t3, e2, i2);
  } }, { key: "addText", value: function(t3, e2) {
    var { x: i2, y: a2, text: s2, textAnchor: r2, foreColor: n2, fontSize: o2, fontFamily: l2, fontWeight: h2, cssClass: c2, backgroundColor: d2, borderWidth: u2, strokeDashArray: g2, borderRadius: p2, borderColor: f2, appendTo: x2 } = t3, b2 = x2 === undefined ? ".apexcharts-svg" : x2, m2 = t3.paddingLeft, v2 = m2 === undefined ? 4 : m2, y2 = t3.paddingRight, w2 = y2 === undefined ? 4 : y2, k2 = t3.paddingBottom, A2 = k2 === undefined ? 2 : k2, C2 = t3.paddingTop, S2 = C2 === undefined ? 2 : C2, L2 = this.w, M2 = this.graphics.drawText({ x: i2, y: a2, text: s2, textAnchor: r2 || "start", fontSize: o2 || "12px", fontWeight: h2 || "regular", fontFamily: l2 || L2.config.chart.fontFamily, foreColor: n2 || L2.config.chart.foreColor, cssClass: c2 }), P2 = L2.globals.dom.baseEl.querySelector(b2);
    P2 && P2.appendChild(M2.node);
    var I2 = M2.bbox();
    if (s2) {
      var T2 = this.graphics.drawRect(I2.x - v2, I2.y - S2, I2.width + v2 + w2, I2.height + A2 + S2, p2, d2 || "transparent", 1, u2, f2, g2);
      P2.insertBefore(T2.node, M2.node);
    }
  } }, { key: "addImage", value: function(t3, e2) {
    var i2 = this.w, a2 = t3.path, s2 = t3.x, r2 = s2 === undefined ? 0 : s2, n2 = t3.y, o2 = n2 === undefined ? 0 : n2, l2 = t3.width, h2 = l2 === undefined ? 20 : l2, c2 = t3.height, d2 = c2 === undefined ? 20 : c2, u2 = t3.appendTo, g2 = u2 === undefined ? ".apexcharts-svg" : u2, p2 = i2.globals.dom.Paper.image(a2);
    p2.size(h2, d2).move(r2, o2);
    var f2 = i2.globals.dom.baseEl.querySelector(g2);
    return f2 && f2.appendChild(p2.node), p2;
  } }, { key: "addXaxisAnnotationExternal", value: function(t3, e2, i2) {
    return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "xaxis", contextMethod: i2.addXaxisAnnotation }), i2;
  } }, { key: "addYaxisAnnotationExternal", value: function(t3, e2, i2) {
    return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "yaxis", contextMethod: i2.addYaxisAnnotation }), i2;
  } }, { key: "addPointAnnotationExternal", value: function(t3, e2, i2) {
    return this.invertAxis === undefined && (this.invertAxis = i2.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "point", contextMethod: i2.addPointAnnotation }), i2;
  } }, { key: "addAnnotationExternal", value: function(t3) {
    var { params: e2, pushToMemory: i2, context: a2, type: s2, contextMethod: r2 } = t3, n2 = a2, o2 = n2.w, l2 = o2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations")), h2 = l2.childNodes.length + 1, c2 = new Oi, d2 = Object.assign({}, s2 === "xaxis" ? c2.xAxisAnnotation : s2 === "yaxis" ? c2.yAxisAnnotation : c2.pointAnnotation), u2 = v.extend(d2, e2);
    switch (s2) {
      case "xaxis":
        this.addXaxisAnnotation(u2, l2, h2);
        break;
      case "yaxis":
        this.addYaxisAnnotation(u2, l2, h2);
        break;
      case "point":
        this.addPointAnnotation(u2, l2, h2);
    }
    var g2 = o2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(h2, "']")), p2 = this.helpers.addBackgroundToAnno(g2, u2);
    return p2 && l2.insertBefore(p2.node, g2), i2 && o2.globals.memory.methodsToExec.push({ context: n2, id: u2.id ? u2.id : v.randomId(), method: r2, label: "addAnnotation", params: e2 }), a2;
  } }, { key: "clearAnnotations", value: function(t3) {
    for (var e2 = t3.w, i2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), a2 = e2.globals.memory.methodsToExec.length - 1;a2 >= 0; a2--)
      e2.globals.memory.methodsToExec[a2].label !== "addText" && e2.globals.memory.methodsToExec[a2].label !== "addAnnotation" || e2.globals.memory.methodsToExec.splice(a2, 1);
    i2 = v.listToArray(i2), Array.prototype.forEach.call(i2, function(t4) {
      for (;t4.firstChild; )
        t4.removeChild(t4.firstChild);
    });
  } }, { key: "removeAnnotation", value: function(t3, e2) {
    var i2 = t3.w, a2 = i2.globals.dom.baseEl.querySelectorAll(".".concat(e2));
    a2 && (i2.globals.memory.methodsToExec.map(function(t4, a3) {
      t4.id === e2 && i2.globals.memory.methodsToExec.splice(a3, 1);
    }), Array.prototype.forEach.call(a2, function(t4) {
      t4.parentElement.removeChild(t4);
    }));
  } }]), t2;
}();
var Di = function(t2) {
  var e2, i2 = t2.isTimeline, a2 = t2.ctx, s2 = t2.seriesIndex, r2 = t2.dataPointIndex, n2 = t2.y1, o2 = t2.y2, l2 = t2.w, h2 = l2.globals.seriesRangeStart[s2][r2], c2 = l2.globals.seriesRangeEnd[s2][r2], d2 = l2.globals.labels[r2], u2 = l2.config.series[s2].name ? l2.config.series[s2].name : "", g2 = l2.globals.ttKeyFormatter, p2 = l2.config.tooltip.y.title.formatter, f2 = { w: l2, seriesIndex: s2, dataPointIndex: r2, start: h2, end: c2 };
  (typeof p2 == "function" && (u2 = p2(u2, f2)), (e2 = l2.config.series[s2].data[r2]) !== null && e2 !== undefined && e2.x && (d2 = l2.config.series[s2].data[r2].x), i2) || l2.config.xaxis.type === "datetime" && (d2 = new Xi(a2).xLabelFormat(l2.globals.ttKeyFormatter, d2, d2, { i: undefined, dateFormatter: new zi(a2).formatDate, w: l2 }));
  typeof g2 == "function" && (d2 = g2(d2, f2)), Number.isFinite(n2) && Number.isFinite(o2) && (h2 = n2, c2 = o2);
  var x2 = "", b2 = "", m2 = l2.globals.colors[s2];
  if (l2.config.tooltip.x.formatter === undefined)
    if (l2.config.xaxis.type === "datetime") {
      var v2 = new zi(a2);
      x2 = v2.formatDate(v2.getDate(h2), l2.config.tooltip.x.format), b2 = v2.formatDate(v2.getDate(c2), l2.config.tooltip.x.format);
    } else
      x2 = h2, b2 = c2;
  else
    x2 = l2.config.tooltip.x.formatter(h2), b2 = l2.config.tooltip.x.formatter(c2);
  return { start: h2, end: c2, startVal: x2, endVal: b2, ylabel: d2, color: m2, seriesName: u2 };
};
var _i = function(t2) {
  var { color: e2, seriesName: i2, ylabel: a2, start: s2, end: r2, seriesIndex: n2, dataPointIndex: o2 } = t2, l2 = t2.ctx.tooltip.tooltipLabels.getFormatters(n2);
  s2 = l2.yLbFormatter(s2), r2 = l2.yLbFormatter(r2);
  var h2 = l2.yLbFormatter(t2.w.globals.series[n2][o2]), c2 = '<span class="value start-value">\n  '.concat(s2, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r2, "\n  </span>");
  return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e2 + '">' + (i2 || "") + '</span></div><div> <span class="category">' + a2 + ": </span> " + (t2.w.globals.comboCharts ? t2.w.config.series[n2].type === "rangeArea" || t2.w.config.series[n2].type === "rangeBar" ? c2 : "<span>".concat(h2, "</span>") : c2) + " </div></div>";
};
var Ni = function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "hideYAxis", value: function() {
    this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
  } }, { key: "line", value: function() {
    return { dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "sparkline", value: function(t3) {
    this.hideYAxis();
    return v.extend(t3, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
  } }, { key: "slope", value: function() {
    return this.hideYAxis(), { chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: true, formatter: function(t3, e2) {
      var i2 = e2.w.config.series[e2.seriesIndex].name;
      return t3 !== null ? i2 + ": " + t3 : "";
    }, background: { enabled: false }, offsetX: -5 }, grid: { xaxis: { lines: { show: true } }, yaxis: { lines: { show: false } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: false }, crosshairs: { show: false } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: false }, tooltip: { shared: false, intersect: true, followCursor: true }, stroke: { width: 5, curve: "straight" } };
  } }, { key: "bar", value: function() {
    return { chart: { stacked: false }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "square" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square" } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
  } }, { key: "funnel", value: function() {
    return this.hideYAxis(), u(u({}, this.bar()), {}, { chart: { animations: { speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
  } }, { key: "candlestick", value: function() {
    var t3 = this;
    return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
      var { seriesIndex: i2, dataPointIndex: a2, w: s2 } = e2;
      return t3._getBoxTooltip(s2, i2, a2, ["Open", "High", "", "Low", "Close"], "candlestick");
    } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "boxPlot", value: function() {
    var t3 = this;
    return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
      var { seriesIndex: i2, dataPointIndex: a2, w: s2 } = e2;
      return t3._getBoxTooltip(s2, i2, a2, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
    } }, markers: { size: 7, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "rangeBar", value: function() {
    return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t3, e2) {
      e2.ctx;
      var { seriesIndex: i2, dataPointIndex: a2, w: s2 } = e2, r2 = function() {
        var t4 = s2.globals.seriesRangeStart[i2][a2];
        return s2.globals.seriesRangeEnd[i2][a2] - t4;
      };
      return s2.globals.comboCharts ? s2.config.series[i2].type === "rangeBar" || s2.config.series[i2].type === "rangeArea" ? r2() : t3 : r2();
    }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t3) {
      return t3.w.config.plotOptions && t3.w.config.plotOptions.bar && t3.w.config.plotOptions.bar.horizontal ? function(t4) {
        var e2 = Di(u(u({}, t4), {}, { isTimeline: true })), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.startVal, n2 = e2.endVal;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3) : function(t4) {
        var e2 = Di(t4), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.start, n2 = e2.end;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3);
    } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
  } }, { key: "dumbbell", value: function(t3) {
    var e2, i2;
    return (e2 = t3.plotOptions.bar) !== null && e2 !== undefined && e2.barHeight || (t3.plotOptions.bar.barHeight = 2), (i2 = t3.plotOptions.bar) !== null && i2 !== undefined && i2.columnWidth || (t3.plotOptions.bar.columnWidth = 2), t3;
  } }, { key: "area", value: function() {
    return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
  } }, { key: "rangeArea", value: function() {
    return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t3) {
      return function(t4) {
        var e2 = Di(t4), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.start, n2 = e2.end;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3);
    } } };
  } }, { key: "brush", value: function(t3) {
    return v.extend(t3, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
  } }, { key: "stacked100", value: function(t3) {
    t3.dataLabels = t3.dataLabels || {}, t3.dataLabels.formatter = t3.dataLabels.formatter || undefined;
    var e2 = t3.dataLabels.formatter;
    return t3.yaxis.forEach(function(e3, i2) {
      t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
    }), t3.chart.type === "bar" && (t3.dataLabels.formatter = e2 || function(t4) {
      return typeof t4 == "number" && t4 ? t4.toFixed(0) + "%" : t4;
    }), t3;
  } }, { key: "stackedBars", value: function() {
    var t3 = this.bar();
    return u(u({}, t3), {}, { plotOptions: u(u({}, t3.plotOptions), {}, { bar: u(u({}, t3.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
  } }, { key: "convertCatToNumeric", value: function(t3) {
    return t3.xaxis.convertedCatToNumeric = true, t3;
  } }, { key: "convertCatToNumericXaxis", value: function(t3, e2, i2) {
    t3.xaxis.type = "numeric", t3.xaxis.labels = t3.xaxis.labels || {}, t3.xaxis.labels.formatter = t3.xaxis.labels.formatter || function(t4) {
      return v.isNumber(t4) ? Math.floor(t4) : t4;
    };
    var a2 = t3.xaxis.labels.formatter, s2 = t3.xaxis.categories && t3.xaxis.categories.length ? t3.xaxis.categories : t3.labels;
    return i2 && i2.length && (s2 = i2.map(function(t4) {
      return Array.isArray(t4) ? t4 : String(t4);
    })), s2 && s2.length && (t3.xaxis.labels.formatter = function(t4) {
      return v.isNumber(t4) ? a2(s2[Math.floor(t4) - 1]) : a2(t4);
    }), t3.xaxis.categories = [], t3.labels = [], t3.xaxis.tickAmount = t3.xaxis.tickAmount || "dataPoints", t3;
  } }, { key: "bubble", value: function() {
    return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
  } }, { key: "scatter", value: function() {
    return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
  } }, { key: "heatmap", value: function() {
    return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square" } }, grid: { padding: { right: 20 } } };
  } }, { key: "treemap", value: function() {
    return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
  } }, { key: "pie", value: function() {
    return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "donut", value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "polarArea", value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "radar", value: function() {
    return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, xaxis: { labels: { formatter: function(t3) {
      return t3;
    }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
  } }, { key: "radialBar", value: function() {
    return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "_getBoxTooltip", value: function(t3, e2, i2, a2, s2) {
    var r2 = t3.globals.seriesCandleO[e2][i2], n2 = t3.globals.seriesCandleH[e2][i2], o2 = t3.globals.seriesCandleM[e2][i2], l2 = t3.globals.seriesCandleL[e2][i2], h2 = t3.globals.seriesCandleC[e2][i2];
    return t3.config.series[e2].type && t3.config.series[e2].type !== s2 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t3.config.series[e2].name ? t3.config.series[e2].name : "series-" + (e2 + 1), ": <strong>").concat(t3.globals.series[e2][i2], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t3.config.chart.type, '">') + "<div>".concat(a2[0], ': <span class="value">') + r2 + "</span></div>" + "<div>".concat(a2[1], ': <span class="value">') + n2 + "</span></div>" + (o2 ? "<div>".concat(a2[2], ': <span class="value">') + o2 + "</span></div>" : "") + "<div>".concat(a2[3], ': <span class="value">') + l2 + "</span></div>" + "<div>".concat(a2[4], ': <span class="value">') + h2 + "</span></div></div>";
  } }]), t2;
}();
var Wi = function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "init", value: function(t3) {
    var e2 = t3.responsiveOverride, i2 = this.opts, a2 = new Oi, s2 = new Ni(i2);
    this.chartType = i2.chart.type, i2 = this.extendYAxis(i2), i2 = this.extendAnnotations(i2);
    var r2 = a2.init(), n2 = {};
    if (i2 && b(i2) === "object") {
      var o2, l2, h2, c2, d2, u2, g2, p2, f2, x2, m2 = {};
      m2 = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i2.chart.type) !== -1 ? s2[i2.chart.type]() : s2.line(), (o2 = i2.plotOptions) !== null && o2 !== undefined && (l2 = o2.bar) !== null && l2 !== undefined && l2.isFunnel && (m2 = s2.funnel()), i2.chart.stacked && i2.chart.type === "bar" && (m2 = s2.stackedBars()), (h2 = i2.chart.brush) !== null && h2 !== undefined && h2.enabled && (m2 = s2.brush(m2)), (c2 = i2.plotOptions) !== null && c2 !== undefined && (d2 = c2.line) !== null && d2 !== undefined && d2.isSlopeChart && (m2 = s2.slope()), i2.chart.stacked && i2.chart.stackType === "100%" && (i2 = s2.stacked100(i2)), (u2 = i2.plotOptions) !== null && u2 !== undefined && (g2 = u2.bar) !== null && g2 !== undefined && g2.isDumbbell && (i2 = s2.dumbbell(i2)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i2), i2.xaxis = i2.xaxis || window.Apex.xaxis || {}, e2 || (i2.xaxis.convertedCatToNumeric = false), ((p2 = (i2 = this.checkForCatToNumericXAxis(this.chartType, m2, i2)).chart.sparkline) !== null && p2 !== undefined && p2.enabled || (f2 = window.Apex.chart) !== null && f2 !== undefined && (x2 = f2.sparkline) !== null && x2 !== undefined && x2.enabled) && (m2 = s2.sparkline(m2)), n2 = v.extend(r2, m2);
    }
    var y2 = v.extend(n2, window.Apex);
    return r2 = v.extend(y2, i2), r2 = this.handleUserInputErrors(r2);
  } }, { key: "checkForCatToNumericXAxis", value: function(t3, e2, i2) {
    var a2, s2, r2 = new Ni(i2), n2 = (t3 === "bar" || t3 === "boxPlot") && ((a2 = i2.plotOptions) === null || a2 === undefined || (s2 = a2.bar) === null || s2 === undefined ? undefined : s2.horizontal), o2 = t3 === "pie" || t3 === "polarArea" || t3 === "donut" || t3 === "radar" || t3 === "radialBar" || t3 === "heatmap", l2 = i2.xaxis.type !== "datetime" && i2.xaxis.type !== "numeric", h2 = i2.xaxis.tickPlacement ? i2.xaxis.tickPlacement : e2.xaxis && e2.xaxis.tickPlacement;
    return n2 || o2 || !l2 || h2 === "between" || (i2 = r2.convertCatToNumeric(i2)), i2;
  } }, { key: "extendYAxis", value: function(t3, e2) {
    var i2 = new Oi;
    (t3.yaxis === undefined || !t3.yaxis || Array.isArray(t3.yaxis) && t3.yaxis.length === 0) && (t3.yaxis = {}), t3.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t3.yaxis = v.extend(t3.yaxis, window.Apex.yaxis)), t3.yaxis.constructor !== Array ? t3.yaxis = [v.extend(i2.yAxis, t3.yaxis)] : t3.yaxis = v.extendArray(t3.yaxis, i2.yAxis);
    var a2 = false;
    t3.yaxis.forEach(function(t4) {
      t4.logarithmic && (a2 = true);
    });
    var s2 = t3.series;
    return e2 && !s2 && (s2 = e2.config.series), a2 && s2.length !== t3.yaxis.length && s2.length && (t3.yaxis = s2.map(function(e3, a3) {
      if (e3.name || (s2[a3].name = "series-".concat(a3 + 1)), t3.yaxis[a3])
        return t3.yaxis[a3].seriesName = s2[a3].name, t3.yaxis[a3];
      var r2 = v.extend(i2.yAxis, t3.yaxis[0]);
      return r2.show = false, r2;
    })), a2 && s2.length > 1 && s2.length !== t3.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t3;
  } }, { key: "extendAnnotations", value: function(t3) {
    return t3.annotations === undefined && (t3.annotations = {}, t3.annotations.yaxis = [], t3.annotations.xaxis = [], t3.annotations.points = []), t3 = this.extendYAxisAnnotations(t3), t3 = this.extendXAxisAnnotations(t3), t3 = this.extendPointAnnotations(t3);
  } }, { key: "extendYAxisAnnotations", value: function(t3) {
    var e2 = new Oi;
    return t3.annotations.yaxis = v.extendArray(t3.annotations.yaxis !== undefined ? t3.annotations.yaxis : [], e2.yAxisAnnotation), t3;
  } }, { key: "extendXAxisAnnotations", value: function(t3) {
    var e2 = new Oi;
    return t3.annotations.xaxis = v.extendArray(t3.annotations.xaxis !== undefined ? t3.annotations.xaxis : [], e2.xAxisAnnotation), t3;
  } }, { key: "extendPointAnnotations", value: function(t3) {
    var e2 = new Oi;
    return t3.annotations.points = v.extendArray(t3.annotations.points !== undefined ? t3.annotations.points : [], e2.pointAnnotation), t3;
  } }, { key: "checkForDarkTheme", value: function(t3) {
    t3.theme && t3.theme.mode === "dark" && (t3.tooltip || (t3.tooltip = {}), t3.tooltip.theme !== "light" && (t3.tooltip.theme = "dark"), t3.chart.foreColor || (t3.chart.foreColor = "#f6f7f8"), t3.theme.palette || (t3.theme.palette = "palette4"));
  } }, { key: "handleUserInputErrors", value: function(t3) {
    var e2 = t3;
    if (e2.tooltip.shared && e2.tooltip.intersect)
      throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
    if (e2.chart.type === "bar" && e2.plotOptions.bar.horizontal) {
      if (e2.yaxis.length > 1)
        throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
      e2.yaxis[0].reversed && (e2.yaxis[0].opposite = true), e2.xaxis.tooltip.enabled = false, e2.yaxis[0].tooltip.enabled = false, e2.chart.zoom.enabled = false;
    }
    return e2.chart.type !== "bar" && e2.chart.type !== "rangeBar" || e2.tooltip.shared && e2.xaxis.crosshairs.width === "barWidth" && e2.series.length > 1 && (e2.xaxis.crosshairs.width = "tickWidth"), e2.chart.type !== "candlestick" && e2.chart.type !== "boxPlot" || e2.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e2.chart.type, " chart is not supported.")), e2.yaxis[0].reversed = false), e2;
  } }]), t2;
}();
var Bi = function() {
  function t2() {
    i(this, t2);
  }
  return s(t2, [{ key: "initGlobalVars", value: function(t3) {
    t3.series = [], t3.seriesCandleO = [], t3.seriesCandleH = [], t3.seriesCandleM = [], t3.seriesCandleL = [], t3.seriesCandleC = [], t3.seriesRangeStart = [], t3.seriesRangeEnd = [], t3.seriesRange = [], t3.seriesPercent = [], t3.seriesGoals = [], t3.seriesX = [], t3.seriesZ = [], t3.seriesNames = [], t3.seriesTotals = [], t3.seriesLog = [], t3.seriesColors = [], t3.stackedSeriesTotals = [], t3.seriesXvalues = [], t3.seriesYvalues = [], t3.labels = [], t3.hasXaxisGroups = false, t3.groups = [], t3.barGroups = [], t3.lineGroups = [], t3.areaGroups = [], t3.hasSeriesGroups = false, t3.seriesGroups = [], t3.categoryLabels = [], t3.timescaleLabels = [], t3.noLabelsProvided = false, t3.resizeTimer = null, t3.selectionResizeTimer = null, t3.lastWheelExecution = 0, t3.delayedElements = [], t3.pointsArray = [], t3.dataLabelsRects = [], t3.isXNumeric = false, t3.skipLastTimelinelabel = false, t3.skipFirstTimelinelabel = false, t3.isDataXYZ = false, t3.isMultiLineX = false, t3.isMultipleYAxis = false, t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE, t3.minYArr = [], t3.maxYArr = [], t3.maxX = -Number.MAX_VALUE, t3.minX = Number.MAX_VALUE, t3.initialMaxX = -Number.MAX_VALUE, t3.initialMinX = Number.MAX_VALUE, t3.maxDate = 0, t3.minDate = Number.MAX_VALUE, t3.minZ = Number.MAX_VALUE, t3.maxZ = -Number.MAX_VALUE, t3.minXDiff = Number.MAX_VALUE, t3.yAxisScale = [], t3.xAxisScale = null, t3.xAxisTicksPositions = [], t3.yLabelsCoords = [], t3.yTitleCoords = [], t3.barPadForNumericAxis = 0, t3.padHorizontal = 0, t3.xRange = 0, t3.yRange = [], t3.zRange = 0, t3.dataPoints = 0, t3.xTickAmount = 0, t3.multiAxisTickAmount = 0;
  } }, { key: "globalVars", value: function(t3) {
    return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t3.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], invalidLogScale: false, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: undefined, zoomEnabled: t3.chart.toolbar.autoSelected === "zoom" && t3.chart.toolbar.tools.zoom && t3.chart.zoom.enabled, panEnabled: t3.chart.toolbar.autoSelected === "pan" && t3.chart.toolbar.tools.pan, selectionEnabled: t3.chart.toolbar.autoSelected === "selection" && t3.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: undefined, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, isSlopeChart: t3.plotOptions.line.isSlopeChart, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: undefined, yLabelFormatters: [], xaxisTooltipFormatter: undefined, ttKeyFormatter: undefined, ttVal: undefined, ttZFormatter: undefined, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
  } }, { key: "init", value: function(t3) {
    var e2 = this.globalVars(t3);
    return this.initGlobalVars(e2), e2.initialConfig = v.extend({}, t3), e2.initialSeries = v.clone(t3.series), e2.lastXAxis = v.clone(e2.initialConfig.xaxis), e2.lastYAxis = v.clone(e2.initialConfig.yaxis), e2;
  } }]), t2;
}();
var Gi = function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "init", value: function() {
    var t3 = new Wi(this.opts).init({ responsiveOverride: false });
    return { config: t3, globals: new Bi().init(t3) };
  } }]), t2;
}();
var ji = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
  }
  return s(t2, [{ key: "clippedImgArea", value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = parseInt(e2.globals.gridWidth, 10), s2 = parseInt(e2.globals.gridHeight, 10), r2 = a2 > s2 ? a2 : s2, n2 = t3.image, o2 = 0, l2 = 0;
    t3.width === undefined && t3.height === undefined ? i2.fill.image.width !== undefined && i2.fill.image.height !== undefined ? (o2 = i2.fill.image.width + 1, l2 = i2.fill.image.height) : (o2 = r2 + 1, l2 = r2) : (o2 = t3.width, l2 = t3.height);
    var h2 = document.createElementNS(e2.globals.SVGNS, "pattern");
    Mi.setAttrs(h2, { id: t3.patternID, patternUnits: t3.patternUnits ? t3.patternUnits : "userSpaceOnUse", width: o2 + "px", height: l2 + "px" });
    var c2 = document.createElementNS(e2.globals.SVGNS, "image");
    h2.appendChild(c2), c2.setAttributeNS(window.SVG.xlink, "href", n2), Mi.setAttrs(c2, { x: 0, y: 0, preserveAspectRatio: "none", width: o2 + "px", height: l2 + "px" }), c2.style.opacity = t3.opacity, e2.globals.dom.elDefs.node.appendChild(h2);
  } }, { key: "getSeriesIndex", value: function(t3) {
    var e2 = this.w, i2 = e2.config.chart.type;
    return (i2 === "bar" || i2 === "rangeBar") && e2.config.plotOptions.bar.distributed || i2 === "heatmap" || i2 === "treemap" ? this.seriesIndex = t3.seriesNumber : this.seriesIndex = t3.seriesNumber % e2.globals.series.length, this.seriesIndex;
  } }, { key: "computeColorStops", value: function(t3, e2) {
    var i2, a2 = this.w, s2 = null, n2 = null, o2 = r(t3);
    try {
      for (o2.s();!(i2 = o2.n()).done; ) {
        var l2 = i2.value;
        l2 >= e2.threshold ? (s2 === null || l2 > s2) && (s2 = l2) : (n2 === null || l2 < n2) && (n2 = l2);
      }
    } catch (t4) {
      o2.e(t4);
    } finally {
      o2.f();
    }
    s2 === null && (s2 = e2.threshold), n2 === null && (n2 = e2.threshold);
    var h2 = s2 - e2.threshold + (e2.threshold - n2);
    h2 === 0 && (h2 = 1);
    var c2 = 100 - (e2.threshold - n2) / h2 * 100;
    return [{ offset: c2 = Math.max(0, Math.min(c2, 100)), color: e2.colorAboveThreshold, opacity: a2.config.fill.opacity }, { offset: 0, color: e2.colorBelowThreshold, opacity: a2.config.fill.opacity }];
  } }, { key: "fillPath", value: function(t3) {
    var e2, i2, a2, s2 = this.w;
    this.opts = t3;
    var r2, n2, o2, l2 = this.w.config;
    this.seriesIndex = this.getSeriesIndex(t3);
    var h2 = l2.plotOptions.line.colors.colorAboveThreshold && l2.plotOptions.line.colors.colorBelowThreshold, c2 = this.getFillColors()[this.seriesIndex];
    s2.globals.seriesColors[this.seriesIndex] !== undefined && (c2 = s2.globals.seriesColors[this.seriesIndex]), typeof c2 == "function" && (c2 = c2({ seriesIndex: this.seriesIndex, dataPointIndex: t3.dataPointIndex, value: t3.value, w: s2 }));
    var d2, u2, g2, p2 = t3.fillType ? t3.fillType : this.getFillType(this.seriesIndex), x2 = Array.isArray(l2.fill.opacity) ? l2.fill.opacity[this.seriesIndex] : l2.fill.opacity, b2 = p2 === "gradient" || h2;
    (t3.color && (c2 = t3.color), (e2 = s2.config.series[this.seriesIndex]) !== null && e2 !== undefined && (i2 = e2.data) !== null && i2 !== undefined && (a2 = i2[t3.dataPointIndex]) !== null && a2 !== undefined && a2.fillColor) && (c2 = (d2 = s2.config.series[this.seriesIndex]) === null || d2 === undefined || (u2 = d2.data) === null || u2 === undefined || (g2 = u2[t3.dataPointIndex]) === null || g2 === undefined ? undefined : g2.fillColor);
    c2 || (c2 = "#fff", console.warn("undefined color - ApexCharts"));
    var m2 = c2;
    if (c2.indexOf("rgb") === -1 ? c2.indexOf("#") === -1 ? m2 = c2 : c2.length < 9 && (m2 = v.hexToRgba(c2, x2)) : c2.indexOf("rgba") > -1 ? x2 = v.getOpacityFromRGBA(c2) : m2 = v.hexToRgba(v.rgb2hex(c2), x2), t3.opacity && (x2 = t3.opacity), p2 === "pattern" && (n2 = this.handlePatternFill({ fillConfig: t3.fillConfig, patternFill: n2, fillColor: c2, fillOpacity: x2, defaultColor: m2 })), b2) {
      var y2 = f(l2.fill.gradient.colorStops) || [], w2 = l2.fill.gradient.type;
      h2 && (y2[this.seriesIndex] = this.computeColorStops(s2.globals.series[this.seriesIndex], l2.plotOptions.line.colors), w2 = "vertical"), o2 = this.handleGradientFill({ type: w2, fillConfig: t3.fillConfig, fillColor: c2, fillOpacity: x2, colorStops: y2, i: this.seriesIndex });
    }
    if (p2 === "image") {
      var k2 = l2.fill.image.src, A2 = t3.patternID ? t3.patternID : "", C2 = "pattern".concat(s2.globals.cuid).concat(t3.seriesNumber + 1).concat(A2);
      this.patternIDs.indexOf(C2) === -1 && (this.clippedImgArea({ opacity: x2, image: Array.isArray(k2) ? t3.seriesNumber < k2.length ? k2[t3.seriesNumber] : k2[0] : k2, width: t3.width ? t3.width : undefined, height: t3.height ? t3.height : undefined, patternUnits: t3.patternUnits, patternID: C2 }), this.patternIDs.push(C2)), r2 = "url(#".concat(C2, ")");
    } else
      r2 = b2 ? o2 : p2 === "pattern" ? n2 : m2;
    return t3.solid && (r2 = m2), r2;
  } }, { key: "getFillType", value: function(t3) {
    var e2 = this.w;
    return Array.isArray(e2.config.fill.type) ? e2.config.fill.type[t3] : e2.config.fill.type;
  } }, { key: "getFillColors", value: function() {
    var t3 = this.w, e2 = t3.config, i2 = this.opts, a2 = [];
    return t3.globals.comboCharts ? t3.config.series[this.seriesIndex].type === "line" ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors) : e2.chart.type === "line" ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors), i2.fillColors !== undefined && (a2 = [], Array.isArray(i2.fillColors) ? a2 = i2.fillColors.slice() : a2.push(i2.fillColors)), a2;
  } }, { key: "handlePatternFill", value: function(t3) {
    var { fillConfig: e2, patternFill: i2, fillColor: a2, fillOpacity: s2, defaultColor: r2 } = t3, n2 = this.w.config.fill;
    e2 && (n2 = e2);
    var o2 = this.opts, l2 = new Mi(this.ctx), h2 = Array.isArray(n2.pattern.strokeWidth) ? n2.pattern.strokeWidth[this.seriesIndex] : n2.pattern.strokeWidth, c2 = a2;
    Array.isArray(n2.pattern.style) ? i2 = n2.pattern.style[o2.seriesNumber] !== undefined ? l2.drawPattern(n2.pattern.style[o2.seriesNumber], n2.pattern.width, n2.pattern.height, c2, h2, s2) : r2 : i2 = l2.drawPattern(n2.pattern.style, n2.pattern.width, n2.pattern.height, c2, h2, s2);
    return i2;
  } }, { key: "handleGradientFill", value: function(t3) {
    var { type: e2, fillColor: i2, fillOpacity: a2, fillConfig: s2, colorStops: r2, i: n2 } = t3, o2 = this.w.config.fill;
    s2 && (o2 = u(u({}, o2), s2));
    var l2 = this.opts, h2 = new Mi(this.ctx), c2 = new v;
    e2 = e2 || o2.gradient.type;
    var d2, g2 = i2, p2 = o2.gradient.opacityFrom === undefined ? a2 : Array.isArray(o2.gradient.opacityFrom) ? o2.gradient.opacityFrom[n2] : o2.gradient.opacityFrom;
    g2.indexOf("rgba") > -1 && (p2 = v.getOpacityFromRGBA(g2));
    var f2 = o2.gradient.opacityTo === undefined ? a2 : Array.isArray(o2.gradient.opacityTo) ? o2.gradient.opacityTo[n2] : o2.gradient.opacityTo;
    if (o2.gradient.gradientToColors === undefined || o2.gradient.gradientToColors.length === 0)
      d2 = o2.gradient.shade === "dark" ? c2.shadeColor(-1 * parseFloat(o2.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? v.rgb2hex(i2) : i2) : c2.shadeColor(parseFloat(o2.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? v.rgb2hex(i2) : i2);
    else if (o2.gradient.gradientToColors[l2.seriesNumber]) {
      var x2 = o2.gradient.gradientToColors[l2.seriesNumber];
      d2 = x2, x2.indexOf("rgba") > -1 && (f2 = v.getOpacityFromRGBA(x2));
    } else
      d2 = i2;
    if (o2.gradient.gradientFrom && (g2 = o2.gradient.gradientFrom), o2.gradient.gradientTo && (d2 = o2.gradient.gradientTo), o2.gradient.inverseColors) {
      var b2 = g2;
      g2 = d2, d2 = b2;
    }
    return g2.indexOf("rgb") > -1 && (g2 = v.rgb2hex(g2)), d2.indexOf("rgb") > -1 && (d2 = v.rgb2hex(d2)), h2.drawGradient(e2, g2, d2, p2, f2, l2.size, o2.gradient.stops, r2, n2);
  } }]), t2;
}();
var Vi = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "setGlobalMarkerSize", value: function() {
    var t3 = this.w;
    if (t3.globals.markers.size = Array.isArray(t3.config.markers.size) ? t3.config.markers.size : [t3.config.markers.size], t3.globals.markers.size.length > 0) {
      if (t3.globals.markers.size.length < t3.globals.series.length + 1)
        for (var e2 = 0;e2 <= t3.globals.series.length; e2++)
          t3.globals.markers.size[e2] === undefined && t3.globals.markers.size.push(t3.globals.markers.size[0]);
    } else
      t3.globals.markers.size = t3.config.series.map(function(e3) {
        return t3.config.markers.size;
      });
  } }, { key: "plotChartMarkers", value: function(t3) {
    var { pointsPos: e2, seriesIndex: i2, j: a2, pSize: s2, alwaysDrawMarker: r2 } = t3, n2 = r2 !== undefined && r2, o2 = t3.isVirtualPoint, l2 = o2 !== undefined && o2, h2 = this.w, c2 = i2, d2 = e2, u2 = null, g2 = new Mi(this.ctx), p2 = h2.config.markers.discrete && h2.config.markers.discrete.length;
    if (Array.isArray(d2.x))
      for (var f2 = 0;f2 < d2.x.length; f2++) {
        var x2 = undefined, b2 = a2, m2 = !v.isNumber(d2.y[f2]);
        h2.globals.markers.largestSize === 0 && h2.globals.hasNullValues && h2.globals.series[c2][a2 + 1] !== null && !l2 && (m2 = true), a2 === 1 && f2 === 0 && (b2 = 0), a2 === 1 && f2 === 1 && (b2 = 1);
        var y2 = "apexcharts-marker";
        if (h2.config.chart.type !== "line" && h2.config.chart.type !== "area" || h2.globals.comboCharts || h2.config.tooltip.intersect || (y2 += " no-pointer-events"), (Array.isArray(h2.config.markers.size) ? h2.globals.markers.size[i2] > 0 : h2.config.markers.size > 0) || n2 || p2) {
          m2 || (y2 += " w".concat(v.randomId()));
          var w2 = this.getMarkerConfig({ cssClass: y2, seriesIndex: i2, dataPointIndex: b2 });
          if (h2.config.series[c2].data[b2] && (h2.config.series[c2].data[b2].fillColor && (w2.pointFillColor = h2.config.series[c2].data[b2].fillColor), h2.config.series[c2].data[b2].strokeColor && (w2.pointStrokeColor = h2.config.series[c2].data[b2].strokeColor)), s2 !== undefined && (w2.pSize = s2), (d2.x[f2] < -h2.globals.markers.largestSize || d2.x[f2] > h2.globals.gridWidth + h2.globals.markers.largestSize || d2.y[f2] < -h2.globals.markers.largestSize || d2.y[f2] > h2.globals.gridHeight + h2.globals.markers.largestSize) && (w2.pSize = 0), !m2)
            (h2.globals.markers.size[i2] > 0 || n2 || p2) && !u2 && (u2 = g2.group({ class: n2 || p2 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(h2.globals.cuid, ")")), (x2 = g2.drawMarker(d2.x[f2], d2.y[f2], w2)).attr("rel", b2), x2.attr("j", b2), x2.attr("index", i2), x2.node.setAttribute("default-marker-size", w2.pSize), new Li(this.ctx).setSelectionFilter(x2, i2, b2), this.addEvents(x2), u2 && u2.add(x2);
        } else
          h2.globals.pointsArray[i2] === undefined && (h2.globals.pointsArray[i2] = []), h2.globals.pointsArray[i2].push([d2.x[f2], d2.y[f2]]);
      }
    return u2;
  } }, { key: "getMarkerConfig", value: function(t3) {
    var { cssClass: e2, seriesIndex: i2, dataPointIndex: a2 } = t3, s2 = a2 === undefined ? null : a2, r2 = t3.radius, n2 = r2 === undefined ? null : r2, o2 = t3.size, l2 = o2 === undefined ? null : o2, h2 = t3.strokeWidth, c2 = h2 === undefined ? null : h2, d2 = this.w, u2 = this.getMarkerStyle(i2), g2 = l2 === null ? d2.globals.markers.size[i2] : l2, p2 = d2.config.markers;
    return s2 !== null && p2.discrete.length && p2.discrete.map(function(t4) {
      t4.seriesIndex === i2 && t4.dataPointIndex === s2 && (u2.pointStrokeColor = t4.strokeColor, u2.pointFillColor = t4.fillColor, g2 = t4.size, u2.pointShape = t4.shape);
    }), { pSize: n2 === null ? g2 : n2, pRadius: n2 !== null ? n2 : p2.radius, pointStrokeWidth: c2 !== null ? c2 : Array.isArray(p2.strokeWidth) ? p2.strokeWidth[i2] : p2.strokeWidth, pointStrokeColor: u2.pointStrokeColor, pointFillColor: u2.pointFillColor, shape: u2.pointShape || (Array.isArray(p2.shape) ? p2.shape[i2] : p2.shape), class: e2, pointStrokeOpacity: Array.isArray(p2.strokeOpacity) ? p2.strokeOpacity[i2] : p2.strokeOpacity, pointStrokeDashArray: Array.isArray(p2.strokeDashArray) ? p2.strokeDashArray[i2] : p2.strokeDashArray, pointFillOpacity: Array.isArray(p2.fillOpacity) ? p2.fillOpacity[i2] : p2.fillOpacity, seriesIndex: i2 };
  } }, { key: "addEvents", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this.ctx, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this.ctx, t3)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this.ctx, t3)), t3.node.addEventListener("click", e2.config.markers.onClick), t3.node.addEventListener("dblclick", e2.config.markers.onDblClick), t3.node.addEventListener("touchstart", i2.pathMouseDown.bind(this.ctx, t3), { passive: true });
  } }, { key: "getMarkerStyle", value: function(t3) {
    var e2 = this.w, i2 = e2.globals.markers.colors, a2 = e2.config.markers.strokeColor || e2.config.markers.strokeColors;
    return { pointStrokeColor: Array.isArray(a2) ? a2[t3] : a2, pointFillColor: Array.isArray(i2) ? i2[t3] : i2 };
  } }]), t2;
}();
var Ui = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.initialAnim = this.w.config.chart.animations.enabled;
  }
  return s(t2, [{ key: "draw", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx), r2 = i2.realIndex, n2 = i2.pointsPos, o2 = i2.zRatio, l2 = i2.elParent, h2 = s2.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a2.config.chart.type) });
    if (h2.attr("clip-path", "url(#gridRectMarkerMask".concat(a2.globals.cuid, ")")), Array.isArray(n2.x))
      for (var c2 = 0;c2 < n2.x.length; c2++) {
        var d2 = e2 + 1, u2 = true;
        e2 === 0 && c2 === 0 && (d2 = 0), e2 === 0 && c2 === 1 && (d2 = 1);
        var g2 = a2.globals.markers.size[r2];
        if (o2 !== 1 / 0) {
          var p2 = a2.config.plotOptions.bubble;
          g2 = a2.globals.seriesZ[r2][d2], p2.zScaling && (g2 /= o2), p2.minBubbleRadius && g2 < p2.minBubbleRadius && (g2 = p2.minBubbleRadius), p2.maxBubbleRadius && g2 > p2.maxBubbleRadius && (g2 = p2.maxBubbleRadius);
        }
        var f2 = n2.x[c2], x2 = n2.y[c2];
        if (g2 = g2 || 0, x2 !== null && a2.globals.series[r2][d2] !== undefined || (u2 = false), u2) {
          var b2 = this.drawPoint(f2, x2, g2, r2, d2, e2);
          h2.add(b2);
        }
        l2.add(h2);
      }
  } }, { key: "drawPoint", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = this.w, o2 = a2, l2 = new y(this.ctx), h2 = new Li(this.ctx), c2 = new ji(this.ctx), d2 = new Vi(this.ctx), u2 = new Mi(this.ctx), g2 = d2.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: o2, dataPointIndex: s2, radius: n2.config.chart.type === "bubble" || n2.globals.comboCharts && n2.config.series[a2] && n2.config.series[a2].type === "bubble" ? i2 : null }), p2 = c2.fillPath({ seriesNumber: a2, dataPointIndex: s2, color: g2.pointFillColor, patternUnits: "objectBoundingBox", value: n2.globals.series[a2][r2] }), f2 = u2.drawMarker(t3, e2, g2);
    if (n2.config.series[o2].data[s2] && n2.config.series[o2].data[s2].fillColor && (p2 = n2.config.series[o2].data[s2].fillColor), f2.attr({ fill: p2 }), n2.config.chart.dropShadow.enabled) {
      var x2 = n2.config.chart.dropShadow;
      h2.dropShadow(f2, x2, a2);
    }
    if (!this.initialAnim || n2.globals.dataChanged || n2.globals.resized)
      n2.globals.animationEnded = true;
    else {
      var b2 = n2.config.chart.animations.speed;
      l2.animateMarker(f2, b2, n2.globals.easing, function() {
        window.setTimeout(function() {
          l2.animationCompleted(f2);
        }, 100);
      });
    }
    return f2.attr({ rel: s2, j: s2, index: a2, "default-marker-size": g2.pSize }), h2.setSelectionFilter(f2, a2, s2), d2.addEvents(f2), f2.node.classList.add("apexcharts-marker"), f2;
  } }, { key: "centerTextInBubble", value: function(t3) {
    var e2 = this.w;
    return { y: t3 += parseInt(e2.config.dataLabels.style.fontSize, 10) / 4 };
  } }]), t2;
}();
var qi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "dataLabelsCorrection", value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = this.w, l2 = false, h2 = new Mi(this.ctx).getTextRects(i2, n2), c2 = h2.width, d2 = h2.height;
    e2 < 0 && (e2 = 0), e2 > o2.globals.gridHeight + d2 && (e2 = o2.globals.gridHeight + d2 / 2), o2.globals.dataLabelsRects[a2] === undefined && (o2.globals.dataLabelsRects[a2] = []), o2.globals.dataLabelsRects[a2].push({ x: t3, y: e2, width: c2, height: d2 });
    var u2 = o2.globals.dataLabelsRects[a2].length - 2, g2 = o2.globals.lastDrawnDataLabelsIndexes[a2] !== undefined ? o2.globals.lastDrawnDataLabelsIndexes[a2][o2.globals.lastDrawnDataLabelsIndexes[a2].length - 1] : 0;
    if (o2.globals.dataLabelsRects[a2][u2] !== undefined) {
      var p2 = o2.globals.dataLabelsRects[a2][g2];
      (t3 > p2.x + p2.width || e2 > p2.y + p2.height || e2 + d2 < p2.y || t3 + c2 < p2.x) && (l2 = true);
    }
    return (s2 === 0 || r2) && (l2 = true), { x: t3, y: e2, textRects: h2, drawnextLabel: l2 };
  } }, { key: "drawDataLabel", value: function(t3) {
    var e2 = this, i2 = t3.type, a2 = t3.pos, s2 = t3.i, r2 = t3.j, n2 = t3.isRangeStart, o2 = t3.strokeWidth, l2 = o2 === undefined ? 2 : o2, h2 = this.w, c2 = new Mi(this.ctx), d2 = h2.config.dataLabels, u2 = 0, g2 = 0, p2 = r2, f2 = null;
    if (h2.globals.collapsedSeriesIndices.indexOf(s2) !== -1 || !d2.enabled || !Array.isArray(a2.x))
      return f2;
    f2 = c2.group({ class: "apexcharts-data-labels" });
    for (var x2 = 0;x2 < a2.x.length; x2++)
      if (u2 = a2.x[x2] + d2.offsetX, g2 = a2.y[x2] + d2.offsetY + l2, !isNaN(u2)) {
        r2 === 1 && x2 === 0 && (p2 = 0), r2 === 1 && x2 === 1 && (p2 = 1);
        var b2 = h2.globals.series[s2][p2];
        i2 === "rangeArea" && (b2 = n2 ? h2.globals.seriesRangeStart[s2][p2] : h2.globals.seriesRangeEnd[s2][p2]);
        var m2 = "", v2 = function(t4) {
          return h2.config.dataLabels.formatter(t4, { ctx: e2.ctx, seriesIndex: s2, dataPointIndex: p2, w: h2 });
        };
        if (h2.config.chart.type === "bubble")
          m2 = v2(b2 = h2.globals.seriesZ[s2][p2]), g2 = a2.y[x2], g2 = new Ui(this.ctx).centerTextInBubble(g2, s2, p2).y;
        else
          b2 !== undefined && (m2 = v2(b2));
        var y2 = h2.config.dataLabels.textAnchor;
        h2.globals.isSlopeChart && (y2 = p2 === 0 ? "end" : p2 === h2.config.series[s2].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: u2, y: g2, text: m2, i: s2, j: p2, parent: f2, offsetCorrection: true, dataLabelsConfig: h2.config.dataLabels, textAnchor: y2 });
      }
    return f2;
  } }, { key: "plotDataLabelsText", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = t3.x, s2 = t3.y, r2 = t3.i, n2 = t3.j, o2 = t3.text, l2 = t3.textAnchor, h2 = t3.fontSize, c2 = t3.parent, d2 = t3.dataLabelsConfig, u2 = t3.color, g2 = t3.alwaysDrawDataLabel, p2 = t3.offsetCorrection, f2 = t3.className, x2 = null;
    if (Array.isArray(e2.config.dataLabels.enabledOnSeries) && e2.config.dataLabels.enabledOnSeries.indexOf(r2) < 0)
      return x2;
    var b2 = { x: a2, y: s2, drawnextLabel: true, textRects: null };
    p2 && (b2 = this.dataLabelsCorrection(a2, s2, o2, r2, n2, g2, parseInt(d2.style.fontSize, 10))), e2.globals.zoomed || (a2 = b2.x, s2 = b2.y), b2.textRects && (a2 < -20 - b2.textRects.width || a2 > e2.globals.gridWidth + b2.textRects.width + 30) && (o2 = "");
    var m2 = e2.globals.dataLabels.style.colors[r2];
    ((e2.config.chart.type === "bar" || e2.config.chart.type === "rangeBar") && e2.config.plotOptions.bar.distributed || e2.config.dataLabels.distributed) && (m2 = e2.globals.dataLabels.style.colors[n2]), typeof m2 == "function" && (m2 = m2({ series: e2.globals.series, seriesIndex: r2, dataPointIndex: n2, w: e2 })), u2 && (m2 = u2);
    var { offsetX: v2, offsetY: y2 } = d2;
    if (e2.config.chart.type !== "bar" && e2.config.chart.type !== "rangeBar" || (v2 = 0, y2 = 0), e2.globals.isSlopeChart && (n2 !== 0 && (v2 = -2 * d2.offsetX + 5), n2 !== 0 && n2 !== e2.config.series[r2].data.length - 1 && (v2 = 0)), b2.drawnextLabel) {
      if ((x2 = i2.drawText({ width: 100, height: parseInt(d2.style.fontSize, 10), x: a2 + v2, y: s2 + y2, foreColor: m2, textAnchor: l2 || d2.textAnchor, text: o2, fontSize: h2 || d2.style.fontSize, fontFamily: d2.style.fontFamily, fontWeight: d2.style.fontWeight || "normal" })).attr({ class: f2 || "apexcharts-datalabel", cx: a2, cy: s2 }), d2.dropShadow.enabled) {
        var w2 = d2.dropShadow;
        new Li(this.ctx).dropShadow(x2, w2);
      }
      c2.add(x2), e2.globals.lastDrawnDataLabelsIndexes[r2] === undefined && (e2.globals.lastDrawnDataLabelsIndexes[r2] = []), e2.globals.lastDrawnDataLabelsIndexes[r2].push(n2);
    }
    return x2;
  } }, { key: "addBackgroundToDataLabel", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.dataLabels.background, s2 = a2.padding, r2 = a2.padding / 2, n2 = e2.width, o2 = e2.height, l2 = new Mi(this.ctx).drawRect(e2.x - s2, e2.y - r2 / 2, n2 + 2 * s2, o2 + r2, a2.borderRadius, i2.config.chart.background !== "transparent" && i2.config.chart.background ? i2.config.chart.background : "#fff", a2.opacity, a2.borderWidth, a2.borderColor);
    a2.dropShadow.enabled && new Li(this.ctx).dropShadow(l2, a2.dropShadow);
    return l2;
  } }, { key: "dataLabelsBackground", value: function() {
    var t3 = this.w;
    if (t3.config.chart.type !== "bubble")
      for (var e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i2 = 0;i2 < e2.length; i2++) {
        var a2 = e2[i2], s2 = a2.getBBox(), r2 = null;
        if (s2.width && s2.height && (r2 = this.addBackgroundToDataLabel(a2, s2)), r2) {
          a2.parentNode.insertBefore(r2.node, a2);
          var n2 = a2.getAttribute("fill");
          t3.config.chart.animations.enabled && !t3.globals.resized && !t3.globals.dataChanged ? r2.animate().attr({ fill: n2 }) : r2.attr({ fill: n2 }), a2.setAttribute("fill", t3.config.dataLabels.background.foreColor);
        }
      }
  } }, { key: "bringForward", value: function() {
    for (var t3 = this.w, e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a2 = 0;a2 < e2.length; a2++)
      i2 && i2.insertBefore(e2[a2], i2.nextSibling);
  } }]), t2;
}();
var Zi = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.legendInactiveClass = "legend-mouseover-inactive";
  }
  return s(t2, [{ key: "getAllSeriesEls", value: function() {
    return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
  } }, { key: "getSeriesByName", value: function(t3) {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(v.escapeString(t3), "']"));
  } }, { key: "isSeriesHidden", value: function(t3) {
    var e2 = this.getSeriesByName(t3), i2 = parseInt(e2.getAttribute("data:realIndex"), 10);
    return { isHidden: e2.classList.contains("apexcharts-series-collapsed"), realIndex: i2 };
  } }, { key: "addCollapsedClassToSeries", value: function(t3, e2) {
    var i2 = this.w;
    function a2(i3) {
      for (var a3 = 0;a3 < i3.length; a3++)
        i3[a3].index === e2 && t3.node.classList.add("apexcharts-series-collapsed");
    }
    a2(i2.globals.collapsedSeries), a2(i2.globals.ancillaryCollapsedSeries);
  } }, { key: "toggleSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    return this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, e2.isHidden), e2.isHidden;
  } }, { key: "showSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    e2.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, true);
  } }, { key: "hideSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    e2.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, false);
  } }, { key: "resetSeries", value: function() {
    var t3 = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0], e2 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1], i2 = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2], a2 = this.w, s2 = v.clone(a2.globals.initialSeries);
    a2.globals.previousPaths = [], i2 ? (a2.globals.collapsedSeries = [], a2.globals.ancillaryCollapsedSeries = [], a2.globals.collapsedSeriesIndices = [], a2.globals.ancillaryCollapsedSeriesIndices = []) : s2 = this.emptyCollapsedSeries(s2), a2.config.series = s2, t3 && (e2 && (a2.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled));
  } }, { key: "emptyCollapsedSeries", value: function(t3) {
    for (var e2 = this.w, i2 = 0;i2 < t3.length; i2++)
      e2.globals.collapsedSeriesIndices.indexOf(i2) > -1 && (t3[i2].data = []);
    return t3;
  } }, { key: "highlightSeries", value: function(t3) {
    var e2 = this.w, i2 = this.getSeriesByName(t3), a2 = parseInt(i2 == null ? undefined : i2.getAttribute("data:realIndex"), 10), s2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"), r2 = null, n2 = null, o2 = null;
    if (e2.globals.axisCharts || e2.config.chart.type === "radialBar")
      if (e2.globals.axisCharts) {
        r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(a2, "']")), n2 = e2.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(a2, "']"));
        var l2 = e2.globals.seriesYAxisReverseMap[a2];
        o2 = e2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l2, "']"));
      } else
        r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a2 + 1, "']"));
    else
      r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a2 + 1, "'] path"));
    for (var h2 = 0;h2 < s2.length; h2++)
      s2[h2].classList.add(this.legendInactiveClass);
    if (r2)
      e2.globals.axisCharts || r2.parentNode.classList.remove(this.legendInactiveClass), r2.classList.remove(this.legendInactiveClass), n2 !== null && n2.classList.remove(this.legendInactiveClass), o2 !== null && o2.classList.remove(this.legendInactiveClass);
    else
      for (var c2 = 0;c2 < s2.length; c2++)
        s2[c2].classList.remove(this.legendInactiveClass);
  } }, { key: "toggleSeriesOnHover", value: function(t3, e2) {
    var i2 = this.w;
    e2 || (e2 = t3.target);
    var a2 = i2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
    if (t3.type === "mousemove") {
      var s2 = parseInt(e2.getAttribute("rel"), 10) - 1;
      this.highlightSeries(i2.globals.seriesNames[s2]);
    } else if (t3.type === "mouseout")
      for (var r2 = 0;r2 < a2.length; r2++)
        a2[r2].classList.remove(this.legendInactiveClass);
  } }, { key: "highlightRangeInSeries", value: function(t3, e2) {
    var i2 = this, a2 = this.w, s2 = a2.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r2 = function(t4) {
      for (var e3 = 0;e3 < s2.length; e3++)
        s2[e3].classList[t4](i2.legendInactiveClass);
    };
    if (t3.type === "mousemove") {
      var n2 = parseInt(e2.getAttribute("rel"), 10) - 1;
      r2("add");
      var o2 = a2.config.plotOptions.heatmap.colorScale.ranges;
      (function(t4, e3) {
        for (var a3 = 0;a3 < s2.length; a3++) {
          var r3 = Number(s2[a3].getAttribute("val"));
          r3 >= t4.from && (r3 < t4.to || t4.to === e3 && r3 === e3) && s2[a3].classList.remove(i2.legendInactiveClass);
        }
      })(o2[n2], o2.reduce(function(t4, e3) {
        return Math.max(t4, e3.to);
      }, 0));
    } else
      t3.type === "mouseout" && r2("remove");
  } }, { key: "getActiveConfigSeriesIndex", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "asc", e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [], i2 = this.w, a2 = 0;
    if (i2.config.series.length > 1) {
      for (var s2 = i2.config.series.map(function(t4, a3) {
        return t4.data && t4.data.length > 0 && i2.globals.collapsedSeriesIndices.indexOf(a3) === -1 && (!i2.globals.comboCharts || e2.length === 0 || e2.length && e2.indexOf(i2.config.series[a3].type) > -1) ? a3 : -1;
      }), r2 = t3 === "asc" ? 0 : s2.length - 1;t3 === "asc" ? r2 < s2.length : r2 >= 0; t3 === "asc" ? r2++ : r2--)
        if (s2[r2] !== -1) {
          a2 = s2[r2];
          break;
        }
    }
    return a2;
  } }, { key: "getBarSeriesIndices", value: function() {
    return this.w.globals.comboCharts ? this.w.config.series.map(function(t3, e2) {
      return t3.type === "bar" || t3.type === "column" ? e2 : -1;
    }).filter(function(t3) {
      return t3 !== -1;
    }) : this.w.config.series.map(function(t3, e2) {
      return e2;
    });
  } }, { key: "getPreviousPaths", value: function() {
    var t3 = this.w;
    function e2(e3, i3, a3) {
      for (var s3 = e3[i3].childNodes, r2 = { type: a3, paths: [], realIndex: e3[i3].getAttribute("data:realIndex") }, n2 = 0;n2 < s3.length; n2++)
        if (s3[n2].hasAttribute("pathTo")) {
          var o2 = s3[n2].getAttribute("pathTo");
          r2.paths.push({ d: o2 });
        }
      t3.globals.previousPaths.push(r2);
    }
    t3.globals.previousPaths = [];
    ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(i3) {
      for (var a3, s3 = (a3 = i3, t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a3, "-series .apexcharts-series"))), r2 = 0;r2 < s3.length; r2++)
        e2(s3, r2, i3);
    });
    var i2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series"));
    if (i2.length > 0)
      for (var a2 = function(e3) {
        for (var i3 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e3, "'] rect")), a3 = [], s3 = function(t4) {
          var e4 = function(e5) {
            return i3[t4].getAttribute(e5);
          }, s4 = { x: parseFloat(e4("x")), y: parseFloat(e4("y")), width: parseFloat(e4("width")), height: parseFloat(e4("height")) };
          a3.push({ rect: s4, color: i3[t4].getAttribute("color") });
        }, r2 = 0;r2 < i3.length; r2++)
          s3(r2);
        t3.globals.previousPaths.push(a3);
      }, s2 = 0;s2 < i2.length; s2++)
        a2(s2);
    t3.globals.axisCharts || (t3.globals.previousPaths = t3.globals.series);
  } }, { key: "clearPreviousPaths", value: function() {
    var t3 = this.w;
    t3.globals.previousPaths = [], t3.globals.allSeriesCollapsed = false;
  } }, { key: "handleNoData", value: function() {
    var t3 = this.w, e2 = t3.config.noData, i2 = new Mi(this.ctx), a2 = t3.globals.svgWidth / 2, s2 = t3.globals.svgHeight / 2, r2 = "middle";
    if (t3.globals.noData = true, t3.globals.animationEnded = true, e2.align === "left" ? (a2 = 10, r2 = "start") : e2.align === "right" && (a2 = t3.globals.svgWidth - 10, r2 = "end"), e2.verticalAlign === "top" ? s2 = 50 : e2.verticalAlign === "bottom" && (s2 = t3.globals.svgHeight - 50), a2 += e2.offsetX, s2 = s2 + parseInt(e2.style.fontSize, 10) + 2 + e2.offsetY, e2.text !== undefined && e2.text !== "") {
      var n2 = i2.drawText({ x: a2, y: s2, text: e2.text, textAnchor: r2, fontSize: e2.style.fontSize, fontFamily: e2.style.fontFamily, foreColor: e2.style.color, opacity: 1, class: "apexcharts-text-nodata" });
      t3.globals.dom.Paper.add(n2);
    }
  } }, { key: "setNullSeriesToZeroValues", value: function(t3) {
    for (var e2 = this.w, i2 = 0;i2 < t3.length; i2++)
      if (t3[i2].length === 0)
        for (var a2 = 0;a2 < t3[e2.globals.maxValsInArrayIndex].length; a2++)
          t3[i2].push(0);
    return t3;
  } }, { key: "hasAllSeriesEqualX", value: function() {
    for (var t3 = true, e2 = this.w, i2 = this.filteredSeriesX(), a2 = 0;a2 < i2.length - 1; a2++)
      if (i2[a2][0] !== i2[a2 + 1][0]) {
        t3 = false;
        break;
      }
    return e2.globals.allSeriesHasEqualX = t3, t3;
  } }, { key: "filteredSeriesX", value: function() {
    var t3 = this.w.globals.seriesX.map(function(t4) {
      return t4.length > 0 ? t4 : [];
    });
    return t3;
  } }]), t2;
}();
var $i = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new Pi(this.ctx);
  }
  return s(t2, [{ key: "isMultiFormat", value: function() {
    return this.isFormatXY() || this.isFormat2DArray();
  } }, { key: "isFormatXY", value: function() {
    var t3 = this.w.config.series.slice(), e2 = new Zi(this.ctx);
    if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), t3[this.activeSeriesIndex].data !== undefined && t3[this.activeSeriesIndex].data.length > 0 && t3[this.activeSeriesIndex].data[0] !== null && t3[this.activeSeriesIndex].data[0].x !== undefined && t3[this.activeSeriesIndex].data[0] !== null)
      return true;
  } }, { key: "isFormat2DArray", value: function() {
    var t3 = this.w.config.series.slice(), e2 = new Zi(this.ctx);
    if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), t3[this.activeSeriesIndex].data !== undefined && t3[this.activeSeriesIndex].data.length > 0 && t3[this.activeSeriesIndex].data[0] !== undefined && t3[this.activeSeriesIndex].data[0] !== null && t3[this.activeSeriesIndex].data[0].constructor === Array)
      return true;
  } }, { key: "handleFormat2DArray", value: function(t3, e2) {
    for (var i2 = this.w.config, a2 = this.w.globals, s2 = i2.chart.type === "boxPlot" || i2.series[e2].type === "boxPlot", r2 = 0;r2 < t3[e2].data.length; r2++)
      if (t3[e2].data[r2][1] !== undefined && (Array.isArray(t3[e2].data[r2][1]) && t3[e2].data[r2][1].length === 4 && !s2 ? this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][1][3])) : t3[e2].data[r2].length >= 5 ? this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][4])) : this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][1])), a2.dataFormatXNumeric = true), i2.xaxis.type === "datetime") {
        var n2 = new Date(t3[e2].data[r2][0]);
        n2 = new Date(n2).getTime(), this.twoDSeriesX.push(n2);
      } else
        this.twoDSeriesX.push(t3[e2].data[r2][0]);
    for (var o2 = 0;o2 < t3[e2].data.length; o2++)
      t3[e2].data[o2][2] !== undefined && (this.threeDSeries.push(t3[e2].data[o2][2]), a2.isDataXYZ = true);
  } }, { key: "handleFormatXY", value: function(t3, e2) {
    var i2 = this.w.config, a2 = this.w.globals, s2 = new zi(this.ctx), r2 = e2;
    a2.collapsedSeriesIndices.indexOf(e2) > -1 && (r2 = this.activeSeriesIndex);
    for (var n2 = 0;n2 < t3[e2].data.length; n2++)
      t3[e2].data[n2].y !== undefined && (Array.isArray(t3[e2].data[n2].y) ? this.twoDSeries.push(v.parseNumber(t3[e2].data[n2].y[t3[e2].data[n2].y.length - 1])) : this.twoDSeries.push(v.parseNumber(t3[e2].data[n2].y))), t3[e2].data[n2].goals !== undefined && Array.isArray(t3[e2].data[n2].goals) ? (this.seriesGoals[e2] === undefined && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(t3[e2].data[n2].goals)) : (this.seriesGoals[e2] === undefined && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(null));
    for (var o2 = 0;o2 < t3[r2].data.length; o2++) {
      var l2 = typeof t3[r2].data[o2].x == "string", h2 = Array.isArray(t3[r2].data[o2].x), c2 = !h2 && !!s2.isValidDate(t3[r2].data[o2].x);
      if (l2 || c2)
        if (l2 || i2.xaxis.convertedCatToNumeric) {
          var d2 = a2.isBarHorizontal && a2.isRangeData;
          i2.xaxis.type !== "datetime" || d2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[o2].x), isNaN(t3[r2].data[o2].x) || this.w.config.xaxis.type === "category" || typeof t3[r2].data[o2].x == "string" || (a2.isXNumeric = true)) : this.twoDSeriesX.push(s2.parseDate(t3[r2].data[o2].x));
        } else
          i2.xaxis.type === "datetime" ? this.twoDSeriesX.push(s2.parseDate(t3[r2].data[o2].x.toString())) : (a2.dataFormatXNumeric = true, a2.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t3[r2].data[o2].x)));
      else
        h2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[o2].x)) : (a2.isXNumeric = true, a2.dataFormatXNumeric = true, this.twoDSeriesX.push(t3[r2].data[o2].x));
    }
    if (t3[e2].data[0] && t3[e2].data[0].z !== undefined) {
      for (var u2 = 0;u2 < t3[e2].data.length; u2++)
        this.threeDSeries.push(t3[e2].data[u2].z);
      a2.isDataXYZ = true;
    }
  } }, { key: "handleRangeData", value: function(t3, e2) {
    var i2 = this.w.globals, a2 = {};
    return this.isFormat2DArray() ? a2 = this.handleRangeDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleRangeDataFormat("xy", t3, e2)), i2.seriesRangeStart.push(a2.start === undefined ? [] : a2.start), i2.seriesRangeEnd.push(a2.end === undefined ? [] : a2.end), i2.seriesRange.push(a2.rangeUniques), i2.seriesRange.forEach(function(t4, e3) {
      t4 && t4.forEach(function(t5, e4) {
        t5.y.forEach(function(e5, i3) {
          for (var a3 = 0;a3 < t5.y.length; a3++)
            if (i3 !== a3) {
              var { y1: s2, y2: r2 } = e5, n2 = t5.y[a3].y1;
              s2 <= t5.y[a3].y2 && n2 <= r2 && (t5.overlaps.indexOf(e5.rangeName) < 0 && t5.overlaps.push(e5.rangeName), t5.overlaps.indexOf(t5.y[a3].rangeName) < 0 && t5.overlaps.push(t5.y[a3].rangeName));
            }
        });
      });
    }), a2;
  } }, { key: "handleCandleStickBoxData", value: function(t3, e2) {
    var i2 = this.w.globals, a2 = {};
    return this.isFormat2DArray() ? a2 = this.handleCandleStickBoxDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleCandleStickBoxDataFormat("xy", t3, e2)), i2.seriesCandleO[e2] = a2.o, i2.seriesCandleH[e2] = a2.h, i2.seriesCandleM[e2] = a2.m, i2.seriesCandleL[e2] = a2.l, i2.seriesCandleC[e2] = a2.c, a2;
  } }, { key: "handleRangeDataFormat", value: function(t3, e2, i2) {
    var a2 = [], s2 = [], r2 = e2[i2].data.filter(function(t4, e3, i3) {
      return e3 === i3.findIndex(function(e4) {
        return e4.x === t4.x;
      });
    }).map(function(t4, e3) {
      return { x: t4.x, overlaps: [], y: [] };
    });
    if (t3 === "array")
      for (var n2 = 0;n2 < e2[i2].data.length; n2++)
        Array.isArray(e2[i2].data[n2]) ? (a2.push(e2[i2].data[n2][1][0]), s2.push(e2[i2].data[n2][1][1])) : (a2.push(e2[i2].data[n2]), s2.push(e2[i2].data[n2]));
    else if (t3 === "xy")
      for (var o2 = function(t4) {
        var n3 = Array.isArray(e2[i2].data[t4].y), o3 = v.randomId(), l3 = e2[i2].data[t4].x, h2 = { y1: n3 ? e2[i2].data[t4].y[0] : e2[i2].data[t4].y, y2: n3 ? e2[i2].data[t4].y[1] : e2[i2].data[t4].y, rangeName: o3 };
        e2[i2].data[t4].rangeName = o3;
        var c2 = r2.findIndex(function(t5) {
          return t5.x === l3;
        });
        r2[c2].y.push(h2), a2.push(h2.y1), s2.push(h2.y2);
      }, l2 = 0;l2 < e2[i2].data.length; l2++)
        o2(l2);
    return { start: a2, end: s2, rangeUniques: r2 };
  } }, { key: "handleCandleStickBoxDataFormat", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.config.chart.type === "boxPlot" || a2.config.series[i2].type === "boxPlot", r2 = [], n2 = [], o2 = [], l2 = [], h2 = [];
    if (t3 === "array")
      if (s2 && e2[i2].data[0].length === 6 || !s2 && e2[i2].data[0].length === 5)
        for (var c2 = 0;c2 < e2[i2].data.length; c2++)
          r2.push(e2[i2].data[c2][1]), n2.push(e2[i2].data[c2][2]), s2 ? (o2.push(e2[i2].data[c2][3]), l2.push(e2[i2].data[c2][4]), h2.push(e2[i2].data[c2][5])) : (l2.push(e2[i2].data[c2][3]), h2.push(e2[i2].data[c2][4]));
      else
        for (var d2 = 0;d2 < e2[i2].data.length; d2++)
          Array.isArray(e2[i2].data[d2][1]) && (r2.push(e2[i2].data[d2][1][0]), n2.push(e2[i2].data[d2][1][1]), s2 ? (o2.push(e2[i2].data[d2][1][2]), l2.push(e2[i2].data[d2][1][3]), h2.push(e2[i2].data[d2][1][4])) : (l2.push(e2[i2].data[d2][1][2]), h2.push(e2[i2].data[d2][1][3])));
    else if (t3 === "xy")
      for (var u2 = 0;u2 < e2[i2].data.length; u2++)
        Array.isArray(e2[i2].data[u2].y) && (r2.push(e2[i2].data[u2].y[0]), n2.push(e2[i2].data[u2].y[1]), s2 ? (o2.push(e2[i2].data[u2].y[2]), l2.push(e2[i2].data[u2].y[3]), h2.push(e2[i2].data[u2].y[4])) : (l2.push(e2[i2].data[u2].y[2]), h2.push(e2[i2].data[u2].y[3])));
    return { o: r2, h: n2, m: o2, l: l2, c: h2 };
  } }, { key: "parseDataAxisCharts", value: function(t3) {
    var e2 = this, i2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.ctx, a2 = this.w.config, s2 = this.w.globals, r2 = new zi(i2), n2 = a2.labels.length > 0 ? a2.labels.slice() : a2.xaxis.categories.slice();
    s2.isRangeBar = a2.chart.type === "rangeBar" && s2.isBarHorizontal, s2.hasXaxisGroups = a2.xaxis.type === "category" && a2.xaxis.group.groups.length > 0, s2.hasXaxisGroups && (s2.groups = a2.xaxis.group.groups), t3.forEach(function(t4, e3) {
      t4.name !== undefined ? s2.seriesNames.push(t4.name) : s2.seriesNames.push("series-" + parseInt(e3 + 1, 10));
    }), this.coreUtils.setSeriesYAxisMappings();
    var o2 = [], l2 = f(new Set(a2.series.map(function(t4) {
      return t4.group;
    })));
    a2.series.forEach(function(t4, e3) {
      var i3 = l2.indexOf(t4.group);
      o2[i3] || (o2[i3] = []), o2[i3].push(s2.seriesNames[e3]);
    }), s2.seriesGroups = o2;
    for (var h2 = function() {
      for (var t4 = 0;t4 < n2.length; t4++)
        if (typeof n2[t4] == "string") {
          if (!r2.isValidDate(n2[t4]))
            throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
          e2.twoDSeriesX.push(r2.parseDate(n2[t4]));
        } else
          e2.twoDSeriesX.push(n2[t4]);
    }, c2 = 0;c2 < t3.length; c2++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], t3[c2].data === undefined)
        return void console.error("It is a possibility that you may have not included 'data' property in series.");
      if (a2.chart.type !== "rangeBar" && a2.chart.type !== "rangeArea" && t3[c2].type !== "rangeBar" && t3[c2].type !== "rangeArea" || (s2.isRangeData = true, a2.chart.type !== "rangeBar" && a2.chart.type !== "rangeArea" || this.handleRangeData(t3, c2)), this.isMultiFormat())
        this.isFormat2DArray() ? this.handleFormat2DArray(t3, c2) : this.isFormatXY() && this.handleFormatXY(t3, c2), a2.chart.type !== "candlestick" && t3[c2].type !== "candlestick" && a2.chart.type !== "boxPlot" && t3[c2].type !== "boxPlot" || this.handleCandleStickBoxData(t3, c2), s2.series.push(this.twoDSeries), s2.labels.push(this.twoDSeriesX), s2.seriesX.push(this.twoDSeriesX), s2.seriesGoals = this.seriesGoals, c2 !== this.activeSeriesIndex || this.fallbackToCategory || (s2.isXNumeric = true);
      else {
        a2.xaxis.type === "datetime" ? (s2.isXNumeric = true, h2(), s2.seriesX.push(this.twoDSeriesX)) : a2.xaxis.type === "numeric" && (s2.isXNumeric = true, n2.length > 0 && (this.twoDSeriesX = n2, s2.seriesX.push(this.twoDSeriesX))), s2.labels.push(this.twoDSeriesX);
        var d2 = t3[c2].data.map(function(t4) {
          return v.parseNumber(t4);
        });
        s2.series.push(d2);
      }
      s2.seriesZ.push(this.threeDSeries), t3[c2].color !== undefined ? s2.seriesColors.push(t3[c2].color) : s2.seriesColors.push(undefined);
    }
    return this.w;
  } }, { key: "parseDataNonAxisCharts", value: function(t3) {
    var e2 = this.w.globals, i2 = this.w.config;
    e2.series = t3.slice(), e2.seriesNames = i2.labels.slice();
    for (var a2 = 0;a2 < e2.series.length; a2++)
      e2.seriesNames[a2] === undefined && e2.seriesNames.push("series-" + (a2 + 1));
    return this.w;
  } }, { key: "handleExternalLabelsData", value: function(t3) {
    var e2 = this.w.config, i2 = this.w.globals;
    if (e2.xaxis.categories.length > 0)
      i2.labels = e2.xaxis.categories;
    else if (e2.labels.length > 0)
      i2.labels = e2.labels.slice();
    else if (this.fallbackToCategory) {
      if (i2.labels = i2.labels[0], i2.seriesRange.length && (i2.seriesRange.map(function(t4) {
        t4.forEach(function(t5) {
          i2.labels.indexOf(t5.x) < 0 && t5.x && i2.labels.push(t5.x);
        });
      }), i2.labels = Array.from(new Set(i2.labels.map(JSON.stringify)), JSON.parse)), e2.xaxis.convertedCatToNumeric)
        new Ni(e2).convertCatToNumericXaxis(e2, this.ctx, i2.seriesX[0]), this._generateExternalLabels(t3);
    } else
      this._generateExternalLabels(t3);
  } }, { key: "_generateExternalLabels", value: function(t3) {
    var e2 = this.w.globals, i2 = this.w.config, a2 = [];
    if (e2.axisCharts) {
      if (e2.series.length > 0)
        if (this.isFormatXY())
          for (var s2 = i2.series.map(function(t4, e3) {
            return t4.data.filter(function(t5, e4, i3) {
              return i3.findIndex(function(e5) {
                return e5.x === t5.x;
              }) === e4;
            });
          }), r2 = s2.reduce(function(t4, e3, i3, a3) {
            return a3[t4].length > e3.length ? t4 : i3;
          }, 0), n2 = 0;n2 < s2[r2].length; n2++)
            a2.push(n2 + 1);
        else
          for (var o2 = 0;o2 < e2.series[e2.maxValsInArrayIndex].length; o2++)
            a2.push(o2 + 1);
      e2.seriesX = [];
      for (var l2 = 0;l2 < t3.length; l2++)
        e2.seriesX.push(a2);
      this.w.globals.isBarHorizontal || (e2.isXNumeric = true);
    }
    if (a2.length === 0) {
      a2 = e2.axisCharts ? [] : e2.series.map(function(t4, e3) {
        return e3 + 1;
      });
      for (var h2 = 0;h2 < t3.length; h2++)
        e2.seriesX.push(a2);
    }
    e2.labels = a2, i2.xaxis.convertedCatToNumeric && (e2.categoryLabels = a2.map(function(t4) {
      return i2.xaxis.labels.formatter(t4);
    })), e2.noLabelsProvided = true;
  } }, { key: "parseData", value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = e2.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a2.axisCharts ? (this.parseDataAxisCharts(t3), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t3), i2.chart.stacked) {
      var s2 = new Zi(this.ctx);
      a2.series = s2.setNullSeriesToZeroValues(a2.series);
    }
    this.coreUtils.getSeriesTotals(), a2.axisCharts && (a2.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a2.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a2.dataFormatXNumeric || a2.isXNumeric && (i2.xaxis.type !== "numeric" || i2.labels.length !== 0 || i2.xaxis.categories.length !== 0) || this.handleExternalLabelsData(t3);
    for (var r2 = this.coreUtils.getCategoryLabels(a2.labels), n2 = 0;n2 < r2.length; n2++)
      if (Array.isArray(r2[n2])) {
        a2.isMultiLineX = true;
        break;
      }
  } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
    var t3 = this.w, e2 = [];
    t3.globals.seriesYAxisMap.forEach(function(i2, a2) {
      var s2 = 0;
      i2.forEach(function(e3) {
        t3.globals.collapsedSeriesIndices.indexOf(e3) !== -1 && s2++;
      }), s2 > 0 && s2 == i2.length && e2.push(a2);
    }), t3.globals.ignoreYAxisIndexes = e2.map(function(t4) {
      return t4;
    });
  } }]), t2;
}();
var Ji = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "svgStringToNode", value: function(t3) {
    return new DOMParser().parseFromString(t3, "image/svg+xml").documentElement;
  } }, { key: "scaleSvgNode", value: function(t3, e2) {
    var i2 = parseFloat(t3.getAttributeNS(null, "width")), a2 = parseFloat(t3.getAttributeNS(null, "height"));
    t3.setAttributeNS(null, "width", i2 * e2), t3.setAttributeNS(null, "height", a2 * e2), t3.setAttributeNS(null, "viewBox", "0 0 " + i2 + " " + a2);
  } }, { key: "getSvgString", value: function(t3) {
    var e2 = this;
    return new Promise(function(i2) {
      var a2 = e2.w, s2 = t3 || a2.config.chart.toolbar.export.scale || a2.config.chart.toolbar.export.width / a2.globals.svgWidth;
      s2 || (s2 = 1);
      var r2 = a2.globals.svgWidth * s2, n2 = a2.globals.svgHeight * s2, o2 = a2.globals.dom.elWrap.cloneNode(true);
      o2.style.width = r2 + "px", o2.style.height = n2 + "px";
      var l2 = new XMLSerializer().serializeToString(o2), h2 = '\n        <svg xmlns="http://www.w3.org/2000/svg"\n          version="1.1"\n          xmlns:xlink="http://www.w3.org/1999/xlink"\n          class="apexcharts-svg"\n          xmlns:data="ApexChartsNS"\n          transform="translate(0, 0)"\n          width="'.concat(a2.globals.svgWidth, 'px" height="').concat(a2.globals.svgHeight, 'px">\n          <foreignObject width="100%" height="100%">\n            <div xmlns="http://www.w3.org/1999/xhtml" style="width:').concat(r2, "px; height:").concat(n2, 'px;">\n            <style type="text/css">\n              .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {\n                display: none;\n              }\n            </style>\n              ').concat(l2, "\n            </div>\n          </foreignObject>\n        </svg>\n      "), c2 = e2.svgStringToNode(h2);
      s2 !== 1 && e2.scaleSvgNode(c2, s2), e2.convertImagesToBase64(c2).then(function() {
        h2 = new XMLSerializer().serializeToString(c2), i2(h2.replace(/&nbsp;/g, "&#160;"));
      });
    });
  } }, { key: "convertImagesToBase64", value: function(t3) {
    var e2 = this, i2 = t3.getElementsByTagName("image"), a2 = Array.from(i2).map(function(t4) {
      var i3 = t4.getAttributeNS("http://www.w3.org/1999/xlink", "href");
      return i3 && !i3.startsWith("data:") ? e2.getBase64FromUrl(i3).then(function(e3) {
        t4.setAttributeNS("http://www.w3.org/1999/xlink", "href", e3);
      }).catch(function(t5) {
        console.error("Error converting image to base64:", t5);
      }) : Promise.resolve();
    });
    return Promise.all(a2);
  } }, { key: "getBase64FromUrl", value: function(t3) {
    return new Promise(function(e2, i2) {
      var a2 = new Image;
      a2.crossOrigin = "Anonymous", a2.onload = function() {
        var t4 = document.createElement("canvas");
        t4.width = a2.width, t4.height = a2.height, t4.getContext("2d").drawImage(a2, 0, 0), e2(t4.toDataURL());
      }, a2.onerror = i2, a2.src = t3;
    });
  } }, { key: "svgUrl", value: function() {
    var t3 = this;
    return new Promise(function(e2) {
      t3.getSvgString().then(function(t4) {
        var i2 = new Blob([t4], { type: "image/svg+xml;charset=utf-8" });
        e2(URL.createObjectURL(i2));
      });
    });
  } }, { key: "dataURI", value: function(t3) {
    var e2 = this;
    return new Promise(function(i2) {
      var a2 = e2.w, s2 = t3 ? t3.scale || t3.width / a2.globals.svgWidth : 1, r2 = document.createElement("canvas");
      r2.width = a2.globals.svgWidth * s2, r2.height = parseInt(a2.globals.dom.elWrap.style.height, 10) * s2;
      var n2 = a2.config.chart.background !== "transparent" && a2.config.chart.background ? a2.config.chart.background : "#fff", o2 = r2.getContext("2d");
      o2.fillStyle = n2, o2.fillRect(0, 0, r2.width * s2, r2.height * s2), e2.getSvgString(s2).then(function(t4) {
        var e3 = "data:image/svg+xml," + encodeURIComponent(t4), a3 = new Image;
        a3.crossOrigin = "anonymous", a3.onload = function() {
          if (o2.drawImage(a3, 0, 0), r2.msToBlob) {
            var t5 = r2.msToBlob();
            i2({ blob: t5 });
          } else {
            var e4 = r2.toDataURL("image/png");
            i2({ imgURI: e4 });
          }
        }, a3.src = e3;
      });
    });
  } }, { key: "exportToSVG", value: function() {
    var t3 = this;
    this.svgUrl().then(function(e2) {
      t3.triggerDownload(e2, t3.w.config.chart.toolbar.export.svg.filename, ".svg");
    });
  } }, { key: "exportToPng", value: function() {
    var t3 = this, e2 = this.w.config.chart.toolbar.export.scale, i2 = this.w.config.chart.toolbar.export.width, a2 = e2 ? { scale: e2 } : i2 ? { width: i2 } : undefined;
    this.dataURI(a2).then(function(e3) {
      var { imgURI: i3, blob: a3 } = e3;
      a3 ? navigator.msSaveOrOpenBlob(a3, t3.w.globals.chartID + ".png") : t3.triggerDownload(i3, t3.w.config.chart.toolbar.export.png.filename, ".png");
    });
  } }, { key: "exportToCSV", value: function(t3) {
    var e2 = this, i2 = t3.series, a2 = t3.fileName, s2 = t3.columnDelimiter, r2 = s2 === undefined ? "," : s2, n2 = t3.lineDelimiter, o2 = n2 === undefined ? "\n" : n2, l2 = this.w;
    i2 || (i2 = l2.config.series);
    var h2 = [], c2 = [], d2 = "", u2 = l2.globals.series.map(function(t4, e3) {
      return l2.globals.collapsedSeriesIndices.indexOf(e3) === -1 ? t4 : [];
    }), g2 = function(t4) {
      return typeof l2.config.chart.toolbar.export.csv.categoryFormatter == "function" ? l2.config.chart.toolbar.export.csv.categoryFormatter(t4) : l2.config.xaxis.type === "datetime" && String(t4).length >= 10 ? new Date(t4).toDateString() : v.isNumber(t4) ? t4 : t4.split(r2).join("");
    }, p2 = function(t4) {
      return typeof l2.config.chart.toolbar.export.csv.valueFormatter == "function" ? l2.config.chart.toolbar.export.csv.valueFormatter(t4) : t4;
    }, x2 = Math.max.apply(Math, f(i2.map(function(t4) {
      return t4.data ? t4.data.length : 0;
    }))), b2 = new $i(this.ctx), m2 = new Ri(this.ctx), y2 = function(t4) {
      var i3 = "";
      if (l2.globals.axisCharts) {
        if (l2.config.xaxis.type === "category" || l2.config.xaxis.convertedCatToNumeric)
          if (l2.globals.isBarHorizontal) {
            var a3 = l2.globals.yLabelFormatters[0], s3 = new Zi(e2.ctx).getActiveConfigSeriesIndex();
            i3 = a3(l2.globals.labels[t4], { seriesIndex: s3, dataPointIndex: t4, w: l2 });
          } else
            i3 = m2.getLabel(l2.globals.labels, l2.globals.timescaleLabels, 0, t4).text;
        l2.config.xaxis.type === "datetime" && (l2.config.xaxis.categories.length ? i3 = l2.config.xaxis.categories[t4] : l2.config.labels.length && (i3 = l2.config.labels[t4]));
      } else
        i3 = l2.config.labels[t4];
      return i3 === null ? "nullvalue" : (Array.isArray(i3) && (i3 = i3.join(" ")), v.isNumber(i3) ? i3 : i3.split(r2).join(""));
    }, w2 = function(t4, e3) {
      if (h2.length && e3 === 0 && c2.push(h2.join(r2)), t4.data) {
        t4.data = t4.data.length && t4.data || f(Array(x2)).map(function() {
          return "";
        });
        for (var a3 = 0;a3 < t4.data.length; a3++) {
          h2 = [];
          var s3 = y2(a3);
          if (s3 !== "nullvalue") {
            if (s3 || (b2.isFormatXY() ? s3 = i2[e3].data[a3].x : b2.isFormat2DArray() && (s3 = i2[e3].data[a3] ? i2[e3].data[a3][0] : "")), e3 === 0) {
              h2.push(g2(s3));
              for (var n3 = 0;n3 < l2.globals.series.length; n3++) {
                var o3, d3 = b2.isFormatXY() ? (o3 = i2[n3].data[a3]) === null || o3 === undefined ? undefined : o3.y : u2[n3][a3];
                h2.push(p2(d3));
              }
            }
            (l2.config.chart.type === "candlestick" || t4.type && t4.type === "candlestick") && (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), (l2.config.chart.type === "boxPlot" || t4.type && t4.type === "boxPlot") && (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleM[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), l2.config.chart.type === "rangeBar" && (h2.pop(), h2.push(l2.globals.seriesRangeStart[e3][a3]), h2.push(l2.globals.seriesRangeEnd[e3][a3])), h2.length && c2.push(h2.join(r2));
          }
        }
      }
    };
    h2.push(l2.config.chart.toolbar.export.csv.headerCategory), l2.config.chart.type === "boxPlot" ? (h2.push("minimum"), h2.push("q1"), h2.push("median"), h2.push("q3"), h2.push("maximum")) : l2.config.chart.type === "candlestick" ? (h2.push("open"), h2.push("high"), h2.push("low"), h2.push("close")) : l2.config.chart.type === "rangeBar" ? (h2.push("minimum"), h2.push("maximum")) : i2.map(function(t4, e3) {
      var i3 = (t4.name ? t4.name : "series-".concat(e3)) + "";
      l2.globals.axisCharts && h2.push(i3.split(r2).join("") ? i3.split(r2).join("") : "series-".concat(e3));
    }), l2.globals.axisCharts || (h2.push(l2.config.chart.toolbar.export.csv.headerValue), c2.push(h2.join(r2))), l2.globals.allSeriesHasEqualX || !l2.globals.axisCharts || l2.config.xaxis.categories.length || l2.config.labels.length ? i2.map(function(t4, e3) {
      l2.globals.axisCharts ? w2(t4, e3) : ((h2 = []).push(g2(l2.globals.labels[e3])), h2.push(p2(u2[e3])), c2.push(h2.join(r2)));
    }) : function() {
      var t4 = new Set, e3 = {};
      i2.forEach(function(a3, s3) {
        a3 == null || a3.data.forEach(function(a4) {
          var r3, n3;
          if (b2.isFormatXY())
            r3 = a4.x, n3 = a4.y;
          else {
            if (!b2.isFormat2DArray())
              return;
            r3 = a4[0], n3 = a4[1];
          }
          e3[r3] || (e3[r3] = Array(i2.length).fill("")), e3[r3][s3] = p2(n3), t4.add(r3);
        });
      }), h2.length && c2.push(h2.join(r2)), Array.from(t4).sort().forEach(function(t5) {
        c2.push([g2(t5), e3[t5].join(r2)]);
      });
    }(), d2 += c2.join(o2), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + d2), a2 || l2.config.chart.toolbar.export.csv.filename, ".csv");
  } }, { key: "triggerDownload", value: function(t3, e2, i2) {
    var a2 = document.createElement("a");
    a2.href = t3, a2.download = (e2 || this.w.globals.chartID) + i2, document.body.appendChild(a2), a2.click(), document.body.removeChild(a2);
  } }]), t2;
}();
var Qi = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.elgrid = a2, this.w = e2.w;
    var s2 = this.w;
    this.axesUtils = new Ri(e2), this.xaxisLabels = s2.globals.labels.slice(), s2.globals.timescaleLabels.length > 0 && !s2.globals.isBarHorizontal && (this.xaxisLabels = s2.globals.timescaleLabels.slice()), s2.config.xaxis.overwriteCategories && (this.xaxisLabels = s2.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], s2.config.xaxis.position === "top" ? this.offY = 0 : this.offY = s2.globals.gridHeight, this.offY = this.offY + s2.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = s2.config.chart.type === "bar" && s2.config.plotOptions.bar.horizontal, this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s2.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s2.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s2.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s2.config.xaxis.axisBorder.height, this.yaxis = s2.config.yaxis[0];
  }
  return s(t2, [{ key: "drawXaxis", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = e2.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t3.config.xaxis.offsetX, ", ").concat(t3.config.xaxis.offsetY, ")") }), a2 = e2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t3.globals.translateXAxisX, ", ").concat(t3.globals.translateXAxisY, ")") });
    i2.add(a2);
    for (var s2 = [], r2 = 0;r2 < this.xaxisLabels.length; r2++)
      s2.push(this.xaxisLabels[r2]);
    if (this.drawXAxisLabelAndGroup(true, e2, a2, s2, t3.globals.isXNumeric, function(t4, e3) {
      return e3;
    }), t3.globals.hasXaxisGroups) {
      var n2 = t3.globals.groups;
      s2 = [];
      for (var o2 = 0;o2 < n2.length; o2++)
        s2.push(n2[o2].title);
      var l2 = {};
      t3.config.xaxis.group.style && (l2.xaxisFontSize = t3.config.xaxis.group.style.fontSize, l2.xaxisFontFamily = t3.config.xaxis.group.style.fontFamily, l2.xaxisForeColors = t3.config.xaxis.group.style.colors, l2.fontWeight = t3.config.xaxis.group.style.fontWeight, l2.cssClass = t3.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e2, a2, s2, false, function(t4, e3) {
        return n2[t4].cols * e3;
      }, l2);
    }
    if (t3.config.xaxis.title.text !== undefined) {
      var h2 = e2.group({ class: "apexcharts-xaxis-title" }), c2 = e2.drawText({ x: t3.globals.gridWidth / 2 + t3.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (t3.config.xaxis.position === "bottom" ? t3.globals.xAxisLabelsHeight : -t3.globals.xAxisLabelsHeight - 10) + t3.config.xaxis.title.offsetY, text: t3.config.xaxis.title.text, textAnchor: "middle", fontSize: t3.config.xaxis.title.style.fontSize, fontFamily: t3.config.xaxis.title.style.fontFamily, fontWeight: t3.config.xaxis.title.style.fontWeight, foreColor: t3.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t3.config.xaxis.title.style.cssClass });
      h2.add(c2), i2.add(h2);
    }
    if (t3.config.xaxis.axisBorder.show) {
      var d2 = t3.globals.barPadForNumericAxis, u2 = e2.drawLine(t3.globals.padHorizontal + t3.config.xaxis.axisBorder.offsetX - d2, this.offY, this.xaxisBorderWidth + d2, this.offY, t3.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      this.elgrid && this.elgrid.elGridBorders && t3.config.grid.show ? this.elgrid.elGridBorders.add(u2) : i2.add(u2);
    }
    return i2;
  } }, { key: "drawXAxisLabelAndGroup", value: function(t3, e2, i2, a2, s2, r2) {
    var n2, o2 = this, l2 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {}, h2 = [], c2 = [], d2 = this.w, u2 = l2.xaxisFontSize || this.xaxisFontSize, g2 = l2.xaxisFontFamily || this.xaxisFontFamily, p2 = l2.xaxisForeColors || this.xaxisForeColors, f2 = l2.fontWeight || d2.config.xaxis.labels.style.fontWeight, x2 = l2.cssClass || d2.config.xaxis.labels.style.cssClass, b2 = d2.globals.padHorizontal, m2 = a2.length, v2 = d2.config.xaxis.type === "category" ? d2.globals.dataPoints : m2;
    if (v2 === 0 && m2 > v2 && (v2 = m2), s2) {
      var y2 = Math.max(Number(d2.config.xaxis.tickAmount) || 1, v2 > 1 ? v2 - 1 : v2);
      n2 = d2.globals.gridWidth / Math.min(y2, m2 - 1), b2 = b2 + r2(0, n2) / 2 + d2.config.xaxis.labels.offsetX;
    } else
      n2 = d2.globals.gridWidth / v2, b2 = b2 + r2(0, n2) + d2.config.xaxis.labels.offsetX;
    for (var w2 = function(s3) {
      var l3 = b2 - r2(s3, n2) / 2 + d2.config.xaxis.labels.offsetX;
      s3 === 0 && m2 === 1 && n2 / 2 === b2 && v2 === 1 && (l3 = d2.globals.gridWidth / 2);
      var y3 = o2.axesUtils.getLabel(a2, d2.globals.timescaleLabels, l3, s3, h2, u2, t3), w3 = 28;
      d2.globals.rotateXLabels && t3 && (w3 = 22), d2.config.xaxis.title.text && d2.config.xaxis.position === "top" && (w3 += parseFloat(d2.config.xaxis.title.style.fontSize) + 2), t3 || (w3 = w3 + parseFloat(u2) + (d2.globals.xAxisLabelsHeight - d2.globals.xAxisGroupLabelsHeight) + (d2.globals.rotateXLabels ? 10 : 0)), y3 = d2.config.xaxis.tickAmount !== undefined && d2.config.xaxis.tickAmount !== "dataPoints" && d2.config.xaxis.type !== "datetime" ? o2.axesUtils.checkLabelBasedOnTickamount(s3, y3, m2) : o2.axesUtils.checkForOverflowingLabels(s3, y3, m2, h2, c2);
      if (d2.config.xaxis.labels.show) {
        var k3 = e2.drawText({ x: y3.x, y: o2.offY + d2.config.xaxis.labels.offsetY + w3 - (d2.config.xaxis.position === "top" ? d2.globals.xAxisHeight + d2.config.xaxis.axisTicks.height - 2 : 0), text: y3.text, textAnchor: "middle", fontWeight: y3.isBold ? 600 : f2, fontSize: u2, fontFamily: g2, foreColor: Array.isArray(p2) ? t3 && d2.config.xaxis.convertedCatToNumeric ? p2[d2.globals.minX + s3 - 1] : p2[s3] : p2, isPlainText: false, cssClass: (t3 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x2 });
        if (i2.add(k3), k3.on("click", function(t4) {
          if (typeof d2.config.chart.events.xAxisLabelClick == "function") {
            var e3 = Object.assign({}, d2, { labelIndex: s3 });
            d2.config.chart.events.xAxisLabelClick(t4, o2.ctx, e3);
          }
        }), t3) {
          var A2 = document.createElementNS(d2.globals.SVGNS, "title");
          A2.textContent = Array.isArray(y3.text) ? y3.text.join(" ") : y3.text, k3.node.appendChild(A2), y3.text !== "" && (h2.push(y3.text), c2.push(y3));
        }
      }
      s3 < m2 - 1 && (b2 += r2(s3 + 1, n2));
    }, k2 = 0;k2 <= m2 - 1; k2++)
      w2(k2);
  } }, { key: "drawXaxisInversed", value: function(t3) {
    var e2, i2, a2 = this, s2 = this.w, r2 = new Mi(this.ctx), n2 = s2.config.yaxis[0].opposite ? s2.globals.translateYAxisX[t3] : 0, o2 = r2.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t3 }), l2 = r2.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + n2 + ", 0)" });
    o2.add(l2);
    var h2 = [];
    if (s2.config.yaxis[t3].show)
      for (var c2 = 0;c2 < this.xaxisLabels.length; c2++)
        h2.push(this.xaxisLabels[c2]);
    e2 = s2.globals.gridHeight / h2.length, i2 = -e2 / 2.2;
    var d2 = s2.globals.yLabelFormatters[0], u2 = s2.config.yaxis[0].labels;
    if (u2.show)
      for (var g2 = function(n3) {
        var o3 = h2[n3] === undefined ? "" : h2[n3];
        o3 = d2(o3, { seriesIndex: t3, dataPointIndex: n3, w: s2 });
        var c3 = a2.axesUtils.getYAxisForeColor(u2.style.colors, t3), g3 = 0;
        Array.isArray(o3) && (g3 = o3.length / 2 * parseInt(u2.style.fontSize, 10));
        var p3 = u2.offsetX - 15, f3 = "end";
        a2.yaxis.opposite && (f3 = "start"), s2.config.yaxis[0].labels.align === "left" ? (p3 = u2.offsetX, f3 = "start") : s2.config.yaxis[0].labels.align === "center" ? (p3 = u2.offsetX, f3 = "middle") : s2.config.yaxis[0].labels.align === "right" && (f3 = "end");
        var x3 = r2.drawText({ x: p3, y: i2 + e2 + u2.offsetY - g3, text: o3, textAnchor: f3, foreColor: Array.isArray(c3) ? c3[n3] : c3, fontSize: u2.style.fontSize, fontFamily: u2.style.fontFamily, fontWeight: u2.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + u2.style.cssClass, maxWidth: u2.maxWidth });
        l2.add(x3), x3.on("click", function(t4) {
          if (typeof s2.config.chart.events.xAxisLabelClick == "function") {
            var e3 = Object.assign({}, s2, { labelIndex: n3 });
            s2.config.chart.events.xAxisLabelClick(t4, a2.ctx, e3);
          }
        });
        var b3 = document.createElementNS(s2.globals.SVGNS, "title");
        if (b3.textContent = Array.isArray(o3) ? o3.join(" ") : o3, x3.node.appendChild(b3), s2.config.yaxis[t3].labels.rotate !== 0) {
          var m3 = r2.rotateAroundCenter(x3.node);
          x3.node.setAttribute("transform", "rotate(".concat(s2.config.yaxis[t3].labels.rotate, " 0 ").concat(m3.y, ")"));
        }
        i2 += e2;
      }, p2 = 0;p2 <= h2.length - 1; p2++)
        g2(p2);
    if (s2.config.yaxis[0].title.text !== undefined) {
      var f2 = r2.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + n2 + ", 0)" }), x2 = r2.drawText({ x: s2.config.yaxis[0].title.offsetX, y: s2.globals.gridHeight / 2 + s2.config.yaxis[0].title.offsetY, text: s2.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s2.config.yaxis[0].title.style.color, fontSize: s2.config.yaxis[0].title.style.fontSize, fontWeight: s2.config.yaxis[0].title.style.fontWeight, fontFamily: s2.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s2.config.yaxis[0].title.style.cssClass });
      f2.add(x2), o2.add(f2);
    }
    var b2 = 0;
    this.isCategoryBarHorizontal && s2.config.yaxis[0].opposite && (b2 = s2.globals.gridWidth);
    var m2 = s2.config.xaxis.axisBorder;
    if (m2.show) {
      var v2 = r2.drawLine(s2.globals.padHorizontal + m2.offsetX + b2, 1 + m2.offsetY, s2.globals.padHorizontal + m2.offsetX + b2, s2.globals.gridHeight + m2.offsetY, m2.color, 0);
      this.elgrid && this.elgrid.elGridBorders && s2.config.grid.show ? this.elgrid.elGridBorders.add(v2) : o2.add(v2);
    }
    return s2.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b2, h2.length, s2.config.yaxis[0].axisBorder, s2.config.yaxis[0].axisTicks, 0, e2, o2), o2;
  } }, { key: "drawXaxisTicks", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = t3;
    if (!(t3 < 0 || t3 - 2 > a2.globals.gridWidth)) {
      var r2 = this.offY + a2.config.xaxis.axisTicks.offsetY;
      if (e2 = e2 + r2 + a2.config.xaxis.axisTicks.height, a2.config.xaxis.position === "top" && (e2 = r2 - a2.config.xaxis.axisTicks.height), a2.config.xaxis.axisTicks.show) {
        var n2 = new Mi(this.ctx).drawLine(t3 + a2.config.xaxis.axisTicks.offsetX, r2 + a2.config.xaxis.offsetY, s2 + a2.config.xaxis.axisTicks.offsetX, e2 + a2.config.xaxis.offsetY, a2.config.xaxis.axisTicks.color);
        i2.add(n2), n2.node.classList.add("apexcharts-xaxis-tick");
      }
    }
  } }, { key: "getXAxisTicksPositions", value: function() {
    var t3 = this.w, e2 = [], i2 = this.xaxisLabels.length, a2 = t3.globals.padHorizontal;
    if (t3.globals.timescaleLabels.length > 0)
      for (var s2 = 0;s2 < i2; s2++)
        a2 = this.xaxisLabels[s2].position, e2.push(a2);
    else
      for (var r2 = i2, n2 = 0;n2 < r2; n2++) {
        var o2 = r2;
        t3.globals.isXNumeric && t3.config.chart.type !== "bar" && (o2 -= 1), a2 += t3.globals.gridWidth / o2, e2.push(a2);
      }
    return e2;
  } }, { key: "xAxisLabelCorrections", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
    if (t3.globals.rotateXLabels || t3.config.xaxis.labels.rotateAlways)
      for (var n2 = 0;n2 < a2.length; n2++) {
        var o2 = e2.rotateAroundCenter(a2[n2]);
        o2.y = o2.y - 1, o2.x = o2.x + 1, a2[n2].setAttribute("transform", "rotate(".concat(t3.config.xaxis.labels.rotate, " ").concat(o2.x, " ").concat(o2.y, ")")), a2[n2].setAttribute("text-anchor", "end");
        i2.setAttribute("transform", "translate(0, ".concat(-10, ")"));
        var l2 = a2[n2].childNodes;
        t3.config.xaxis.labels.trim && Array.prototype.forEach.call(l2, function(i3) {
          e2.placeTextWithEllipsis(i3, i3.textContent, t3.globals.xAxisLabelsHeight - (t3.config.legend.position === "bottom" ? 20 : 10));
        });
      }
    else
      (function() {
        for (var i3 = t3.globals.gridWidth / (t3.globals.labels.length + 1), s3 = 0;s3 < a2.length; s3++) {
          var r3 = a2[s3].childNodes;
          t3.config.xaxis.labels.trim && t3.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(r3, function(t4) {
            e2.placeTextWithEllipsis(t4, t4.textContent, i3);
          });
        }
      })();
    if (s2.length > 0) {
      var h2 = s2[s2.length - 1].getBBox(), c2 = s2[0].getBBox();
      h2.x < -20 && s2[s2.length - 1].parentNode.removeChild(s2[s2.length - 1]), c2.x + c2.width > t3.globals.gridWidth && !t3.globals.isBarHorizontal && s2[0].parentNode.removeChild(s2[0]);
      for (var d2 = 0;d2 < r2.length; d2++)
        e2.placeTextWithEllipsis(r2[d2], r2[d2].textContent, t3.config.yaxis[0].labels.maxWidth - (t3.config.yaxis[0].title.text ? 2 * parseFloat(t3.config.yaxis[0].title.style.fontSize) : 0) - 15);
    }
  } }]), t2;
}();
var Ki = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.xaxisLabels = a2.globals.labels.slice(), this.axesUtils = new Ri(e2), this.isRangeBar = a2.globals.seriesRange.length && a2.globals.isBarHorizontal, a2.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a2.globals.timescaleLabels.slice());
  }
  return s(t2, [{ key: "drawGridArea", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null, e2 = this.w, i2 = new Mi(this.ctx);
    t3 || (t3 = i2.group({ class: "apexcharts-grid" }));
    var a2 = i2.drawLine(e2.globals.padHorizontal, 1, e2.globals.padHorizontal, e2.globals.gridHeight, "transparent"), s2 = i2.drawLine(e2.globals.padHorizontal, e2.globals.gridHeight, e2.globals.gridWidth, e2.globals.gridHeight, "transparent");
    return t3.add(s2), t3.add(a2), t3;
  } }, { key: "drawGrid", value: function() {
    if (this.w.globals.axisCharts) {
      var t3 = this.renderGrid();
      return this.drawGridArea(t3.el), t3;
    }
    return null;
  } }, { key: "createGridMask", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = new Mi(this.ctx), a2 = Array.isArray(t3.config.stroke.width) ? Math.max.apply(Math, f(t3.config.stroke.width)) : t3.config.stroke.width, s2 = function(t4) {
      var i3 = document.createElementNS(e2.SVGNS, "clipPath");
      return i3.setAttribute("id", t4), i3;
    };
    e2.dom.elGridRectMask = s2("gridRectMask".concat(e2.cuid)), e2.dom.elGridRectBarMask = s2("gridRectBarMask".concat(e2.cuid)), e2.dom.elGridRectMarkerMask = s2("gridRectMarkerMask".concat(e2.cuid)), e2.dom.elForecastMask = s2("forecastMask".concat(e2.cuid)), e2.dom.elNonForecastMask = s2("nonForecastMask".concat(e2.cuid));
    var r2 = 0, n2 = 0;
    (["bar", "rangeBar", "candlestick", "boxPlot"].includes(t3.config.chart.type) || t3.globals.comboBarCount > 0) && t3.globals.isXNumeric && !t3.globals.isBarHorizontal && (r2 = Math.max(t3.config.grid.padding.left, e2.barPadForNumericAxis), n2 = Math.max(t3.config.grid.padding.right, e2.barPadForNumericAxis)), e2.dom.elGridRect = i2.drawRect(-a2 / 2 - 2, -a2 / 2 - 2, e2.gridWidth + a2 + 4, e2.gridHeight + a2 + 4, 0, "#fff"), e2.dom.elGridRectBar = i2.drawRect(-a2 / 2 - r2 - 2, -a2 / 2 - 2, e2.gridWidth + a2 + n2 + r2 + 4, e2.gridHeight + a2 + 4, 0, "#fff");
    var o2 = t3.globals.markers.largestSize;
    e2.dom.elGridRectMarker = i2.drawRect(-o2, -o2, e2.gridWidth + 2 * o2, e2.gridHeight + 2 * o2, 0, "#fff"), e2.dom.elGridRectMask.appendChild(e2.dom.elGridRect.node), e2.dom.elGridRectBarMask.appendChild(e2.dom.elGridRectBar.node), e2.dom.elGridRectMarkerMask.appendChild(e2.dom.elGridRectMarker.node);
    var l2 = e2.dom.baseEl.querySelector("defs");
    l2.appendChild(e2.dom.elGridRectMask), l2.appendChild(e2.dom.elGridRectBarMask), l2.appendChild(e2.dom.elGridRectMarkerMask), l2.appendChild(e2.dom.elForecastMask), l2.appendChild(e2.dom.elNonForecastMask);
  } }, { key: "_drawGridLines", value: function(t3) {
    var { i: e2, x1: i2, y1: a2, x2: s2, y2: r2, xCount: n2, parent: o2 } = t3, l2 = this.w;
    if (!(e2 === 0 && l2.globals.skipFirstTimelinelabel || e2 === n2 - 1 && l2.globals.skipLastTimelinelabel && !l2.config.xaxis.labels.formatter || l2.config.chart.type === "radar")) {
      l2.config.grid.xaxis.lines.show && this._drawGridLine({ i: e2, x1: i2, y1: a2, x2: s2, y2: r2, xCount: n2, parent: o2 });
      var h2 = 0;
      if (l2.globals.hasXaxisGroups && l2.config.xaxis.tickPlacement === "between") {
        var c2 = l2.globals.groups;
        if (c2) {
          for (var d2 = 0, u2 = 0;d2 < e2 && u2 < c2.length; u2++)
            d2 += c2[u2].cols;
          d2 === e2 && (h2 = 0.6 * l2.globals.xAxisLabelsHeight);
        }
      }
      new Qi(this.ctx).drawXaxisTicks(i2, h2, l2.globals.dom.elGraphical);
    }
  } }, { key: "_drawGridLine", value: function(t3) {
    var { i: e2, x1: i2, y1: a2, x2: s2, y2: r2, xCount: n2, parent: o2 } = t3, l2 = this.w, h2 = o2.node.classList.contains("apexcharts-gridlines-horizontal"), c2 = l2.globals.barPadForNumericAxis, d2 = a2 === 0 && r2 === 0 || i2 === 0 && s2 === 0 || a2 === l2.globals.gridHeight && r2 === l2.globals.gridHeight || l2.globals.isBarHorizontal && (e2 === 0 || e2 === n2 - 1), u2 = new Mi(this).drawLine(i2 - (h2 ? c2 : 0), a2, s2 + (h2 ? c2 : 0), r2, l2.config.grid.borderColor, l2.config.grid.strokeDashArray);
    u2.node.classList.add("apexcharts-gridline"), d2 && l2.config.grid.show ? this.elGridBorders.add(u2) : o2.add(u2);
  } }, { key: "_drawGridBandRect", value: function(t3) {
    var { c: e2, x1: i2, y1: a2, x2: s2, y2: r2, type: n2 } = t3, o2 = this.w, l2 = new Mi(this.ctx), h2 = o2.globals.barPadForNumericAxis, c2 = o2.config.grid[n2].colors[e2], d2 = l2.drawRect(i2 - (n2 === "row" ? h2 : 0), a2, s2 + (n2 === "row" ? 2 * h2 : 0), r2, 0, c2, o2.config.grid[n2].opacity);
    this.elg.add(d2), d2.attr("clip-path", "url(#gridRectMask".concat(o2.globals.cuid, ")")), d2.node.classList.add("apexcharts-grid-".concat(n2));
  } }, { key: "_drawXYLines", value: function(t3) {
    var e2 = this, i2 = t3.xCount, a2 = t3.tickAmount, s2 = this.w;
    if (s2.config.grid.xaxis.lines.show || s2.config.xaxis.axisTicks.show) {
      var r2, n2 = s2.globals.padHorizontal, o2 = s2.globals.gridHeight;
      s2.globals.timescaleLabels.length ? function(t4) {
        for (var { xC: a3, x1: s3, y1: r3, x2: n3, y2: o3 } = t4, l3 = 0;l3 < a3; l3++)
          s3 = e2.xaxisLabels[l3].position, n3 = e2.xaxisLabels[l3].position, e2._drawGridLines({ i: l3, x1: s3, y1: r3, x2: n3, y2: o3, xCount: i2, parent: e2.elgridLinesV });
      }({ xC: i2, x1: n2, y1: 0, x2: r2, y2: o2 }) : (s2.globals.isXNumeric && (i2 = s2.globals.xAxisScale.result.length), function(t4) {
        for (var { xC: a3, x1: r3, y1: n3, x2: o3, y2: l3 } = t4, h3 = 0;h3 < a3 + (s2.globals.isXNumeric ? 0 : 1); h3++)
          h3 === 0 && a3 === 1 && s2.globals.dataPoints === 1 && (o3 = r3 = s2.globals.gridWidth / 2), e2._drawGridLines({ i: h3, x1: r3, y1: n3, x2: o3, y2: l3, xCount: i2, parent: e2.elgridLinesV }), o3 = r3 += s2.globals.gridWidth / (s2.globals.isXNumeric ? a3 - 1 : a3);
      }({ xC: i2, x1: n2, y1: 0, x2: r2, y2: o2 }));
    }
    if (s2.config.grid.yaxis.lines.show) {
      var l2 = 0, h2 = 0, c2 = s2.globals.gridWidth, d2 = a2 + 1;
      this.isRangeBar && (d2 = s2.globals.labels.length);
      for (var u2 = 0;u2 < d2 + (this.isRangeBar ? 1 : 0); u2++)
        this._drawGridLine({ i: u2, xCount: d2 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l2, x2: c2, y2: h2, parent: this.elgridLinesH }), h2 = l2 += s2.globals.gridHeight / (this.isRangeBar ? d2 : a2);
    }
  } }, { key: "_drawInvertedXYLines", value: function(t3) {
    var e2 = t3.xCount, i2 = this.w;
    if (i2.config.grid.xaxis.lines.show || i2.config.xaxis.axisTicks.show)
      for (var a2, s2 = i2.globals.padHorizontal, r2 = i2.globals.gridHeight, n2 = 0;n2 < e2 + 1; n2++) {
        i2.config.grid.xaxis.lines.show && this._drawGridLine({ i: n2, xCount: e2 + 1, x1: s2, y1: 0, x2: a2, y2: r2, parent: this.elgridLinesV }), new Qi(this.ctx).drawXaxisTicks(s2, 0, i2.globals.dom.elGraphical), a2 = s2 += i2.globals.gridWidth / e2;
      }
    if (i2.config.grid.yaxis.lines.show)
      for (var o2 = 0, l2 = 0, h2 = i2.globals.gridWidth, c2 = 0;c2 < i2.globals.dataPoints + 1; c2++)
        this._drawGridLine({ i: c2, xCount: i2.globals.dataPoints + 1, x1: 0, y1: o2, x2: h2, y2: l2, parent: this.elgridLinesH }), l2 = o2 += i2.globals.gridHeight / i2.globals.dataPoints;
  } }, { key: "renderGrid", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = new Mi(this.ctx);
    this.elg = i2.group({ class: "apexcharts-grid" }), this.elgridLinesH = i2.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i2.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i2.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t3.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
    for (var a2 = 0;a2 < e2.seriesYAxisMap.length && e2.ignoreYAxisIndexes.includes(a2); )
      a2++;
    a2 === e2.seriesYAxisMap.length && (a2 = 0);
    var s2, r2 = e2.yAxisScale[a2].result.length - 1;
    if (!e2.isBarHorizontal || this.isRangeBar) {
      var n2, o2, l2;
      if (s2 = this.xaxisLabels.length, this.isRangeBar)
        r2 = e2.labels.length, t3.config.xaxis.tickAmount && t3.config.xaxis.labels.formatter && (s2 = t3.config.xaxis.tickAmount), ((n2 = e2.yAxisScale) === null || n2 === undefined || (o2 = n2[a2]) === null || o2 === undefined || (l2 = o2.result) === null || l2 === undefined ? undefined : l2.length) > 0 && t3.config.xaxis.type !== "datetime" && (s2 = e2.yAxisScale[a2].result.length - 1);
      this._drawXYLines({ xCount: s2, tickAmount: r2 });
    } else
      s2 = r2, r2 = e2.xTickAmount, this._drawInvertedXYLines({ xCount: s2, tickAmount: r2 });
    return this.drawGridBands(s2, r2), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: e2.gridWidth / s2 };
  } }, { key: "drawGridBands", value: function(t3, e2) {
    var i2, a2, s2 = this, r2 = this.w;
    if (((i2 = r2.config.grid.row.colors) === null || i2 === undefined ? undefined : i2.length) > 0 && function(t4, i3, a3, n3, o3, l3) {
      for (var h3 = 0, c3 = 0;h3 < i3; h3++, c3++)
        c3 >= r2.config.grid[t4].colors.length && (c3 = 0), s2._drawGridBandRect({ c: c3, x1: a3, y1: n3, x2: o3, y2: l3, type: t4 }), n3 += r2.globals.gridHeight / e2;
    }("row", e2, 0, 0, r2.globals.gridWidth, r2.globals.gridHeight / e2), ((a2 = r2.config.grid.column.colors) === null || a2 === undefined ? undefined : a2.length) > 0) {
      var n2 = r2.globals.isBarHorizontal || r2.config.xaxis.tickPlacement !== "on" || r2.config.xaxis.type !== "category" && !r2.config.xaxis.convertedCatToNumeric ? t3 : t3 - 1;
      r2.globals.isXNumeric && (n2 = r2.globals.xAxisScale.result.length - 1);
      for (var o2 = r2.globals.padHorizontal, l2 = r2.globals.padHorizontal + r2.globals.gridWidth / n2, h2 = r2.globals.gridHeight, c2 = 0, d2 = 0;c2 < t3; c2++, d2++) {
        var u2;
        if (d2 >= r2.config.grid.column.colors.length && (d2 = 0), r2.config.xaxis.type === "datetime")
          o2 = this.xaxisLabels[c2].position, l2 = (((u2 = this.xaxisLabels[c2 + 1]) === null || u2 === undefined ? undefined : u2.position) || r2.globals.gridWidth) - this.xaxisLabels[c2].position;
        this._drawGridBandRect({ c: d2, x1: o2, y1: 0, x2: l2, y2: h2, type: "column" }), o2 += r2.globals.gridWidth / n2;
      }
    }
  } }]), t2;
}();
var ta = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.coreUtils = new Pi(this.ctx);
  }
  return s(t2, [{ key: "niceScale", value: function(t3, e2) {
    var i2, a2, s2, r2, n2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0, o2 = 0.00000000001, l2 = this.w, h2 = l2.globals;
    h2.isBarHorizontal ? (i2 = l2.config.xaxis, a2 = Math.max((h2.svgWidth - 100) / 25, 2)) : (i2 = l2.config.yaxis[n2], a2 = Math.max((h2.svgHeight - 100) / 15, 2)), v.isNumber(a2) || (a2 = 10), s2 = i2.min !== undefined && i2.min !== null, r2 = i2.max !== undefined && i2.min !== null;
    var c2 = i2.stepSize !== undefined && i2.stepSize !== null, d2 = i2.tickAmount !== undefined && i2.tickAmount !== null, u2 = d2 ? i2.tickAmount : h2.niceScaleDefaultTicks[Math.min(Math.round(a2 / 2), h2.niceScaleDefaultTicks.length - 1)];
    if (h2.isMultipleYAxis && !d2 && h2.multiAxisTickAmount > 0 && (u2 = h2.multiAxisTickAmount, d2 = true), u2 = u2 === "dataPoints" ? h2.dataPoints - 1 : Math.abs(Math.round(u2)), (t3 === Number.MIN_VALUE && e2 === 0 || !v.isNumber(t3) && !v.isNumber(e2) || t3 === Number.MIN_VALUE && e2 === -Number.MAX_VALUE) && (t3 = v.isNumber(i2.min) ? i2.min : 0, e2 = v.isNumber(i2.max) ? i2.max : t3 + u2, h2.allSeriesCollapsed = false), t3 > e2) {
      console.warn("axis.min cannot be greater than axis.max: swapping min and max");
      var g2 = e2;
      e2 = t3, t3 = g2;
    } else
      t3 === e2 && (t3 = t3 === 0 ? 0 : t3 - 1, e2 = e2 === 0 ? 2 : e2 + 1);
    var p2 = [];
    u2 < 1 && (u2 = 1);
    var f2 = u2, x2 = Math.abs(e2 - t3);
    !s2 && t3 > 0 && t3 / x2 < 0.15 && (t3 = 0, s2 = true), !r2 && e2 < 0 && -e2 / x2 < 0.15 && (e2 = 0, r2 = true);
    var b2 = (x2 = Math.abs(e2 - t3)) / f2, m2 = b2, y2 = Math.floor(Math.log10(m2)), w2 = Math.pow(10, y2), k2 = Math.ceil(m2 / w2);
    if (b2 = m2 = (k2 = h2.niceScaleAllowedMagMsd[h2.yValueDecimal === 0 ? 0 : 1][k2]) * w2, h2.isBarHorizontal && i2.stepSize && i2.type !== "datetime" ? (b2 = i2.stepSize, c2 = true) : c2 && (b2 = i2.stepSize), c2 && i2.forceNiceScale) {
      var A2 = Math.floor(Math.log10(b2));
      b2 *= Math.pow(10, y2 - A2);
    }
    if (s2 && r2) {
      var C2 = x2 / f2;
      if (d2)
        if (c2)
          if (v.mod(x2, b2) != 0) {
            var S2 = v.getGCD(b2, C2);
            b2 = C2 / S2 < 10 ? S2 : C2;
          } else
            v.mod(b2, C2) == 0 ? b2 = C2 : (C2 = b2, d2 = false);
        else
          b2 = C2;
      else if (c2)
        v.mod(x2, b2) == 0 ? C2 = b2 : b2 = C2;
      else if (v.mod(x2, b2) == 0)
        C2 = b2;
      else {
        C2 = x2 / (f2 = Math.ceil(x2 / b2));
        var L2 = v.getGCD(x2, b2);
        x2 / L2 < a2 && (C2 = L2), b2 = C2;
      }
      f2 = Math.round(x2 / b2);
    } else {
      if (s2 || r2) {
        if (r2)
          if (d2)
            t3 = e2 - b2 * f2;
          else {
            var M2 = t3;
            t3 = b2 * Math.floor(t3 / b2), Math.abs(e2 - t3) / v.getGCD(x2, b2) > a2 && (t3 = e2 - b2 * u2, t3 += b2 * Math.floor((M2 - t3) / b2));
          }
        else if (s2)
          if (d2)
            e2 = t3 + b2 * f2;
          else {
            var P2 = e2;
            e2 = b2 * Math.ceil(e2 / b2), Math.abs(e2 - t3) / v.getGCD(x2, b2) > a2 && (e2 = t3 + b2 * u2, e2 += b2 * Math.ceil((P2 - e2) / b2));
          }
      } else if (h2.isMultipleYAxis && d2) {
        var I2 = b2 * Math.floor(t3 / b2), T2 = I2 + b2 * f2;
        T2 < e2 && (b2 *= 2), T2 = e2, e2 = (t3 = I2) + b2 * f2, x2 = Math.abs(e2 - t3), t3 > 0 && t3 < Math.abs(T2 - e2) && (t3 = 0, e2 = b2 * f2), e2 < 0 && -e2 < Math.abs(I2 - t3) && (e2 = 0, t3 = -b2 * f2);
      } else
        t3 = b2 * Math.floor(t3 / b2), e2 = b2 * Math.ceil(e2 / b2);
      x2 = Math.abs(e2 - t3), b2 = v.getGCD(x2, b2), f2 = Math.round(x2 / b2);
    }
    if (d2 || s2 || r2 || (f2 = Math.ceil((x2 - o2) / (b2 + o2))) > 16 && v.getPrimeFactors(f2).length < 2 && f2++, !d2 && i2.forceNiceScale && h2.yValueDecimal === 0 && f2 > x2 && (f2 = x2, b2 = Math.round(x2 / f2)), f2 > a2 && (!d2 && !c2 || i2.forceNiceScale)) {
      var z2 = v.getPrimeFactors(f2), X2 = z2.length - 1, R2 = f2;
      t:
        for (var E2 = 0;E2 < X2; E2++)
          for (var Y2 = 0;Y2 <= X2 - E2; Y2++) {
            for (var H2 = Math.min(Y2 + E2, X2), O2 = R2, F2 = 1, D2 = Y2;D2 <= H2; D2++)
              F2 *= z2[D2];
            if ((O2 /= F2) < a2) {
              R2 = O2;
              break t;
            }
          }
      b2 = R2 === f2 ? x2 : x2 / R2, f2 = Math.round(x2 / b2);
    }
    h2.isMultipleYAxis && h2.multiAxisTickAmount == 0 && h2.ignoreYAxisIndexes.indexOf(n2) < 0 && (h2.multiAxisTickAmount = f2);
    var _2 = t3 - b2, N2 = b2 * o2;
    do {
      _2 += b2, p2.push(v.stripNumber(_2, 7));
    } while (e2 - _2 > N2);
    return { result: p2, niceMin: p2[0], niceMax: p2[p2.length - 1] };
  } }, { key: "linearScale", value: function(t3, e2) {
    var i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10, a2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0, s2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined, r2 = Math.abs(e2 - t3), n2 = [];
    if (t3 === e2)
      return { result: n2 = [t3], niceMin: n2[0], niceMax: n2[n2.length - 1] };
    (i2 = this._adjustTicksForSmallRange(i2, a2, r2)) === "dataPoints" && (i2 = this.w.globals.dataPoints - 1), s2 || (s2 = r2 / i2), s2 = Math.round(100 * (s2 + Number.EPSILON)) / 100, i2 === Number.MAX_VALUE && (i2 = 5, s2 = 1);
    for (var o2 = t3;i2 >= 0; )
      n2.push(o2), o2 = v.preciseAddition(o2, s2), i2 -= 1;
    return { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
  } }, { key: "logarithmicScaleNice", value: function(t3, e2, i2) {
    e2 <= 0 && (e2 = Math.max(t3, i2)), t3 <= 0 && (t3 = Math.min(e2, i2));
    for (var a2 = [], s2 = Math.ceil(Math.log(e2) / Math.log(i2) + 1), r2 = Math.floor(Math.log(t3) / Math.log(i2));r2 < s2; r2++)
      a2.push(Math.pow(i2, r2));
    return { result: a2, niceMin: a2[0], niceMax: a2[a2.length - 1] };
  } }, { key: "logarithmicScale", value: function(t3, e2, i2) {
    e2 <= 0 && (e2 = Math.max(t3, i2)), t3 <= 0 && (t3 = Math.min(e2, i2));
    for (var a2 = [], s2 = Math.log(e2) / Math.log(i2), r2 = Math.log(t3) / Math.log(i2), n2 = s2 - r2, o2 = Math.round(n2), l2 = n2 / o2, h2 = 0, c2 = r2;h2 < o2; h2++, c2 += l2)
      a2.push(Math.pow(i2, c2));
    return a2.push(Math.pow(i2, s2)), { result: a2, niceMin: t3, niceMax: e2 };
  } }, { key: "_adjustTicksForSmallRange", value: function(t3, e2, i2) {
    var a2 = t3;
    if (e2 !== undefined && this.w.config.yaxis[e2].labels.formatter && this.w.config.yaxis[e2].tickAmount === undefined) {
      var s2 = Number(this.w.config.yaxis[e2].labels.formatter(1));
      v.isNumber(s2) && this.w.globals.yValueDecimal === 0 && (a2 = Math.ceil(i2));
    }
    return a2 < t3 ? a2 : t3;
  } }, { key: "setYScaleForIndex", value: function(t3, e2, i2) {
    var a2 = this.w.globals, s2 = this.w.config, r2 = a2.isBarHorizontal ? s2.xaxis : s2.yaxis[t3];
    a2.yAxisScale[t3] === undefined && (a2.yAxisScale[t3] = []);
    var n2 = Math.abs(i2 - e2);
    r2.logarithmic && n2 <= 5 && (a2.invalidLogScale = true), r2.logarithmic && n2 > 5 ? (a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = r2.forceNiceScale ? this.logarithmicScaleNice(e2, i2, r2.logBase) : this.logarithmicScale(e2, i2, r2.logBase)) : i2 !== -Number.MAX_VALUE && v.isNumber(i2) && e2 !== Number.MAX_VALUE && v.isNumber(e2) ? (a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = this.niceScale(e2, i2, t3)) : a2.yAxisScale[t3] = this.niceScale(Number.MIN_VALUE, 0, t3);
  } }, { key: "setXScale", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.globals;
    if (e2 !== -Number.MAX_VALUE && v.isNumber(e2)) {
      var s2 = a2.xTickAmount;
      a2.xAxisScale = this.linearScale(t3, e2, s2, 0, i2.config.xaxis.stepSize);
    } else
      a2.xAxisScale = this.linearScale(0, 10, 10);
    return a2.xAxisScale;
  } }, { key: "scaleMultipleYAxes", value: function() {
    var t3 = this, e2 = this.w.config, i2 = this.w.globals;
    this.coreUtils.setSeriesYAxisMappings();
    var { seriesYAxisMap: a2, minYArr: s2, maxYArr: r2 } = i2;
    i2.allSeriesCollapsed = true, i2.barGroups = [], a2.forEach(function(a3, n2) {
      var o2 = [];
      a3.forEach(function(t4) {
        var i3, a4 = (i3 = e2.series[t4]) === null || i3 === undefined ? undefined : i3.group;
        o2.indexOf(a4) < 0 && o2.push(a4);
      }), a3.length > 0 ? function() {
        var l2, h2, c2 = Number.MAX_VALUE, d2 = -Number.MAX_VALUE, u2 = c2, g2 = d2;
        if (e2.chart.stacked)
          (function() {
            var t4 = new Array(i2.dataPoints).fill(0), s3 = [], r3 = [], p3 = [];
            o2.forEach(function() {
              s3.push(t4.map(function() {
                return Number.MIN_VALUE;
              })), r3.push(t4.map(function() {
                return Number.MIN_VALUE;
              })), p3.push(t4.map(function() {
                return Number.MIN_VALUE;
              }));
            });
            for (var f3 = function(t5) {
              !l2 && e2.series[a3[t5]].type && (l2 = e2.series[a3[t5]].type);
              var c3 = a3[t5];
              h2 = e2.series[c3].group ? e2.series[c3].group : "axis-".concat(n2), !(i2.collapsedSeriesIndices.indexOf(c3) < 0 && i2.ancillaryCollapsedSeriesIndices.indexOf(c3) < 0) || (i2.allSeriesCollapsed = false, o2.forEach(function(t6, a4) {
                if (e2.series[c3].group === t6)
                  for (var n3 = 0;n3 < i2.series[c3].length; n3++) {
                    var o3 = i2.series[c3][n3];
                    o3 >= 0 ? r3[a4][n3] += o3 : p3[a4][n3] += o3, s3[a4][n3] += o3, u2 = Math.min(u2, o3), g2 = Math.max(g2, o3);
                  }
              })), l2 !== "bar" && l2 !== "column" || i2.barGroups.push(h2);
            }, x2 = 0;x2 < a3.length; x2++)
              f3(x2);
            l2 || (l2 = e2.chart.type), l2 === "bar" || l2 === "column" ? o2.forEach(function(t5, e3) {
              c2 = Math.min(c2, Math.min.apply(null, p3[e3])), d2 = Math.max(d2, Math.max.apply(null, r3[e3]));
            }) : (o2.forEach(function(t5, e3) {
              u2 = Math.min(u2, Math.min.apply(null, s3[e3])), g2 = Math.max(g2, Math.max.apply(null, s3[e3]));
            }), c2 = u2, d2 = g2), c2 === Number.MIN_VALUE && d2 === Number.MIN_VALUE && (d2 = -Number.MAX_VALUE);
          })();
        else
          for (var p2 = 0;p2 < a3.length; p2++) {
            var f2 = a3[p2];
            c2 = Math.min(c2, s2[f2]), d2 = Math.max(d2, r2[f2]), !(i2.collapsedSeriesIndices.indexOf(f2) < 0 && i2.ancillaryCollapsedSeriesIndices.indexOf(f2) < 0) || (i2.allSeriesCollapsed = false);
          }
        e2.yaxis[n2].min !== undefined && (c2 = typeof e2.yaxis[n2].min == "function" ? e2.yaxis[n2].min(c2) : e2.yaxis[n2].min), e2.yaxis[n2].max !== undefined && (d2 = typeof e2.yaxis[n2].max == "function" ? e2.yaxis[n2].max(d2) : e2.yaxis[n2].max), i2.barGroups = i2.barGroups.filter(function(t4, e3, i3) {
          return i3.indexOf(t4) === e3;
        }), t3.setYScaleForIndex(n2, c2, d2), a3.forEach(function(t4) {
          s2[t4] = i2.yAxisScale[n2].niceMin, r2[t4] = i2.yAxisScale[n2].niceMax;
        });
      }() : t3.setYScaleForIndex(n2, 0, -Number.MAX_VALUE);
    });
  } }]), t2;
}();
var ea = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.scales = new ta(e2);
  }
  return s(t2, [{ key: "init", value: function() {
    this.setYRange(), this.setXRange(), this.setZRange();
  } }, { key: "getMinYMaxY", value: function(t3) {
    var e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE, i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Number.MAX_VALUE, a2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null, s2 = this.w.config, r2 = this.w.globals, n2 = -Number.MAX_VALUE, o2 = Number.MIN_VALUE;
    a2 === null && (a2 = t3 + 1);
    var l2 = r2.series, h2 = l2, c2 = l2;
    s2.chart.type === "candlestick" ? (h2 = r2.seriesCandleL, c2 = r2.seriesCandleH) : s2.chart.type === "boxPlot" ? (h2 = r2.seriesCandleO, c2 = r2.seriesCandleC) : r2.isRangeData && (h2 = r2.seriesRangeStart, c2 = r2.seriesRangeEnd);
    var d2 = false;
    if (r2.seriesX.length >= a2) {
      var u2, g2 = (u2 = r2.brushSource) === null || u2 === undefined ? undefined : u2.w.config.chart.brush;
      (s2.chart.zoom.enabled && s2.chart.zoom.autoScaleYaxis || g2 != null && g2.enabled && g2 != null && g2.autoScaleYaxis) && (d2 = true);
    }
    for (var p2 = t3;p2 < a2; p2++) {
      r2.dataPoints = Math.max(r2.dataPoints, l2[p2].length);
      var f2 = s2.series[p2].type;
      r2.categoryLabels.length && (r2.dataPoints = r2.categoryLabels.filter(function(t4) {
        return t4 !== undefined;
      }).length), r2.labels.length && s2.xaxis.type !== "datetime" && r2.series.reduce(function(t4, e3) {
        return t4 + e3.length;
      }, 0) !== 0 && (r2.dataPoints = Math.max(r2.dataPoints, r2.labels.length));
      var x2 = 0, b2 = l2[p2].length - 1;
      if (d2) {
        if (s2.xaxis.min)
          for (;x2 < b2 && r2.seriesX[p2][x2] < s2.xaxis.min; x2++)
            ;
        if (s2.xaxis.max)
          for (;b2 > x2 && r2.seriesX[p2][b2] > s2.xaxis.max; b2--)
            ;
      }
      for (var m2 = x2;m2 <= b2 && m2 < r2.series[p2].length; m2++) {
        var y2 = l2[p2][m2];
        if (y2 !== null && v.isNumber(y2)) {
          switch (c2[p2][m2] !== undefined && (n2 = Math.max(n2, c2[p2][m2]), e2 = Math.min(e2, c2[p2][m2])), h2[p2][m2] !== undefined && (e2 = Math.min(e2, h2[p2][m2]), i2 = Math.max(i2, h2[p2][m2])), f2) {
            case "candlestick":
              r2.seriesCandleC[p2][m2] !== undefined && (n2 = Math.max(n2, r2.seriesCandleH[p2][m2]), e2 = Math.min(e2, r2.seriesCandleL[p2][m2]));
              break;
            case "boxPlot":
              r2.seriesCandleC[p2][m2] !== undefined && (n2 = Math.max(n2, r2.seriesCandleC[p2][m2]), e2 = Math.min(e2, r2.seriesCandleO[p2][m2]));
          }
          f2 && f2 !== "candlestick" && f2 !== "boxPlot" && f2 !== "rangeArea" && f2 !== "rangeBar" && (n2 = Math.max(n2, r2.series[p2][m2]), e2 = Math.min(e2, r2.series[p2][m2])), r2.seriesGoals[p2] && r2.seriesGoals[p2][m2] && Array.isArray(r2.seriesGoals[p2][m2]) && r2.seriesGoals[p2][m2].forEach(function(t4) {
            n2 = Math.max(n2, t4.value), e2 = Math.min(e2, t4.value);
          }), i2 = n2, y2 = v.noExponents(y2), v.isFloat(y2) && (r2.yValueDecimal = Math.max(r2.yValueDecimal, y2.toString().split(".")[1].length)), o2 > h2[p2][m2] && h2[p2][m2] < 0 && (o2 = h2[p2][m2]);
        } else
          r2.hasNullValues = true;
      }
      f2 !== "bar" && f2 !== "column" || (o2 < 0 && n2 < 0 && (n2 = 0, i2 = Math.max(i2, 0)), o2 === Number.MIN_VALUE && (o2 = 0, e2 = Math.min(e2, 0)));
    }
    return s2.chart.type === "rangeBar" && r2.seriesRangeStart.length && r2.isBarHorizontal && (o2 = e2), s2.chart.type === "bar" && (o2 < 0 && n2 < 0 && (n2 = 0), o2 === Number.MIN_VALUE && (o2 = 0)), { minY: o2, maxY: n2, lowestY: e2, highestY: i2 };
  } }, { key: "setYRange", value: function() {
    var t3 = this.w.globals, e2 = this.w.config;
    t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE;
    var i2, a2 = Number.MAX_VALUE;
    if (t3.isMultipleYAxis) {
      a2 = Number.MAX_VALUE;
      for (var s2 = 0;s2 < t3.series.length; s2++)
        i2 = this.getMinYMaxY(s2), t3.minYArr[s2] = i2.lowestY, t3.maxYArr[s2] = i2.highestY, a2 = Math.min(a2, i2.lowestY);
    }
    if (i2 = this.getMinYMaxY(0, a2, null, t3.series.length), e2.chart.type === "bar" ? (t3.minY = i2.minY, t3.maxY = i2.maxY) : (t3.minY = i2.lowestY, t3.maxY = i2.highestY), a2 = i2.lowestY, e2.chart.stacked && this._setStackedMinMax(), e2.chart.type === "line" || e2.chart.type === "area" || e2.chart.type === "scatter" || e2.chart.type === "candlestick" || e2.chart.type === "boxPlot" || e2.chart.type === "rangeBar" && !t3.isBarHorizontal ? t3.minY === Number.MIN_VALUE && a2 !== -Number.MAX_VALUE && a2 !== t3.maxY && (t3.minY = a2) : t3.minY = t3.minY !== Number.MIN_VALUE ? Math.min(i2.minY, t3.minY) : i2.minY, e2.yaxis.forEach(function(e3, i3) {
      e3.max !== undefined && (typeof e3.max == "number" ? t3.maxYArr[i3] = e3.max : typeof e3.max == "function" && (t3.maxYArr[i3] = e3.max(t3.isMultipleYAxis ? t3.maxYArr[i3] : t3.maxY)), t3.maxY = t3.maxYArr[i3]), e3.min !== undefined && (typeof e3.min == "number" ? t3.minYArr[i3] = e3.min : typeof e3.min == "function" && (t3.minYArr[i3] = e3.min(t3.isMultipleYAxis ? t3.minYArr[i3] === Number.MIN_VALUE ? 0 : t3.minYArr[i3] : t3.minY)), t3.minY = t3.minYArr[i3]);
    }), t3.isBarHorizontal) {
      ["min", "max"].forEach(function(i3) {
        e2.xaxis[i3] !== undefined && typeof e2.xaxis[i3] == "number" && (i3 === "min" ? t3.minY = e2.xaxis[i3] : t3.maxY = e2.xaxis[i3]);
      });
    }
    return t3.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), t3.minY = a2) : (this.scales.setYScaleForIndex(0, t3.minY, t3.maxY), t3.minY = t3.yAxisScale[0].niceMin, t3.maxY = t3.yAxisScale[0].niceMax, t3.minYArr[0] = t3.minY, t3.maxYArr[0] = t3.maxY), t3.barGroups = [], t3.lineGroups = [], t3.areaGroups = [], e2.series.forEach(function(i3) {
      switch (i3.type || e2.chart.type) {
        case "bar":
        case "column":
          t3.barGroups.push(i3.group);
          break;
        case "line":
          t3.lineGroups.push(i3.group);
          break;
        case "area":
          t3.areaGroups.push(i3.group);
      }
    }), t3.barGroups = t3.barGroups.filter(function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    }), t3.lineGroups = t3.lineGroups.filter(function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    }), t3.areaGroups = t3.areaGroups.filter(function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    }), { minY: t3.minY, maxY: t3.maxY, minYArr: t3.minYArr, maxYArr: t3.maxYArr, yAxisScale: t3.yAxisScale };
  } }, { key: "setXRange", value: function() {
    var t3 = this.w.globals, e2 = this.w.config, i2 = e2.xaxis.type === "numeric" || e2.xaxis.type === "datetime" || e2.xaxis.type === "category" && !t3.noLabelsProvided || t3.noLabelsProvided || t3.isXNumeric;
    if (t3.isXNumeric && function() {
      for (var e3 = 0;e3 < t3.series.length; e3++)
        if (t3.labels[e3])
          for (var i3 = 0;i3 < t3.labels[e3].length; i3++)
            t3.labels[e3][i3] !== null && v.isNumber(t3.labels[e3][i3]) && (t3.maxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.initialMaxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.minX = Math.min(t3.minX, t3.labels[e3][i3]), t3.initialMinX = Math.min(t3.minX, t3.labels[e3][i3]));
    }(), t3.noLabelsProvided && e2.xaxis.categories.length === 0 && (t3.maxX = t3.labels[t3.labels.length - 1], t3.initialMaxX = t3.labels[t3.labels.length - 1], t3.minX = 1, t3.initialMinX = 1), t3.isXNumeric || t3.noLabelsProvided || t3.dataFormatXNumeric) {
      var a2 = 10;
      if (e2.xaxis.tickAmount === undefined)
        a2 = Math.round(t3.svgWidth / 150), e2.xaxis.type === "numeric" && t3.dataPoints < 30 && (a2 = t3.dataPoints - 1), a2 > t3.dataPoints && t3.dataPoints !== 0 && (a2 = t3.dataPoints - 1);
      else if (e2.xaxis.tickAmount === "dataPoints") {
        if (t3.series.length > 1 && (a2 = t3.series[t3.maxValsInArrayIndex].length - 1), t3.isXNumeric) {
          var s2 = Math.round(t3.maxX - t3.minX);
          s2 < 30 && (a2 = s2 - 1);
        }
      } else
        a2 = e2.xaxis.tickAmount;
      if (t3.xTickAmount = a2, e2.xaxis.max !== undefined && typeof e2.xaxis.max == "number" && (t3.maxX = e2.xaxis.max), e2.xaxis.min !== undefined && typeof e2.xaxis.min == "number" && (t3.minX = e2.xaxis.min), e2.xaxis.range !== undefined && (t3.minX = t3.maxX - e2.xaxis.range), t3.minX !== Number.MAX_VALUE && t3.maxX !== -Number.MAX_VALUE)
        if (e2.xaxis.convertedCatToNumeric && !t3.dataFormatXNumeric) {
          for (var r2 = [], n2 = t3.minX - 1;n2 < t3.maxX; n2++)
            r2.push(n2 + 1);
          t3.xAxisScale = { result: r2, niceMin: r2[0], niceMax: r2[r2.length - 1] };
        } else
          t3.xAxisScale = this.scales.setXScale(t3.minX, t3.maxX);
      else
        t3.xAxisScale = this.scales.linearScale(0, a2, a2, 0, e2.xaxis.stepSize), t3.noLabelsProvided && t3.labels.length > 0 && (t3.xAxisScale = this.scales.linearScale(1, t3.labels.length, a2 - 1, 0, e2.xaxis.stepSize), t3.seriesX = t3.labels.slice());
      i2 && (t3.labels = t3.xAxisScale.result.slice());
    }
    return t3.isBarHorizontal && t3.labels.length && (t3.xTickAmount = t3.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t3.minX, maxX: t3.maxX };
  } }, { key: "setZRange", value: function() {
    var t3 = this.w.globals;
    if (t3.isDataXYZ) {
      for (var e2 = 0;e2 < t3.series.length; e2++)
        if (t3.seriesZ[e2] !== undefined)
          for (var i2 = 0;i2 < t3.seriesZ[e2].length; i2++)
            t3.seriesZ[e2][i2] !== null && v.isNumber(t3.seriesZ[e2][i2]) && (t3.maxZ = Math.max(t3.maxZ, t3.seriesZ[e2][i2]), t3.minZ = Math.min(t3.minZ, t3.seriesZ[e2][i2]));
    }
  } }, { key: "_handleSingleDataPoint", value: function() {
    var t3 = this.w.globals, e2 = this.w.config;
    if (t3.minX === t3.maxX) {
      var i2 = new zi(this.ctx);
      if (e2.xaxis.type === "datetime") {
        var a2 = i2.getDate(t3.minX);
        e2.xaxis.labels.datetimeUTC ? a2.setUTCDate(a2.getUTCDate() - 2) : a2.setDate(a2.getDate() - 2), t3.minX = new Date(a2).getTime();
        var s2 = i2.getDate(t3.maxX);
        e2.xaxis.labels.datetimeUTC ? s2.setUTCDate(s2.getUTCDate() + 2) : s2.setDate(s2.getDate() + 2), t3.maxX = new Date(s2).getTime();
      } else
        (e2.xaxis.type === "numeric" || e2.xaxis.type === "category" && !t3.noLabelsProvided) && (t3.minX = t3.minX - 2, t3.initialMinX = t3.minX, t3.maxX = t3.maxX + 2, t3.initialMaxX = t3.maxX);
    }
  } }, { key: "_getMinXDiff", value: function() {
    var t3 = this.w.globals;
    t3.isXNumeric && t3.seriesX.forEach(function(e2, i2) {
      if (e2.length) {
        e2.length === 1 && e2.push(t3.seriesX[t3.maxValsInArrayIndex][t3.seriesX[t3.maxValsInArrayIndex].length - 1]);
        var a2 = e2.slice();
        a2.sort(function(t4, e3) {
          return t4 - e3;
        }), a2.forEach(function(e3, i3) {
          if (i3 > 0) {
            var s2 = e3 - a2[i3 - 1];
            s2 > 0 && (t3.minXDiff = Math.min(s2, t3.minXDiff));
          }
        }), t3.dataPoints !== 1 && t3.minXDiff !== Number.MAX_VALUE || (t3.minXDiff = 0.5);
      }
    });
  } }, { key: "_setStackedMinMax", value: function() {
    var t3 = this, e2 = this.w.globals;
    if (e2.series.length) {
      var i2 = e2.seriesGroups;
      i2.length || (i2 = [this.w.globals.seriesNames.map(function(t4) {
        return t4;
      })]);
      var a2 = {}, s2 = {};
      i2.forEach(function(i3) {
        a2[i3] = [], s2[i3] = [], t3.w.config.series.map(function(t4, a3) {
          return i3.indexOf(e2.seriesNames[a3]) > -1 ? a3 : null;
        }).filter(function(t4) {
          return t4 !== null;
        }).forEach(function(r2) {
          for (var n2 = 0;n2 < e2.series[e2.maxValsInArrayIndex].length; n2++) {
            var o2, l2, h2, c2;
            a2[i3][n2] === undefined && (a2[i3][n2] = 0, s2[i3][n2] = 0), (t3.w.config.chart.stacked && !e2.comboCharts || t3.w.config.chart.stacked && e2.comboCharts && (!t3.w.config.chart.stackOnlyBar || ((o2 = t3.w.config.series) === null || o2 === undefined || (l2 = o2[r2]) === null || l2 === undefined ? undefined : l2.type) === "bar" || ((h2 = t3.w.config.series) === null || h2 === undefined || (c2 = h2[r2]) === null || c2 === undefined ? undefined : c2.type) === "column")) && e2.series[r2][n2] !== null && v.isNumber(e2.series[r2][n2]) && (e2.series[r2][n2] > 0 ? a2[i3][n2] += parseFloat(e2.series[r2][n2]) + 0.0001 : s2[i3][n2] += parseFloat(e2.series[r2][n2]));
          }
        });
      }), Object.entries(a2).forEach(function(t4) {
        var i3 = p(t4, 1)[0];
        a2[i3].forEach(function(t5, r2) {
          e2.maxY = Math.max(e2.maxY, a2[i3][r2]), e2.minY = Math.min(e2.minY, s2[i3][r2]);
        });
      });
    }
  } }]), t2;
}();
var ia = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.elgrid = a2, this.w = e2.w;
    var s2 = this.w;
    this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.axisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = s2.config.chart.type === "bar" && s2.config.plotOptions.bar.horizontal, this.xAxisoffX = s2.config.xaxis.position === "bottom" ? s2.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new Ri(e2);
  }
  return s(t2, [{ key: "drawYaxis", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = e2.config.yaxis[t3].labels.style, s2 = a2.fontSize, r2 = a2.fontFamily, n2 = a2.fontWeight, o2 = i2.group({ class: "apexcharts-yaxis", rel: t3, transform: "translate(".concat(e2.globals.translateYAxisX[t3], ", 0)") });
    if (this.axesUtils.isYAxisHidden(t3))
      return o2;
    var l2 = i2.group({ class: "apexcharts-yaxis-texts-g" });
    o2.add(l2);
    var h2 = e2.globals.yAxisScale[t3].result.length - 1, c2 = e2.globals.gridHeight / h2, d2 = e2.globals.yLabelFormatters[t3], u2 = this.axesUtils.checkForReversedLabels(t3, e2.globals.yAxisScale[t3].result.slice());
    if (e2.config.yaxis[t3].labels.show) {
      var g2 = e2.globals.translateY + e2.config.yaxis[t3].labels.offsetY;
      e2.globals.isBarHorizontal ? g2 = 0 : e2.config.chart.type === "heatmap" && (g2 -= c2 / 2), g2 += parseInt(s2, 10) / 3;
      for (var p2 = h2;p2 >= 0; p2--) {
        var f2 = d2(u2[p2], p2, e2), x2 = e2.config.yaxis[t3].labels.padding;
        e2.config.yaxis[t3].opposite && e2.config.yaxis.length !== 0 && (x2 *= -1);
        var b2 = this.getTextAnchor(e2.config.yaxis[t3].labels.align, e2.config.yaxis[t3].opposite), m2 = this.axesUtils.getYAxisForeColor(a2.colors, t3), y2 = Array.isArray(m2) ? m2[p2] : m2, w2 = v.listToArray(e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-label tspan"))).map(function(t4) {
          return t4.textContent;
        }), k2 = i2.drawText({ x: x2, y: g2, text: w2.includes(f2) && !e2.config.yaxis[t3].labels.showDuplicates ? "" : f2, textAnchor: b2, fontSize: s2, fontFamily: r2, fontWeight: n2, maxWidth: e2.config.yaxis[t3].labels.maxWidth, foreColor: y2, isPlainText: false, cssClass: "apexcharts-yaxis-label ".concat(a2.cssClass) });
        l2.add(k2), this.addTooltip(k2, f2), e2.config.yaxis[t3].labels.rotate !== 0 && this.rotateLabel(i2, k2, firstLabel, e2.config.yaxis[t3].labels.rotate), g2 += c2;
      }
    }
    return this.addYAxisTitle(i2, o2, t3), this.addAxisBorder(i2, o2, t3, h2, c2), o2;
  } }, { key: "getTextAnchor", value: function(t3, e2) {
    return t3 === "left" ? "start" : t3 === "center" ? "middle" : t3 === "right" ? "end" : e2 ? "start" : "end";
  } }, { key: "addTooltip", value: function(t3, e2) {
    var i2 = document.createElementNS(this.w.globals.SVGNS, "title");
    i2.textContent = Array.isArray(e2) ? e2.join(" ") : e2, t3.node.appendChild(i2);
  } }, { key: "rotateLabel", value: function(t3, e2, i2, a2) {
    var s2 = t3.rotateAroundCenter(i2.node), r2 = t3.rotateAroundCenter(e2.node);
    e2.node.setAttribute("transform", "rotate(".concat(a2, " ").concat(s2.x, " ").concat(r2.y, ")"));
  } }, { key: "addYAxisTitle", value: function(t3, e2, i2) {
    var a2 = this.w;
    if (a2.config.yaxis[i2].title.text !== undefined) {
      var s2 = t3.group({ class: "apexcharts-yaxis-title" }), r2 = a2.config.yaxis[i2].opposite ? a2.globals.translateYAxisX[i2] : 0, n2 = t3.drawText({ x: r2, y: a2.globals.gridHeight / 2 + a2.globals.translateY + a2.config.yaxis[i2].title.offsetY, text: a2.config.yaxis[i2].title.text, textAnchor: "end", foreColor: a2.config.yaxis[i2].title.style.color, fontSize: a2.config.yaxis[i2].title.style.fontSize, fontWeight: a2.config.yaxis[i2].title.style.fontWeight, fontFamily: a2.config.yaxis[i2].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text ".concat(a2.config.yaxis[i2].title.style.cssClass) });
      s2.add(n2), e2.add(s2);
    }
  } }, { key: "addAxisBorder", value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w, n2 = r2.config.yaxis[i2].axisBorder, o2 = 31 + n2.offsetX;
    if (r2.config.yaxis[i2].opposite && (o2 = -31 - n2.offsetX), n2.show) {
      var l2 = t3.drawLine(o2, r2.globals.translateY + n2.offsetY - 2, o2, r2.globals.gridHeight + r2.globals.translateY + n2.offsetY + 2, n2.color, 0, n2.width);
      e2.add(l2);
    }
    r2.config.yaxis[i2].axisTicks.show && this.axesUtils.drawYAxisTicks(o2, a2, n2, r2.config.yaxis[i2].axisTicks, i2, s2, e2);
  } }, { key: "drawYaxisInversed", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = i2.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s2 = i2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e2.globals.translateXAxisX, ", ").concat(e2.globals.translateXAxisY, ")") });
    a2.add(s2);
    var r2 = e2.globals.yAxisScale[t3].result.length - 1, n2 = e2.globals.gridWidth / r2 + 0.1, o2 = n2 + e2.config.xaxis.labels.offsetX, l2 = e2.globals.xLabelFormatter, h2 = this.axesUtils.checkForReversedLabels(t3, e2.globals.yAxisScale[t3].result.slice()), c2 = e2.globals.timescaleLabels;
    if (c2.length > 0 && (this.xaxisLabels = c2.slice(), r2 = (h2 = c2.slice()).length), e2.config.xaxis.labels.show)
      for (var d2 = c2.length ? 0 : r2;c2.length ? d2 < c2.length : d2 >= 0; c2.length ? d2++ : d2--) {
        var u2 = l2(h2[d2], d2, e2), g2 = e2.globals.gridWidth + e2.globals.padHorizontal - (o2 - n2 + e2.config.xaxis.labels.offsetX);
        if (c2.length) {
          var p2 = this.axesUtils.getLabel(h2, c2, g2, d2, this.drawnLabels, this.xaxisFontSize);
          g2 = p2.x, u2 = p2.text, this.drawnLabels.push(p2.text), d2 === 0 && e2.globals.skipFirstTimelinelabel && (u2 = ""), d2 === h2.length - 1 && e2.globals.skipLastTimelinelabel && (u2 = "");
        }
        var f2 = i2.drawText({ x: g2, y: this.xAxisoffX + e2.config.xaxis.labels.offsetY + 30 - (e2.config.xaxis.position === "top" ? e2.globals.xAxisHeight + e2.config.xaxis.axisTicks.height - 2 : 0), text: u2, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t3] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e2.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label ".concat(e2.config.xaxis.labels.style.cssClass) });
        s2.add(f2), f2.tspan(u2), this.addTooltip(f2, u2), o2 += n2;
      }
    return this.inversedYAxisTitleText(a2), this.inversedYAxisBorder(a2), a2;
  } }, { key: "inversedYAxisBorder", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = e2.config.xaxis.axisBorder;
    if (a2.show) {
      var s2 = 0;
      e2.config.chart.type === "bar" && e2.globals.isXNumeric && (s2 -= 15);
      var r2 = i2.drawLine(e2.globals.padHorizontal + s2 + a2.offsetX, this.xAxisoffX, e2.globals.gridWidth, this.xAxisoffX, a2.color, 0, a2.height);
      this.elgrid && this.elgrid.elGridBorders && e2.config.grid.show ? this.elgrid.elGridBorders.add(r2) : t3.add(r2);
    }
  } }, { key: "inversedYAxisTitleText", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx);
    if (e2.config.xaxis.title.text !== undefined) {
      var a2 = i2.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s2 = i2.drawText({ x: e2.globals.gridWidth / 2 + e2.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e2.config.xaxis.title.style.fontSize) + e2.config.xaxis.title.offsetY + 20, text: e2.config.xaxis.title.text, textAnchor: "middle", fontSize: e2.config.xaxis.title.style.fontSize, fontFamily: e2.config.xaxis.title.style.fontFamily, fontWeight: e2.config.xaxis.title.style.fontWeight, foreColor: e2.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text ".concat(e2.config.xaxis.title.style.cssClass) });
      a2.add(s2), t3.add(a2);
    }
  } }, { key: "yAxisTitleRotate", value: function(t3, e2) {
    var i2 = this.w, a2 = new Mi(this.ctx), s2 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-texts-g")), r2 = s2 ? s2.getBoundingClientRect() : { width: 0, height: 0 }, n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-title text")), o2 = n2 ? n2.getBoundingClientRect() : { width: 0, height: 0 };
    if (n2) {
      var l2 = this.xPaddingForYAxisTitle(t3, r2, o2, e2);
      n2.setAttribute("x", l2.xPos - (e2 ? 10 : 0));
      var h2 = a2.rotateAroundCenter(n2);
      n2.setAttribute("transform", "rotate(".concat(e2 ? -1 * i2.config.yaxis[t3].title.rotate : i2.config.yaxis[t3].title.rotate, " ").concat(h2.x, " ").concat(h2.y, ")"));
    }
  } }, { key: "xPaddingForYAxisTitle", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = 0, n2 = 10;
    return s2.config.yaxis[t3].title.text === undefined || t3 < 0 ? { xPos: r2, padd: 0 } : (a2 ? r2 = e2.width + s2.config.yaxis[t3].title.offsetX + i2.width / 2 + n2 / 2 : (r2 = -1 * e2.width + s2.config.yaxis[t3].title.offsetX + n2 / 2 + i2.width / 2, s2.globals.isBarHorizontal && (n2 = 25, r2 = -1 * e2.width - s2.config.yaxis[t3].title.offsetX - n2)), { xPos: r2, padd: n2 });
  } }, { key: "setYAxisXPosition", value: function(t3, e2) {
    var i2 = this.w, a2 = 0, s2 = 0, r2 = 18, n2 = 1;
    i2.config.yaxis.length > 1 && (this.multipleYs = true), i2.config.yaxis.forEach(function(o2, l2) {
      var h2 = i2.globals.ignoreYAxisIndexes.includes(l2) || !o2.show || o2.floating || t3[l2].width === 0, c2 = t3[l2].width + e2[l2].width;
      o2.opposite ? i2.globals.isBarHorizontal ? (s2 = i2.globals.gridWidth + i2.globals.translateX - 1, i2.globals.translateYAxisX[l2] = s2 - o2.labels.offsetX) : (s2 = i2.globals.gridWidth + i2.globals.translateX + n2, h2 || (n2 += c2 + 20), i2.globals.translateYAxisX[l2] = s2 - o2.labels.offsetX + 20) : (a2 = i2.globals.translateX - r2, h2 || (r2 += c2 + 20), i2.globals.translateYAxisX[l2] = a2 + o2.labels.offsetX);
    });
  } }, { key: "setYAxisTextAlignments", value: function() {
    var t3 = this.w;
    v.listToArray(t3.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach(function(e2, i2) {
      var a2 = t3.config.yaxis[i2];
      if (a2 && !a2.floating && a2.labels.align !== undefined) {
        var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-texts-g")), r2 = v.listToArray(t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-label"))), n2 = s2.getBoundingClientRect();
        r2.forEach(function(t4) {
          t4.setAttribute("text-anchor", a2.labels.align);
        }), a2.labels.align !== "left" || a2.opposite ? a2.labels.align === "center" ? s2.setAttribute("transform", "translate(".concat(n2.width / 2 * (a2.opposite ? 1 : -1), ", 0)")) : a2.labels.align === "right" && a2.opposite && s2.setAttribute("transform", "translate(".concat(n2.width, ", 0)")) : s2.setAttribute("transform", "translate(-".concat(n2.width, ", 0)"));
      }
    });
  } }]), t2;
}();
var aa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.documentEvent = v.bind(this.documentEvent, this);
  }
  return s(t2, [{ key: "addEventListener", value: function(t3, e2) {
    var i2 = this.w;
    i2.globals.events.hasOwnProperty(t3) ? i2.globals.events[t3].push(e2) : i2.globals.events[t3] = [e2];
  } }, { key: "removeEventListener", value: function(t3, e2) {
    var i2 = this.w;
    if (i2.globals.events.hasOwnProperty(t3)) {
      var a2 = i2.globals.events[t3].indexOf(e2);
      a2 !== -1 && i2.globals.events[t3].splice(a2, 1);
    }
  } }, { key: "fireEvent", value: function(t3, e2) {
    var i2 = this.w;
    if (i2.globals.events.hasOwnProperty(t3)) {
      e2 && e2.length || (e2 = []);
      for (var a2 = i2.globals.events[t3], s2 = a2.length, r2 = 0;r2 < s2; r2++)
        a2[r2].apply(null, e2);
    }
  } }, { key: "setupEventHandlers", value: function() {
    var t3 = this, e2 = this.w, i2 = this.ctx, a2 = e2.globals.dom.baseEl.querySelector(e2.globals.chartClass);
    this.ctx.eventList.forEach(function(t4) {
      a2.addEventListener(t4, function(t5) {
        var a3 = Object.assign({}, e2, { seriesIndex: e2.globals.axisCharts ? e2.globals.capturedSeriesIndex : 0, dataPointIndex: e2.globals.capturedDataPointIndex });
        t5.type === "mousemove" || t5.type === "touchmove" ? typeof e2.config.chart.events.mouseMove == "function" && e2.config.chart.events.mouseMove(t5, i2, a3) : t5.type === "mouseleave" || t5.type === "touchleave" ? typeof e2.config.chart.events.mouseLeave == "function" && e2.config.chart.events.mouseLeave(t5, i2, a3) : (t5.type === "mouseup" && t5.which === 1 || t5.type === "touchend") && (typeof e2.config.chart.events.click == "function" && e2.config.chart.events.click(t5, i2, a3), i2.ctx.events.fireEvent("click", [t5, i2, a3]));
      }, { capture: false, passive: true });
    }), this.ctx.eventList.forEach(function(i3) {
      e2.globals.dom.baseEl.addEventListener(i3, t3.documentEvent, { passive: true });
    }), this.ctx.core.setupBrushHandler();
  } }, { key: "documentEvent", value: function(t3) {
    var e2 = this.w, i2 = t3.target.className;
    if (t3.type === "click") {
      var a2 = e2.globals.dom.baseEl.querySelector(".apexcharts-menu");
      a2 && a2.classList.contains("apexcharts-menu-open") && i2 !== "apexcharts-menu-icon" && a2.classList.remove("apexcharts-menu-open");
    }
    e2.globals.clientX = t3.type === "touchmove" ? t3.touches[0].clientX : t3.clientX, e2.globals.clientY = t3.type === "touchmove" ? t3.touches[0].clientY : t3.clientY;
  } }]), t2;
}();
var sa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "setCurrentLocaleValues", value: function(t3) {
    var e2 = this.w.config.chart.locales;
    window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e2 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    var i2 = e2.filter(function(e3) {
      return e3.name === t3;
    })[0];
    if (!i2)
      throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
    var a2 = v.extend(Hi, i2);
    this.w.globals.locale = a2.options;
  } }]), t2;
}();
var ra = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawAxis", value: function(t3, e2) {
    var i2, a2, s2 = this, r2 = this.w.globals, n2 = this.w.config, o2 = new Qi(this.ctx, e2), l2 = new ia(this.ctx, e2);
    r2.axisCharts && t3 !== "radar" && (r2.isBarHorizontal ? (a2 = l2.drawYaxisInversed(0), i2 = o2.drawXaxisInversed(0), r2.dom.elGraphical.add(i2), r2.dom.elGraphical.add(a2)) : (i2 = o2.drawXaxis(), r2.dom.elGraphical.add(i2), n2.yaxis.map(function(t4, e3) {
      if (r2.ignoreYAxisIndexes.indexOf(e3) === -1 && (a2 = l2.drawYaxis(e3), r2.dom.Paper.add(a2), s2.w.config.grid.position === "back")) {
        var i3 = r2.dom.Paper.children()[1];
        i3.remove(), r2.dom.Paper.add(i3);
      }
    })));
  } }]), t2;
}();
var na = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawXCrosshairs", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = new Li(this.ctx), a2 = t3.config.xaxis.crosshairs.fill.gradient, s2 = t3.config.xaxis.crosshairs.dropShadow, r2 = t3.config.xaxis.crosshairs.fill.type, n2 = a2.colorFrom, o2 = a2.colorTo, l2 = a2.opacityFrom, h2 = a2.opacityTo, c2 = a2.stops, d2 = s2.enabled, u2 = s2.left, g2 = s2.top, p2 = s2.blur, f2 = s2.color, x2 = s2.opacity, b2 = t3.config.xaxis.crosshairs.fill.color;
    if (t3.config.xaxis.crosshairs.show) {
      r2 === "gradient" && (b2 = e2.drawGradient("vertical", n2, o2, l2, h2, null, c2, null));
      var m2 = e2.drawRect();
      t3.config.xaxis.crosshairs.width === 1 && (m2 = e2.drawLine());
      var y2 = t3.globals.gridHeight;
      (!v.isNumber(y2) || y2 < 0) && (y2 = 0);
      var w2 = t3.config.xaxis.crosshairs.width;
      (!v.isNumber(w2) || w2 < 0) && (w2 = 0), m2.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2, width: w2, height: y2, fill: b2, filter: "none", "fill-opacity": t3.config.xaxis.crosshairs.opacity, stroke: t3.config.xaxis.crosshairs.stroke.color, "stroke-width": t3.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t3.config.xaxis.crosshairs.stroke.dashArray }), d2 && (m2 = i2.dropShadow(m2, { left: u2, top: g2, blur: p2, color: f2, opacity: x2 })), t3.globals.dom.elGraphical.add(m2);
    }
  } }, { key: "drawYCrosshairs", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.config.yaxis[0].crosshairs, a2 = t3.globals.barPadForNumericAxis;
    if (t3.config.yaxis[0].crosshairs.show) {
      var s2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, i2.stroke.dashArray, i2.stroke.width);
      s2.attr({ class: "apexcharts-ycrosshairs" }), t3.globals.dom.elGraphical.add(s2);
    }
    var r2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, 0, 0);
    r2.attr({ class: "apexcharts-ycrosshairs-hidden" }), t3.globals.dom.elGraphical.add(r2);
  } }]), t2;
}();
var oa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "checkResponsiveConfig", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.config;
    if (a2.responsive.length !== 0) {
      var s2 = a2.responsive.slice();
      s2.sort(function(t4, e3) {
        return t4.breakpoint > e3.breakpoint ? 1 : e3.breakpoint > t4.breakpoint ? -1 : 0;
      }).reverse();
      var r2 = new Wi({}), n2 = function() {
        var t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, a3 = s2[0].breakpoint, n3 = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (n3 > a3) {
          var o3 = v.clone(i2.globals.initialConfig);
          o3.series = v.clone(i2.config.series);
          var l2 = Pi.extendArrayProps(r2, o3, i2);
          t4 = v.extend(l2, t4), t4 = v.extend(i2.config, t4), e2.overrideResponsiveOptions(t4);
        } else
          for (var h2 = 0;h2 < s2.length; h2++)
            n3 < s2[h2].breakpoint && (t4 = Pi.extendArrayProps(r2, s2[h2].options, i2), t4 = v.extend(i2.config, t4), e2.overrideResponsiveOptions(t4));
      };
      if (t3) {
        var o2 = Pi.extendArrayProps(r2, t3, i2);
        o2 = v.extend(i2.config, o2), n2(o2 = v.extend(o2, t3));
      } else
        n2({});
    }
  } }, { key: "overrideResponsiveOptions", value: function(t3) {
    var e2 = new Wi(t3).init({ responsiveOverride: true });
    this.w.config = e2;
  } }]), t2;
}();
var la = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.colors = [], this.isColorFn = false, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
  }
  return s(t2, [{ key: "checkHeatmapDistributed", value: function() {
    var t3 = this.w.config, e2 = t3.chart, i2 = t3.plotOptions;
    return e2.type === "treemap" && i2.treemap && i2.treemap.distributed || e2.type === "heatmap" && i2.heatmap && i2.heatmap.distributed;
  } }, { key: "checkBarDistributed", value: function() {
    var t3 = this.w.config, e2 = t3.chart, i2 = t3.plotOptions;
    return i2.bar && i2.bar.distributed && (e2.type === "bar" || e2.type === "rangeBar");
  } }, { key: "init", value: function() {
    this.setDefaultColors();
  } }, { key: "setDefaultColors", value: function() {
    var t3 = this.w, e2 = new v;
    t3.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(t3.config.theme.mode));
    var i2 = f(t3.config.colors || t3.config.fill.colors || []);
    t3.globals.colors = this.getColors(i2), this.applySeriesColors(t3.globals.seriesColors, t3.globals.colors), t3.config.theme.monochrome.enabled && (t3.globals.colors = this.getMonochromeColors(t3.config.theme.monochrome, t3.globals.series, e2));
    var a2 = t3.globals.colors.slice();
    this.pushExtraColors(t3.globals.colors), this.applyColorTypes(["fill", "stroke"], a2), this.applyDataLabelsColors(a2), this.applyRadarPolygonsColors(), this.applyMarkersColors(a2);
  } }, { key: "getColors", value: function(t3) {
    var e2 = this, i2 = this.w;
    return t3 && t3.length !== 0 ? Array.isArray(t3) && t3.length > 0 && typeof t3[0] == "function" ? (this.isColorFn = true, i2.config.series.map(function(a2, s2) {
      var r2 = t3[s2] || t3[0];
      return typeof r2 == "function" ? r2({ value: i2.globals.axisCharts ? i2.globals.series[s2][0] || 0 : i2.globals.series[s2], seriesIndex: s2, dataPointIndex: s2, w: e2.w }) : r2;
    })) : t3 : this.predefined();
  } }, { key: "applySeriesColors", value: function(t3, e2) {
    t3.forEach(function(t4, i2) {
      t4 && (e2[i2] = t4);
    });
  } }, { key: "getMonochromeColors", value: function(t3, e2, i2) {
    var { color: a2, shadeIntensity: s2, shadeTo: r2 } = t3, n2 = this.isBarDistributed || this.isHeatmapDistributed ? e2[0].length * e2.length : e2.length, o2 = 1 / (n2 / s2), l2 = 0;
    return Array.from({ length: n2 }, function() {
      var t4 = r2 === "dark" ? i2.shadeColor(-1 * l2, a2) : i2.shadeColor(l2, a2);
      return l2 += o2, t4;
    });
  } }, { key: "applyColorTypes", value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    t3.forEach(function(t4) {
      a2.globals[t4].colors = a2.config[t4].colors === undefined ? i2.isColorFn ? a2.config.colors : e2 : a2.config[t4].colors.slice(), i2.pushExtraColors(a2.globals[t4].colors);
    });
  } }, { key: "applyDataLabelsColors", value: function(t3) {
    var e2 = this.w;
    e2.globals.dataLabels.style.colors = e2.config.dataLabels.style.colors === undefined ? t3 : e2.config.dataLabels.style.colors.slice(), this.pushExtraColors(e2.globals.dataLabels.style.colors, 50);
  } }, { key: "applyRadarPolygonsColors", value: function() {
    var t3 = this.w;
    t3.globals.radarPolygons.fill.colors = t3.config.plotOptions.radar.polygons.fill.colors === undefined ? [t3.config.theme.mode === "dark" ? "#424242" : "none"] : t3.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(t3.globals.radarPolygons.fill.colors, 20);
  } }, { key: "applyMarkersColors", value: function(t3) {
    var e2 = this.w;
    e2.globals.markers.colors = e2.config.markers.colors === undefined ? t3 : e2.config.markers.colors.slice(), this.pushExtraColors(e2.globals.markers.colors);
  } }, { key: "pushExtraColors", value: function(t3, e2) {
    var i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null, a2 = this.w, s2 = e2 || a2.globals.series.length;
    if (i2 === null && (i2 = this.isBarDistributed || this.isHeatmapDistributed || a2.config.chart.type === "heatmap" && a2.config.plotOptions.heatmap && a2.config.plotOptions.heatmap.colorScale.inverse), i2 && a2.globals.series.length && (s2 = a2.globals.series[a2.globals.maxValsInArrayIndex].length * a2.globals.series.length), t3.length < s2)
      for (var r2 = s2 - t3.length, n2 = 0;n2 < r2; n2++)
        t3.push(t3[n2]);
  } }, { key: "updateThemeOptions", value: function(t3) {
    t3.chart = t3.chart || {}, t3.tooltip = t3.tooltip || {};
    var e2 = t3.theme.mode, i2 = e2 === "dark" ? "palette4" : e2 === "light" ? "palette1" : t3.theme.palette || "palette1", a2 = e2 === "dark" ? "#f6f7f8" : e2 === "light" ? "#373d3f" : t3.chart.foreColor || "#373d3f";
    return t3.tooltip.theme = e2 || "light", t3.chart.foreColor = a2, t3.theme.palette = i2, t3;
  } }, { key: "predefined", value: function() {
    var t3 = { palette1: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"], palette2: ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"], palette3: ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"], palette4: ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"], palette5: ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"], palette6: ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"], palette7: ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"], palette8: ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"], palette9: ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"], palette10: ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"], default: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"] };
    return t3[this.w.config.theme.palette] || t3.default;
  } }]), t2;
}();
var ha = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "draw", value: function() {
    this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
  } }, { key: "drawTitleSubtitle", value: function(t3) {
    var e2 = this.w, i2 = t3 === "title" ? e2.config.title : e2.config.subtitle, a2 = e2.globals.svgWidth / 2, s2 = i2.offsetY, r2 = "middle";
    if (i2.align === "left" ? (a2 = 10, r2 = "start") : i2.align === "right" && (a2 = e2.globals.svgWidth - 10, r2 = "end"), a2 += i2.offsetX, s2 = s2 + parseInt(i2.style.fontSize, 10) + i2.margin / 2, i2.text !== undefined) {
      var n2 = new Mi(this.ctx).drawText({ x: a2, y: s2, text: i2.text, textAnchor: r2, fontSize: i2.style.fontSize, fontFamily: i2.style.fontFamily, fontWeight: i2.style.fontWeight, foreColor: i2.style.color, opacity: 1 });
      n2.node.setAttribute("class", "apexcharts-".concat(t3, "-text")), e2.globals.dom.Paper.add(n2);
    }
  } }]), t2;
}();
var ca = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getTitleSubtitleCoords", value: function(t3) {
    var e2 = this.w, i2 = 0, a2 = 0, s2 = t3 === "title" ? e2.config.title.floating : e2.config.subtitle.floating, r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(t3, "-text"));
    if (r2 !== null && !s2) {
      var n2 = r2.getBoundingClientRect();
      i2 = n2.width, a2 = e2.globals.axisCharts ? n2.height + 5 : n2.height;
    }
    return { width: i2, height: a2 };
  } }, { key: "getLegendsRect", value: function() {
    var t3 = this.w, e2 = t3.globals.dom.elLegendWrap;
    t3.config.legend.height || t3.config.legend.position !== "top" && t3.config.legend.position !== "bottom" || (e2.style.maxHeight = t3.globals.svgHeight / 2 + "px");
    var i2 = Object.assign({}, v.getBoundingClientRect(e2));
    return e2 !== null && !t3.config.legend.floating && t3.config.legend.show ? this.dCtx.lgRect = { x: i2.x, y: i2.y, height: i2.height, width: i2.height === 0 ? 0 : i2.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, t3.config.legend.position !== "left" && t3.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > t3.globals.svgWidth && (this.dCtx.lgRect.width = t3.globals.svgWidth / 1.5), this.dCtx.lgRect;
  } }, { key: "getDatalabelsRect", value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    e2.config.series.forEach(function(s3, r3) {
      s3.data.forEach(function(s4, n3) {
        var o2;
        o2 = e2.globals.series[r3][n3], a2 = e2.config.dataLabels.formatter(o2, { ctx: t3.dCtx.ctx, seriesIndex: r3, dataPointIndex: n3, w: e2 }), i2.push(a2);
      });
    });
    var a2 = v.getLargestStringFromArr(i2), s2 = new Mi(this.dCtx.ctx), r2 = e2.config.dataLabels.style, n2 = s2.getTextRects(a2, parseInt(r2.fontSize), r2.fontFamily);
    return { width: 1.05 * n2.width, height: n2.height };
  } }, { key: "getLargestStringFromMultiArr", value: function(t3, e2) {
    var i2 = t3;
    if (this.w.globals.isMultiLineX) {
      var a2 = e2.map(function(t4, e3) {
        return Array.isArray(t4) ? t4.length : 1;
      }), s2 = Math.max.apply(Math, f(a2));
      i2 = e2[a2.indexOf(s2)];
    }
    return i2;
  } }]), t2;
}();
var da = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getxAxisLabelsCoords", value: function() {
    var t3, e2 = this.w, i2 = e2.globals.labels.slice();
    if (e2.config.xaxis.convertedCatToNumeric && i2.length === 0 && (i2 = e2.globals.categoryLabels), e2.globals.timescaleLabels.length > 0) {
      var a2 = this.getxAxisTimeScaleLabelsCoords();
      t3 = { width: a2.width, height: a2.height }, e2.globals.rotateXLabels = false;
    } else {
      this.dCtx.lgWidthForSideLegends = e2.config.legend.position !== "left" && e2.config.legend.position !== "right" || e2.config.legend.floating ? 0 : this.dCtx.lgRect.width;
      var s2 = e2.globals.xLabelFormatter, r2 = v.getLargestStringFromArr(i2), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, i2);
      e2.globals.isBarHorizontal && (n2 = r2 = e2.globals.yAxisScale[0].result.reduce(function(t4, e3) {
        return t4.length > e3.length ? t4 : e3;
      }, 0));
      var o2 = new Xi(this.dCtx.ctx), l2 = r2;
      r2 = o2.xLabelFormat(s2, r2, l2, { i: undefined, dateFormatter: new zi(this.dCtx.ctx).formatDate, w: e2 }), n2 = o2.xLabelFormat(s2, n2, l2, { i: undefined, dateFormatter: new zi(this.dCtx.ctx).formatDate, w: e2 }), (e2.config.xaxis.convertedCatToNumeric && r2 === undefined || String(r2).trim() === "") && (n2 = r2 = "1");
      var h2 = new Mi(this.dCtx.ctx), c2 = h2.getTextRects(r2, e2.config.xaxis.labels.style.fontSize), d2 = c2;
      if (r2 !== n2 && (d2 = h2.getTextRects(n2, e2.config.xaxis.labels.style.fontSize)), (t3 = { width: c2.width >= d2.width ? c2.width : d2.width, height: c2.height >= d2.height ? c2.height : d2.height }).width * i2.length > e2.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && e2.config.xaxis.labels.rotate !== 0 || e2.config.xaxis.labels.rotateAlways) {
        if (!e2.globals.isBarHorizontal) {
          e2.globals.rotateXLabels = true;
          var u2 = function(t4) {
            return h2.getTextRects(t4, e2.config.xaxis.labels.style.fontSize, e2.config.xaxis.labels.style.fontFamily, "rotate(".concat(e2.config.xaxis.labels.rotate, " 0 0)"), false);
          };
          c2 = u2(r2), r2 !== n2 && (d2 = u2(n2)), t3.height = (c2.height > d2.height ? c2.height : d2.height) / 1.5, t3.width = c2.width > d2.width ? c2.width : d2.width;
        }
      } else
        e2.globals.rotateXLabels = false;
    }
    return e2.config.xaxis.labels.show || (t3 = { width: 0, height: 0 }), { width: t3.width, height: t3.height };
  } }, { key: "getxAxisGroupLabelsCoords", value: function() {
    var t3, e2 = this.w;
    if (!e2.globals.hasXaxisGroups)
      return { width: 0, height: 0 };
    var i2, a2 = ((t3 = e2.config.xaxis.group.style) === null || t3 === undefined ? undefined : t3.fontSize) || e2.config.xaxis.labels.style.fontSize, s2 = e2.globals.groups.map(function(t4) {
      return t4.title;
    }), r2 = v.getLargestStringFromArr(s2), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, s2), o2 = new Mi(this.dCtx.ctx), l2 = o2.getTextRects(r2, a2), h2 = l2;
    return r2 !== n2 && (h2 = o2.getTextRects(n2, a2)), i2 = { width: l2.width >= h2.width ? l2.width : h2.width, height: l2.height >= h2.height ? l2.height : h2.height }, e2.config.xaxis.labels.show || (i2 = { width: 0, height: 0 }), { width: i2.width, height: i2.height };
  } }, { key: "getxAxisTitleCoords", value: function() {
    var t3 = this.w, e2 = 0, i2 = 0;
    if (t3.config.xaxis.title.text !== undefined) {
      var a2 = new Mi(this.dCtx.ctx).getTextRects(t3.config.xaxis.title.text, t3.config.xaxis.title.style.fontSize);
      e2 = a2.width, i2 = a2.height;
    }
    return { width: e2, height: i2 };
  } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
    var t3, e2 = this.w;
    this.dCtx.timescaleLabels = e2.globals.timescaleLabels.slice();
    var i2 = this.dCtx.timescaleLabels.map(function(t4) {
      return t4.value;
    }), a2 = i2.reduce(function(t4, e3) {
      return t4 === undefined ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t4.length > e3.length ? t4 : e3;
    }, 0);
    return 1.05 * (t3 = new Mi(this.dCtx.ctx).getTextRects(a2, e2.config.xaxis.labels.style.fontSize)).width * i2.length > e2.globals.gridWidth && e2.config.xaxis.labels.rotate !== 0 && (e2.globals.overlappingXLabels = true), t3;
  } }, { key: "additionalPaddingXLabels", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.globals, s2 = i2.config, r2 = s2.xaxis.type, n2 = t3.width;
    a2.skipLastTimelinelabel = false, a2.skipFirstTimelinelabel = false;
    var o2 = i2.config.yaxis[0].opposite && i2.globals.isBarHorizontal, l2 = function(t4, o3) {
      s2.yaxis.length > 1 && function(t5) {
        return a2.collapsedSeriesIndices.indexOf(t5) !== -1;
      }(o3) || function(t5) {
        if (e2.dCtx.timescaleLabels && e2.dCtx.timescaleLabels.length) {
          var o4 = e2.dCtx.timescaleLabels[0], l3 = e2.dCtx.timescaleLabels[e2.dCtx.timescaleLabels.length - 1].position + n2 / 1.75 - e2.dCtx.yAxisWidthRight, h2 = o4.position - n2 / 1.75 + e2.dCtx.yAxisWidthLeft, c2 = i2.config.legend.position === "right" && e2.dCtx.lgRect.width > 0 ? e2.dCtx.lgRect.width : 0;
          l3 > a2.svgWidth - a2.translateX - c2 && (a2.skipLastTimelinelabel = true), h2 < -(t5.show && !t5.floating || s2.chart.type !== "bar" && s2.chart.type !== "candlestick" && s2.chart.type !== "rangeBar" && s2.chart.type !== "boxPlot" ? 10 : n2 / 1.75) && (a2.skipFirstTimelinelabel = true);
        } else
          r2 === "datetime" ? e2.dCtx.gridPad.right < n2 && !a2.rotateXLabels && (a2.skipLastTimelinelabel = true) : r2 !== "datetime" && e2.dCtx.gridPad.right < n2 / 2 - e2.dCtx.yAxisWidthRight && !a2.rotateXLabels && !i2.config.xaxis.labels.trim && (e2.dCtx.xPadRight = n2 / 2 + 1);
      }(t4);
    };
    s2.yaxis.forEach(function(t4, i3) {
      o2 ? (e2.dCtx.gridPad.left < n2 && (e2.dCtx.xPadLeft = n2 / 2 + 1), e2.dCtx.xPadRight = n2 / 2 + 1) : l2(t4, i3);
    });
  } }]), t2;
}();
var ua = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getyAxisLabelsCoords", value: function() {
    var t3 = this, e2 = this.w, i2 = [], a2 = 10, s2 = new Ri(this.dCtx.ctx);
    return e2.config.yaxis.map(function(r2, n2) {
      var o2 = { seriesIndex: n2, dataPointIndex: -1, w: e2 }, l2 = e2.globals.yAxisScale[n2], h2 = 0;
      if (!s2.isYAxisHidden(n2) && r2.labels.show && r2.labels.minWidth !== undefined && (h2 = r2.labels.minWidth), !s2.isYAxisHidden(n2) && r2.labels.show && l2.result.length) {
        var c2 = e2.globals.yLabelFormatters[n2], d2 = l2.niceMin === Number.MIN_VALUE ? 0 : l2.niceMin, u2 = l2.result.reduce(function(t4, e3) {
          var i3, a3;
          return ((i3 = String(c2(t4, o2))) === null || i3 === undefined ? undefined : i3.length) > ((a3 = String(c2(e3, o2))) === null || a3 === undefined ? undefined : a3.length) ? t4 : e3;
        }, d2), g2 = u2 = c2(u2, o2);
        if (u2 !== undefined && u2.length !== 0 || (u2 = l2.niceMax), e2.globals.isBarHorizontal) {
          a2 = 0;
          var p2 = e2.globals.labels.slice();
          u2 = v.getLargestStringFromArr(p2), u2 = c2(u2, { seriesIndex: n2, dataPointIndex: -1, w: e2 }), g2 = t3.dCtx.dimHelpers.getLargestStringFromMultiArr(u2, p2);
        }
        var f2 = new Mi(t3.dCtx.ctx), x2 = "rotate(".concat(r2.labels.rotate, " 0 0)"), b2 = f2.getTextRects(u2, r2.labels.style.fontSize, r2.labels.style.fontFamily, x2, false), m2 = b2;
        u2 !== g2 && (m2 = f2.getTextRects(g2, r2.labels.style.fontSize, r2.labels.style.fontFamily, x2, false)), i2.push({ width: (h2 > m2.width || h2 > b2.width ? h2 : m2.width > b2.width ? m2.width : b2.width) + a2, height: m2.height > b2.height ? m2.height : b2.height });
      } else
        i2.push({ width: 0, height: 0 });
    }), i2;
  } }, { key: "getyAxisTitleCoords", value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    return e2.config.yaxis.map(function(e3, a2) {
      if (e3.show && e3.title.text !== undefined) {
        var s2 = new Mi(t3.dCtx.ctx), r2 = "rotate(".concat(e3.title.rotate, " 0 0)"), n2 = s2.getTextRects(e3.title.text, e3.title.style.fontSize, e3.title.style.fontFamily, r2, false);
        i2.push({ width: n2.width, height: n2.height });
      } else
        i2.push({ width: 0, height: 0 });
    }), i2;
  } }, { key: "getTotalYAxisWidth", value: function() {
    var t3 = this.w, e2 = 0, i2 = 0, a2 = 0, s2 = t3.globals.yAxisScale.length > 1 ? 10 : 0, r2 = new Ri(this.dCtx.ctx), n2 = function(n3, o2) {
      var l2 = t3.config.yaxis[o2].floating, h2 = 0;
      n3.width > 0 && !l2 ? (h2 = n3.width + s2, function(e3) {
        return t3.globals.ignoreYAxisIndexes.indexOf(e3) > -1;
      }(o2) && (h2 = h2 - n3.width - s2)) : h2 = l2 || r2.isYAxisHidden(o2) ? 0 : 5, t3.config.yaxis[o2].opposite ? a2 += h2 : i2 += h2, e2 += h2;
    };
    return t3.globals.yLabelsCoords.map(function(t4, e3) {
      n2(t4, e3);
    }), t3.globals.yTitleCoords.map(function(t4, e3) {
      n2(t4, e3);
    }), t3.globals.isBarHorizontal && !t3.config.yaxis[0].floating && (e2 = t3.globals.yLabelsCoords[0].width + t3.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i2, this.dCtx.yAxisWidthRight = a2, e2;
  } }]), t2;
}();
var ga = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "gridPadForColumnsInNumericAxis", value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = e2.globals;
    if (a2.noData || a2.collapsedSeries.length + a2.ancillaryCollapsedSeries.length === i2.series.length)
      return 0;
    var s2 = function(t4) {
      return ["bar", "rangeBar", "candlestick", "boxPlot"].includes(t4);
    }, r2 = i2.chart.type, n2 = 0, o2 = s2(r2) ? i2.series.length : 1;
    a2.comboBarCount > 0 && (o2 = a2.comboBarCount), a2.collapsedSeries.forEach(function(t4) {
      s2(t4.type) && (o2 -= 1);
    }), i2.chart.stacked && (o2 = 1);
    var l2 = s2(r2) || a2.comboBarCount > 0, h2 = Math.abs(a2.initialMaxX - a2.initialMinX);
    if (l2 && a2.isXNumeric && !a2.isBarHorizontal && o2 > 0 && h2 !== 0) {
      h2 <= 3 && (h2 = a2.dataPoints);
      var c2 = h2 / t3, d2 = a2.minXDiff && a2.minXDiff / c2 > 0 ? a2.minXDiff / c2 : 0;
      d2 > t3 / 2 && (d2 /= 2), (n2 = d2 * parseInt(i2.plotOptions.bar.columnWidth, 10) / 100) < 1 && (n2 = 1), a2.barPadForNumericAxis = n2;
    }
    return n2;
  } }, { key: "gridPadFortitleSubtitle", value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dCtx.isSparkline || !i2.axisCharts ? 0 : 10;
    ["title", "subtitle"].forEach(function(s3) {
      e2.config[s3].text !== undefined ? a2 += e2.config[s3].margin : a2 += t3.dCtx.isSparkline || !i2.axisCharts ? 0 : 5;
    }), !e2.config.legend.show || e2.config.legend.position !== "bottom" || e2.config.legend.floating || i2.axisCharts || (a2 += 10);
    var s2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
    i2.gridHeight -= s2.height + r2.height + a2, i2.translateY += s2.height + r2.height + a2;
  } }, { key: "setGridXPosForDualYAxis", value: function(t3, e2) {
    var i2 = this.w, a2 = new Ri(this.dCtx.ctx);
    i2.config.yaxis.forEach(function(s2, r2) {
      i2.globals.ignoreYAxisIndexes.indexOf(r2) !== -1 || s2.floating || a2.isYAxisHidden(r2) || (s2.opposite && (i2.globals.translateX -= e2[r2].width + t3[r2].width + parseInt(s2.labels.style.fontSize, 10) / 1.2 + 12), i2.globals.translateX < 2 && (i2.globals.translateX = 2));
    });
  } }]), t2;
}();
var pa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new ca(this), this.dimYAxis = new ua(this), this.dimXAxis = new da(this), this.dimGrid = new ga(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }
  return s(t2, [{ key: "plotCoords", value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals;
    this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
    var a2 = Array.isArray(e2.config.stroke.width) ? Math.max.apply(Math, f(e2.config.stroke.width)) : e2.config.stroke.width;
    this.isSparkline && ((e2.config.markers.discrete.length > 0 || e2.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(e3) {
      var i3 = p(e3, 2), a3 = i3[0], s3 = i3[1];
      t3.gridPad[a3] = Math.max(s3, t3.w.globals.markers.largestSize / 1.5);
    }), this.gridPad.top = Math.max(a2 / 2, this.gridPad.top), this.gridPad.bottom = Math.max(a2 / 2, this.gridPad.bottom)), i2.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i2.gridHeight = i2.gridHeight - this.gridPad.top - this.gridPad.bottom, i2.gridWidth = i2.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
    var s2 = this.dimGrid.gridPadForColumnsInNumericAxis(i2.gridWidth);
    i2.gridWidth = i2.gridWidth - 2 * s2, i2.translateX = i2.translateX + this.gridPad.left + this.xPadLeft + (s2 > 0 ? s2 : 0), i2.translateY = i2.translateY + this.gridPad.top;
  } }, { key: "setDimensionsForAxisCharts", value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dimYAxis.getyAxisLabelsCoords(), s2 = this.dimYAxis.getyAxisTitleCoords();
    i2.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), e2.globals.yLabelsCoords = [], e2.globals.yTitleCoords = [], e2.config.yaxis.map(function(t4, i3) {
      e2.globals.yLabelsCoords.push({ width: a2[i3].width, index: i3 }), e2.globals.yTitleCoords.push({ width: s2[i3].width, index: i3 });
    }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
    var r2 = this.dimXAxis.getxAxisLabelsCoords(), n2 = this.dimXAxis.getxAxisGroupLabelsCoords(), o2 = this.dimXAxis.getxAxisTitleCoords();
    this.conditionalChecksForAxisCoords(r2, o2, n2), i2.translateXAxisY = e2.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i2.translateXAxisX = e2.globals.rotateXLabels && e2.globals.isXNumeric && e2.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e2.globals.isBarHorizontal && (i2.rotateXLabels = false, i2.translateXAxisY = parseInt(e2.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i2.translateXAxisY = i2.translateXAxisY + e2.config.xaxis.labels.offsetY, i2.translateXAxisX = i2.translateXAxisX + e2.config.xaxis.labels.offsetX;
    var l2 = this.yAxisWidth, h2 = this.xAxisHeight;
    i2.xAxisLabelsHeight = this.xAxisHeight - o2.height, i2.xAxisGroupLabelsHeight = i2.xAxisLabelsHeight - r2.height, i2.xAxisLabelsWidth = this.xAxisWidth, i2.xAxisHeight = this.xAxisHeight;
    var c2 = 10;
    (e2.config.chart.type === "radar" || this.isSparkline) && (l2 = 0, h2 = 0), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || e2.config.chart.type === "treemap") && (l2 = 0, h2 = 0, c2 = 0), this.isSparkline || e2.config.chart.type === "treemap" || this.dimXAxis.additionalPaddingXLabels(r2);
    var d2 = function() {
      i2.translateX = l2 + t3.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - t3.lgRect.height - h2 - (t3.isSparkline || e2.config.chart.type === "treemap" ? 0 : e2.globals.rotateXLabels ? 10 : 15), i2.gridWidth = i2.svgWidth - l2 - 2 * t3.datalabelsCoords.width;
    };
    switch (e2.config.xaxis.position === "top" && (c2 = i2.xAxisHeight - e2.config.xaxis.axisTicks.height - 5), e2.config.legend.position) {
      case "bottom":
        i2.translateY = c2, d2();
        break;
      case "top":
        i2.translateY = this.lgRect.height + c2, d2();
        break;
      case "left":
        i2.translateY = c2, i2.translateX = this.lgRect.width + l2 + this.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 2 * this.datalabelsCoords.width;
        break;
      case "right":
        i2.translateY = c2, i2.translateX = l2 + this.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 2 * this.datalabelsCoords.width - 5;
        break;
      default:
        throw new Error("Legend position not supported");
    }
    this.dimGrid.setGridXPosForDualYAxis(s2, a2), new ia(this.ctx).setYAxisXPosition(a2, s2);
  } }, { key: "setDimensionsForNonAxisCharts", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = 0;
    t3.config.legend.show && !t3.config.legend.floating && (a2 = 20);
    var s2 = i2.chart.type === "pie" || i2.chart.type === "polarArea" || i2.chart.type === "donut" ? "pie" : "radialBar", r2 = i2.plotOptions[s2].offsetY, n2 = i2.plotOptions[s2].offsetX;
    if (!i2.legend.show || i2.legend.floating) {
      e2.gridHeight = e2.svgHeight;
      var o2 = e2.dom.elWrap.getBoundingClientRect().width;
      return e2.gridWidth = Math.min(o2, e2.gridHeight), e2.translateY = r2, void (e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2);
    }
    switch (i2.legend.position) {
      case "bottom":
        e2.gridHeight = e2.svgHeight - this.lgRect.height, e2.gridWidth = e2.svgWidth, e2.translateY = r2 - 10, e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2;
        break;
      case "top":
        e2.gridHeight = e2.svgHeight - this.lgRect.height, e2.gridWidth = e2.svgWidth, e2.translateY = this.lgRect.height + r2 + 10, e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2;
        break;
      case "left":
        e2.gridWidth = e2.svgWidth - this.lgRect.width - a2, e2.gridHeight = i2.chart.height !== "auto" ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = n2 + this.lgRect.width + a2;
        break;
      case "right":
        e2.gridWidth = e2.svgWidth - this.lgRect.width - a2 - 5, e2.gridHeight = i2.chart.height !== "auto" ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = n2 + 10;
        break;
      default:
        throw new Error("Legend position not supported");
    }
  } }, { key: "conditionalChecksForAxisCoords", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.globals.hasXaxisGroups ? 2 : 1, r2 = i2.height + t3.height + e2.height, n2 = a2.globals.isMultiLineX ? 1.2 : a2.globals.LINE_HEIGHT_RATIO, o2 = a2.globals.rotateXLabels ? 22 : 10, l2 = a2.globals.rotateXLabels && a2.config.legend.position === "bottom" ? 10 : 0;
    this.xAxisHeight = r2 * n2 + s2 * o2 + l2, this.xAxisWidth = t3.width, this.xAxisHeight - e2.height > a2.config.xaxis.labels.maxHeight && (this.xAxisHeight = a2.config.xaxis.labels.maxHeight), a2.config.xaxis.labels.minHeight && this.xAxisHeight < a2.config.xaxis.labels.minHeight && (this.xAxisHeight = a2.config.xaxis.labels.minHeight), a2.config.xaxis.floating && (this.xAxisHeight = 0);
    var h2 = 0, c2 = 0;
    a2.config.yaxis.forEach(function(t4) {
      h2 += t4.labels.minWidth, c2 += t4.labels.maxWidth;
    }), this.yAxisWidth < h2 && (this.yAxisWidth = h2), this.yAxisWidth > c2 && (this.yAxisWidth = c2);
  } }]), t2;
}();
var fa = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.lgCtx = e2;
  }
  return s(t2, [{ key: "getLegendStyles", value: function() {
    var t3, e2, i2, a2 = document.createElement("style");
    a2.setAttribute("type", "text/css");
    var s2 = ((t3 = this.lgCtx.ctx) === null || t3 === undefined || (e2 = t3.opts) === null || e2 === undefined || (i2 = e2.chart) === null || i2 === undefined ? undefined : i2.nonce) || this.w.config.chart.nonce;
    s2 && a2.setAttribute("nonce", s2);
    var r2 = document.createTextNode("\n      .apexcharts-flip-y {\n        transform: scaleY(-1) translateY(-100%);\n        transform-origin: top;\n        transform-box: fill-box;\n      }\n      .apexcharts-flip-x {\n        transform: scaleX(-1);\n        transform-origin: center;\n        transform-box: fill-box;\n      }\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apexcharts-legend-group-horizontal {\n        flex-direction: column;\n      }\n      .apexcharts-legend-group {\n        display: flex;\n      }\n      .apexcharts-legend-group-vertical {\n        flex-direction: column-reverse;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n        align-items: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n        align-items: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n        align-items: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        margin-right: 1px;\n      }\n\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }\n\n    ");
    return a2.appendChild(r2), a2;
  } }, { key: "getLegendDimensions", value: function() {
    var t3 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e2 = t3.width;
    return { clwh: t3.height, clww: e2 };
  } }, { key: "appendToForeignObject", value: function() {
    this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
  } }, { key: "toggleDataSeries", value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    if (a2.globals.axisCharts || a2.config.chart.type === "radialBar") {
      a2.globals.resized = true;
      var s2 = null, r2 = null;
      if (a2.globals.risingSeries = [], a2.globals.axisCharts ? (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t3, "']")), r2 = parseInt(s2.getAttribute("data:realIndex"), 10)) : (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t3 + 1, "']")), r2 = parseInt(s2.getAttribute("rel"), 10) - 1), e2)
        [{ cs: a2.globals.collapsedSeries, csi: a2.globals.collapsedSeriesIndices }, { cs: a2.globals.ancillaryCollapsedSeries, csi: a2.globals.ancillaryCollapsedSeriesIndices }].forEach(function(t4) {
          i2.riseCollapsedSeries(t4.cs, t4.csi, r2);
        });
      else
        this.hideSeries({ seriesEl: s2, realIndex: r2 });
    } else {
      var n2 = a2.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(t3 + 1, "'] path")), o2 = a2.config.chart.type;
      if (o2 === "pie" || o2 === "polarArea" || o2 === "donut") {
        var l2 = a2.config.plotOptions.pie.donut.labels;
        new Mi(this.lgCtx.ctx).pathMouseDown(n2, null), this.lgCtx.ctx.pie.printDataLabelsInner(n2.node, l2);
      }
      n2.fire("click");
    }
  } }, { key: "getSeriesAfterCollapsing", value: function(t3) {
    var e2 = t3.realIndex, i2 = this.w, a2 = i2.globals, s2 = v.clone(i2.config.series);
    if (a2.axisCharts) {
      var r2 = i2.config.yaxis[a2.seriesYAxisReverseMap[e2]], n2 = { index: e2, data: s2[e2].data.slice(), type: s2[e2].type || i2.config.chart.type };
      if (r2 && r2.show && r2.showAlways)
        a2.ancillaryCollapsedSeriesIndices.indexOf(e2) < 0 && (a2.ancillaryCollapsedSeries.push(n2), a2.ancillaryCollapsedSeriesIndices.push(e2));
      else if (a2.collapsedSeriesIndices.indexOf(e2) < 0) {
        a2.collapsedSeries.push(n2), a2.collapsedSeriesIndices.push(e2);
        var o2 = a2.risingSeries.indexOf(e2);
        a2.risingSeries.splice(o2, 1);
      }
    } else
      a2.collapsedSeries.push({ index: e2, data: s2[e2] }), a2.collapsedSeriesIndices.push(e2);
    return a2.allSeriesCollapsed = a2.collapsedSeries.length + a2.ancillaryCollapsedSeries.length === i2.config.series.length, this._getSeriesBasedOnCollapsedState(s2);
  } }, { key: "hideSeries", value: function(t3) {
    for (var { seriesEl: e2, realIndex: i2 } = t3, a2 = this.w, s2 = this.getSeriesAfterCollapsing({ realIndex: i2 }), r2 = e2.childNodes, n2 = 0;n2 < r2.length; n2++)
      r2[n2].classList.contains("apexcharts-series-markers-wrap") && (r2[n2].classList.contains("apexcharts-hide") ? r2[n2].classList.remove("apexcharts-hide") : r2[n2].classList.add("apexcharts-hide"));
    this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
  } }, { key: "riseCollapsedSeries", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = v.clone(a2.config.series);
    if (t3.length > 0) {
      for (var r2 = 0;r2 < t3.length; r2++)
        t3[r2].index === i2 && (a2.globals.axisCharts ? s2[i2].data = t3[r2].data.slice() : s2[i2] = t3[r2].data, typeof s2[i2] != "number" && (s2[i2].hidden = false), t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2));
      s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
    }
  } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t3) {
    var e2 = this.w, i2 = 0;
    return e2.globals.axisCharts ? t3.forEach(function(a2, s2) {
      e2.globals.collapsedSeriesIndices.indexOf(s2) < 0 && e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2) < 0 || (t3[s2].data = [], i2++);
    }) : t3.forEach(function(a2, s2) {
      !e2.globals.collapsedSeriesIndices.indexOf(s2) < 0 && (t3[s2] = 0, i2++);
    }), e2.globals.allSeriesCollapsed = i2 === t3.length, t3;
  } }]), t2;
}();
var xa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new fa(this);
  }
  return s(t2, [{ key: "init", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = i2.legend.showForSingleSeries && e2.series.length === 1 || this.isBarsDistributed || e2.series.length > 1;
    if (this.legendHelpers.appendToForeignObject(), (a2 || !e2.axisCharts) && i2.legend.show) {
      for (;e2.dom.elLegendWrap.firstChild; )
        e2.dom.elLegendWrap.removeChild(e2.dom.elLegendWrap.firstChild);
      this.drawLegends(), i2.legend.position === "bottom" || i2.legend.position === "top" ? this.legendAlignHorizontal() : i2.legend.position !== "right" && i2.legend.position !== "left" || this.legendAlignVertical();
    }
  } }, { key: "createLegendMarker", value: function(t3) {
    var { i: e2, fillcolor: i2 } = t3, a2 = this.w, s2 = document.createElement("span");
    s2.classList.add("apexcharts-legend-marker");
    var r2 = a2.config.legend.markers.shape || a2.config.markers.shape, n2 = r2;
    Array.isArray(r2) && (n2 = r2[e2]);
    var o2 = Array.isArray(a2.config.legend.markers.size) ? parseFloat(a2.config.legend.markers.size[e2]) : parseFloat(a2.config.legend.markers.size), l2 = Array.isArray(a2.config.legend.markers.offsetX) ? parseFloat(a2.config.legend.markers.offsetX[e2]) : parseFloat(a2.config.legend.markers.offsetX), h2 = Array.isArray(a2.config.legend.markers.offsetY) ? parseFloat(a2.config.legend.markers.offsetY[e2]) : parseFloat(a2.config.legend.markers.offsetY), c2 = Array.isArray(a2.config.legend.markers.strokeWidth) ? parseFloat(a2.config.legend.markers.strokeWidth[e2]) : parseFloat(a2.config.legend.markers.strokeWidth), d2 = s2.style;
    if (d2.height = 2 * (o2 + c2) + "px", d2.width = 2 * (o2 + c2) + "px", d2.left = l2 + "px", d2.top = h2 + "px", a2.config.legend.markers.customHTML)
      d2.background = "transparent", d2.color = i2[e2], Array.isArray(a2.config.legend.markers.customHTML) ? a2.config.legend.markers.customHTML[e2] && (s2.innerHTML = a2.config.legend.markers.customHTML[e2]()) : s2.innerHTML = a2.config.legend.markers.customHTML();
    else {
      var g2 = new Vi(this.ctx).getMarkerConfig({ cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(n2), seriesIndex: e2, strokeWidth: c2, size: o2 }), p2 = window.SVG().addTo(s2).size("100%", "100%"), f2 = new Mi(this.ctx).drawMarker(0, 0, u(u({}, g2), {}, { pointFillColor: Array.isArray(i2) ? i2[e2] : g2.pointFillColor, shape: n2 }));
      a2.globals.dom.Paper.find(".apexcharts-legend-marker.apexcharts-marker").forEach(function(t4) {
        t4.node.classList.contains("apexcharts-marker-triangle") ? t4.node.style.transform = "translate(50%, 45%)" : t4.node.style.transform = "translate(50%, 50%)";
      }), p2.add(f2);
    }
    return s2;
  } }, { key: "drawLegends", value: function() {
    var t3 = this, e2 = this, i2 = this.w, a2 = i2.config.legend.fontFamily, s2 = i2.globals.seriesNames, r2 = i2.config.legend.markers.fillColors ? i2.config.legend.markers.fillColors.slice() : i2.globals.colors.slice();
    if (i2.config.chart.type === "heatmap") {
      var n2 = i2.config.plotOptions.heatmap.colorScale.ranges;
      s2 = n2.map(function(t4) {
        return t4.name ? t4.name : t4.from + " - " + t4.to;
      }), r2 = n2.map(function(t4) {
        return t4.color;
      });
    } else
      this.isBarsDistributed && (s2 = i2.globals.labels.slice());
    i2.config.legend.customLegendItems.length && (s2 = i2.config.legend.customLegendItems);
    var o2 = i2.globals.legendFormatter, l2 = i2.config.legend.inverseOrder, h2 = [];
    i2.globals.seriesGroups.length > 1 && i2.config.legend.clusterGroupedSeries && i2.globals.seriesGroups.forEach(function(t4, e3) {
      h2[e3] = document.createElement("div"), h2[e3].classList.add("apexcharts-legend-group", "apexcharts-legend-group-".concat(e3)), i2.config.legend.clusterGroupedSeriesOrientation === "horizontal" ? i2.globals.dom.elLegendWrap.classList.add("apexcharts-legend-group-horizontal") : h2[e3].classList.add("apexcharts-legend-group-vertical");
    });
    for (var c2 = function(e3) {
      var n3, l3 = o2(s2[e3], { seriesIndex: e3, w: i2 }), c3 = false, d3 = false;
      if (i2.globals.collapsedSeries.length > 0)
        for (var u2 = 0;u2 < i2.globals.collapsedSeries.length; u2++)
          i2.globals.collapsedSeries[u2].index === e3 && (c3 = true);
      if (i2.globals.ancillaryCollapsedSeriesIndices.length > 0)
        for (var g2 = 0;g2 < i2.globals.ancillaryCollapsedSeriesIndices.length; g2++)
          i2.globals.ancillaryCollapsedSeriesIndices[g2] === e3 && (d3 = true);
      var p2 = t3.createLegendMarker({ i: e3, fillcolor: r2 });
      Mi.setAttrs(p2, { rel: e3 + 1, "data:collapsed": c3 || d3 }), (c3 || d3) && p2.classList.add("apexcharts-inactive-legend");
      var f2 = document.createElement("div"), x2 = document.createElement("span");
      x2.classList.add("apexcharts-legend-text"), x2.innerHTML = Array.isArray(l3) ? l3.join(" ") : l3;
      var b2 = i2.config.legend.labels.useSeriesColors ? i2.globals.colors[e3] : Array.isArray(i2.config.legend.labels.colors) ? (n3 = i2.config.legend.labels.colors) === null || n3 === undefined ? undefined : n3[e3] : i2.config.legend.labels.colors;
      b2 || (b2 = i2.config.chart.foreColor), x2.style.color = b2, x2.style.fontSize = parseFloat(i2.config.legend.fontSize) + "px", x2.style.fontWeight = i2.config.legend.fontWeight, x2.style.fontFamily = a2 || i2.config.chart.fontFamily, Mi.setAttrs(x2, { rel: e3 + 1, i: e3, "data:default-text": encodeURIComponent(l3), "data:collapsed": c3 || d3 }), f2.appendChild(p2), f2.appendChild(x2);
      var m2 = new Pi(t3.ctx);
      i2.config.legend.showForZeroSeries || m2.getSeriesTotalByIndex(e3) === 0 && m2.seriesHaveSameValues(e3) && !m2.isSeriesNull(e3) && i2.globals.collapsedSeriesIndices.indexOf(e3) === -1 && i2.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) === -1 && f2.classList.add("apexcharts-hidden-zero-series");
      i2.config.legend.showForNullSeries || m2.isSeriesNull(e3) && i2.globals.collapsedSeriesIndices.indexOf(e3) === -1 && i2.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) === -1 && f2.classList.add("apexcharts-hidden-null-series"), h2.length ? i2.globals.seriesGroups.forEach(function(t4, a3) {
        var s3;
        t4.includes((s3 = i2.config.series[e3]) === null || s3 === undefined ? undefined : s3.name) && (i2.globals.dom.elLegendWrap.appendChild(h2[a3]), h2[a3].appendChild(f2));
      }) : i2.globals.dom.elLegendWrap.appendChild(f2), i2.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(i2.config.legend.horizontalAlign)), i2.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + i2.config.legend.position), f2.classList.add("apexcharts-legend-series"), f2.style.margin = "".concat(i2.config.legend.itemMargin.vertical, "px ").concat(i2.config.legend.itemMargin.horizontal, "px"), i2.globals.dom.elLegendWrap.style.width = i2.config.legend.width ? i2.config.legend.width + "px" : "", i2.globals.dom.elLegendWrap.style.height = i2.config.legend.height ? i2.config.legend.height + "px" : "", Mi.setAttrs(f2, { rel: e3 + 1, seriesName: v.escapeString(s2[e3]), "data:collapsed": c3 || d3 }), (c3 || d3) && f2.classList.add("apexcharts-inactive-legend"), i2.config.legend.onItemClick.toggleDataSeries || f2.classList.add("apexcharts-no-click");
    }, d2 = l2 ? s2.length - 1 : 0;l2 ? d2 >= 0 : d2 <= s2.length - 1; l2 ? d2-- : d2++)
      c2(d2);
    i2.globals.dom.elWrap.addEventListener("click", e2.onLegendClick, true), i2.config.legend.onItemHover.highlightDataSeries && i2.config.legend.customLegendItems.length === 0 && (i2.globals.dom.elWrap.addEventListener("mousemove", e2.onLegendHovered, true), i2.globals.dom.elWrap.addEventListener("mouseout", e2.onLegendHovered, true));
  } }, { key: "setLegendWrapXY", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.globals.dom.elLegendWrap, s2 = a2.clientHeight, r2 = 0, n2 = 0;
    if (i2.config.legend.position === "bottom")
      n2 = i2.globals.svgHeight - Math.min(s2, i2.globals.svgHeight / 2) - 5;
    else if (i2.config.legend.position === "top") {
      var o2 = new pa(this.ctx), l2 = o2.dimHelpers.getTitleSubtitleCoords("title").height, h2 = o2.dimHelpers.getTitleSubtitleCoords("subtitle").height;
      n2 = (l2 > 0 ? l2 - 10 : 0) + (h2 > 0 ? h2 - 10 : 0);
    }
    a2.style.position = "absolute", r2 = r2 + t3 + i2.config.legend.offsetX, n2 = n2 + e2 + i2.config.legend.offsetY, a2.style.left = r2 + "px", a2.style.top = n2 + "px", i2.config.legend.position === "right" && (a2.style.left = "auto", a2.style.right = 25 + i2.config.legend.offsetX + "px");
    ["width", "height"].forEach(function(t4) {
      a2.style[t4] && (a2.style[t4] = parseInt(i2.config.legend[t4], 10) + "px");
    });
  } }, { key: "legendAlignHorizontal", value: function() {
    var t3 = this.w;
    t3.globals.dom.elLegendWrap.style.right = 0;
    var e2 = new pa(this.ctx), i2 = e2.dimHelpers.getTitleSubtitleCoords("title"), a2 = e2.dimHelpers.getTitleSubtitleCoords("subtitle"), s2 = 0;
    t3.config.legend.position === "top" && (s2 = i2.height + a2.height + t3.config.title.margin + t3.config.subtitle.margin - 10), this.setLegendWrapXY(20, s2);
  } }, { key: "legendAlignVertical", value: function() {
    var t3 = this.w, e2 = this.legendHelpers.getLegendDimensions(), i2 = 0;
    t3.config.legend.position === "left" && (i2 = 20), t3.config.legend.position === "right" && (i2 = t3.globals.svgWidth - e2.clww - 10), this.setLegendWrapXY(i2, 20);
  } }, { key: "onLegendHovered", value: function(t3) {
    var e2 = this.w, i2 = t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker");
    if (e2.config.chart.type === "heatmap" || this.isBarsDistributed) {
      if (i2) {
        var a2 = parseInt(t3.target.getAttribute("rel"), 10) - 1;
        this.ctx.events.fireEvent("legendHover", [this.ctx, a2, this.w]), new Zi(this.ctx).highlightRangeInSeries(t3, t3.target);
      }
    } else
      !t3.target.classList.contains("apexcharts-inactive-legend") && i2 && new Zi(this.ctx).toggleSeriesOnHover(t3, t3.target);
  } }, { key: "onLegendClick", value: function(t3) {
    var e2 = this.w;
    if (!e2.config.legend.customLegendItems.length && (t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker"))) {
      var i2 = parseInt(t3.target.getAttribute("rel"), 10) - 1, a2 = t3.target.getAttribute("data:collapsed") === "true", s2 = this.w.config.chart.events.legendClick;
      typeof s2 == "function" && s2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i2, this.w]);
      var r2 = this.w.config.legend.markers.onClick;
      typeof r2 == "function" && t3.target.classList.contains("apexcharts-legend-marker") && (r2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i2, this.w])), e2.config.chart.type !== "treemap" && e2.config.chart.type !== "heatmap" && !this.isBarsDistributed && e2.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i2, a2);
    }
  } }]), t2;
}();
var ba = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = a2.globals.minX, this.maxX = a2.globals.maxX;
  }
  return s(t2, [{ key: "createToolbar", value: function() {
    var t3 = this, e2 = this.w, i2 = function() {
      return document.createElement("div");
    }, a2 = i2();
    if (a2.setAttribute("class", "apexcharts-toolbar"), a2.style.top = e2.config.chart.toolbar.offsetY + "px", a2.style.right = 3 - e2.config.chart.toolbar.offsetX + "px", e2.globals.dom.elWrap.appendChild(a2), this.elZoom = i2(), this.elZoomIn = i2(), this.elZoomOut = i2(), this.elPan = i2(), this.elSelection = i2(), this.elZoomReset = i2(), this.elMenuIcon = i2(), this.elMenu = i2(), this.elCustomIcons = [], this.t = e2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
      for (var s2 = 0;s2 < this.t.customIcons.length; s2++)
        this.elCustomIcons.push(i2());
    var r2 = [], n2 = function(i3, a3, s3) {
      var n3 = i3.toLowerCase();
      t3.t[n3] && e2.config.chart.zoom.enabled && r2.push({ el: a3, icon: typeof t3.t[n3] == "string" ? t3.t[n3] : s3, title: t3.localeValues[i3], class: "apexcharts-".concat(n3, "-icon") });
    };
    n2("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), n2("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
    var o2 = function(i3) {
      t3.t[i3] && e2.config.chart[i3].enabled && r2.push({ el: i3 === "zoom" ? t3.elZoom : t3.elSelection, icon: typeof t3.t[i3] == "string" ? t3.t[i3] : i3 === "zoom" ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t3.localeValues[i3 === "zoom" ? "selectionZoom" : "selection"], class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i3, "-icon") });
    };
    o2("zoom"), o2("selection"), this.t.pan && e2.config.chart.zoom.enabled && r2.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), n2("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r2.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
    for (var l2 = 0;l2 < this.elCustomIcons.length; l2++)
      r2.push({ el: this.elCustomIcons[l2], icon: this.t.customIcons[l2].icon, title: this.t.customIcons[l2].title, index: this.t.customIcons[l2].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l2].class });
    r2.forEach(function(t4, e3) {
      t4.index && v.moveIndexInArray(r2, e3, t4.index);
    });
    for (var h2 = 0;h2 < r2.length; h2++)
      Mi.setAttrs(r2[h2].el, { class: r2[h2].class, title: r2[h2].title }), r2[h2].el.innerHTML = r2[h2].icon, a2.appendChild(r2[h2].el);
    this._createHamburgerMenu(a2), e2.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e2.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e2.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
  } }, { key: "_createHamburgerMenu", value: function(t3) {
    this.elMenuItems = [], t3.appendChild(this.elMenu), Mi.setAttrs(this.elMenu, { class: "apexcharts-menu" });
    for (var e2 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i2 = 0;i2 < e2.length; i2++)
      this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i2].innerHTML = e2[i2].title, Mi.setAttrs(this.elMenuItems[i2], { class: "apexcharts-menu-item ".concat(e2[i2].name), title: e2[i2].title }), this.elMenu.appendChild(this.elMenuItems[i2]);
  } }, { key: "addToolbarEventListeners", value: function() {
    var t3 = this;
    this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e3) {
      e3.classList.contains("exportSVG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "svg")) : e3.classList.contains("exportPNG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "png")) : e3.classList.contains("exportCSV") && e3.addEventListener("click", t3.handleDownload.bind(t3, "csv"));
    });
    for (var e2 = 0;e2 < this.t.customIcons.length; e2++)
      this.elCustomIcons[e2].addEventListener("click", this.t.customIcons[e2].click.bind(this, this.ctx, this.ctx.w));
  } }, { key: "toggleZoomSelection", value: function(t3) {
    this.ctx.getSyncedCharts().forEach(function(e2) {
      e2.ctx.toolbar.toggleOtherControls();
      var i2 = t3 === "selection" ? e2.ctx.toolbar.elSelection : e2.ctx.toolbar.elZoom, a2 = t3 === "selection" ? "selectionEnabled" : "zoomEnabled";
      e2.w.globals[a2] = !e2.w.globals[a2], i2.classList.contains(e2.ctx.toolbar.selectedClass) ? i2.classList.remove(e2.ctx.toolbar.selectedClass) : i2.classList.add(e2.ctx.toolbar.selectedClass);
    });
  } }, { key: "getToolbarIconsReference", value: function() {
    var t3 = this.w;
    this.elZoom || (this.elZoom = t3.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t3.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t3.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
  } }, { key: "enableZoomPanFromToolbar", value: function(t3) {
    this.toggleOtherControls(), t3 === "pan" ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
    var e2 = t3 === "pan" ? this.elPan : this.elZoom, i2 = t3 === "pan" ? this.elZoom : this.elPan;
    e2 && e2.classList.add(this.selectedClass), i2 && i2.classList.remove(this.selectedClass);
  } }, { key: "togglePanning", value: function() {
    this.ctx.getSyncedCharts().forEach(function(t3) {
      t3.ctx.toolbar.toggleOtherControls(), t3.w.globals.panEnabled = !t3.w.globals.panEnabled, t3.ctx.toolbar.elPan.classList.contains(t3.ctx.toolbar.selectedClass) ? t3.ctx.toolbar.elPan.classList.remove(t3.ctx.toolbar.selectedClass) : t3.ctx.toolbar.elPan.classList.add(t3.ctx.toolbar.selectedClass);
    });
  } }, { key: "toggleOtherControls", value: function() {
    var t3 = this, e2 = this.w;
    e2.globals.panEnabled = false, e2.globals.zoomEnabled = false, e2.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e3) {
      e3 && e3.classList.remove(t3.selectedClass);
    });
  } }, { key: "handleZoomIn", value: function() {
    var t3 = this.w;
    t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY);
    var e2 = (this.minX + this.maxX) / 2, i2 = (this.minX + e2) / 2, a2 = (this.maxX + e2) / 2, s2 = this._getNewMinXMaxX(i2, a2);
    t3.globals.disableZoomIn || this.zoomUpdateOptions(s2.minX, s2.maxX);
  } }, { key: "handleZoomOut", value: function() {
    var t3 = this.w;
    if (t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY), !(t3.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1000)) {
      var e2 = (this.minX + this.maxX) / 2, i2 = this.minX - (e2 - this.minX), a2 = this.maxX - (e2 - this.maxX), s2 = this._getNewMinXMaxX(i2, a2);
      t3.globals.disableZoomOut || this.zoomUpdateOptions(s2.minX, s2.maxX);
    }
  } }, { key: "_getNewMinXMaxX", value: function(t3, e2) {
    var i2 = this.w.config.xaxis.convertedCatToNumeric;
    return { minX: i2 ? Math.floor(t3) : t3, maxX: i2 ? Math.floor(e2) : e2 };
  } }, { key: "zoomUpdateOptions", value: function(t3, e2) {
    var i2 = this.w;
    if (t3 !== undefined || e2 !== undefined) {
      if (!(i2.config.xaxis.convertedCatToNumeric && (t3 < 1 && (t3 = 1, e2 = i2.globals.dataPoints), e2 - t3 < 2))) {
        var a2 = { min: t3, max: e2 }, s2 = this.getBeforeZoomRange(a2);
        s2 && (a2 = s2.xaxis);
        var r2 = { xaxis: a2 }, n2 = v.clone(i2.globals.initialConfig.yaxis);
        i2.config.chart.group || (r2.yaxis = n2), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r2, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a2, n2);
      }
    } else
      this.handleZoomReset();
  } }, { key: "zoomCallback", value: function(t3, e2) {
    typeof this.ev.zoomed == "function" && this.ev.zoomed(this.ctx, { xaxis: t3, yaxis: e2 });
  } }, { key: "getBeforeZoomRange", value: function(t3, e2) {
    var i2 = null;
    return typeof this.ev.beforeZoom == "function" && (i2 = this.ev.beforeZoom(this, { xaxis: t3, yaxis: e2 })), i2;
  } }, { key: "toggleMenu", value: function() {
    var t3 = this;
    window.setTimeout(function() {
      t3.elMenu.classList.contains("apexcharts-menu-open") ? t3.elMenu.classList.remove("apexcharts-menu-open") : t3.elMenu.classList.add("apexcharts-menu-open");
    }, 0);
  } }, { key: "handleDownload", value: function(t3) {
    var e2 = this.w, i2 = new Ji(this.ctx);
    switch (t3) {
      case "svg":
        i2.exportToSVG(this.ctx);
        break;
      case "png":
        i2.exportToPng(this.ctx);
        break;
      case "csv":
        i2.exportToCSV({ series: e2.config.series, columnDelimiter: e2.config.chart.toolbar.export.csv.columnDelimiter });
    }
  } }, { key: "handleZoomReset", value: function(t3) {
    this.ctx.getSyncedCharts().forEach(function(t4) {
      var e2 = t4.w;
      if (e2.globals.lastXAxis.min = e2.globals.initialConfig.xaxis.min, e2.globals.lastXAxis.max = e2.globals.initialConfig.xaxis.max, t4.updateHelpers.revertDefaultAxisMinMax(), typeof e2.config.chart.events.beforeResetZoom == "function") {
        var i2 = e2.config.chart.events.beforeResetZoom(t4, e2);
        i2 && t4.updateHelpers.revertDefaultAxisMinMax(i2);
      }
      typeof e2.config.chart.events.zoomed == "function" && t4.ctx.toolbar.zoomCallback({ min: e2.config.xaxis.min, max: e2.config.xaxis.max }), e2.globals.zoomed = false;
      var a2 = t4.ctx.series.emptyCollapsedSeries(v.clone(e2.globals.initialSeries));
      t4.updateHelpers._updateSeries(a2, e2.config.chart.animations.dynamicAnimation.enabled);
    });
  } }, { key: "destroy", value: function() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  } }]), t2;
}();
var ma = function(t2) {
  h(a2, ba);
  var e2 = n(a2);
  function a2(t3) {
    var s2;
    return i(this, a2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.dragged = false, s2.graphics = new Mi(s2.ctx), s2.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend", "wheel"], s2.clientX = 0, s2.clientY = 0, s2.startX = 0, s2.endX = 0, s2.dragX = 0, s2.startY = 0, s2.endY = 0, s2.dragY = 0, s2.moveDirection = "none", s2.debounceTimer = null, s2.debounceDelay = 100, s2.wheelDelay = 400, s2;
  }
  return s(a2, [{ key: "init", value: function(t3) {
    var e3 = this, i2 = t3.xyRatios, a3 = this.w, s2 = this;
    this.xyRatios = i2, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a3.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.constraints = new kt(0, 0, a3.globals.gridWidth, a3.globals.gridHeight), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a3.globals.dom.Paper.add(this.zoomRect), a3.globals.dom.Paper.add(this.selectionRect), a3.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a3.globals.gridWidth, maxY: a3.globals.gridHeight }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : a3.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a3.globals.gridWidth }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a3.globals.dom.baseEl.querySelector("".concat(a3.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t4) {
      e3.hoverArea.addEventListener(t4, s2.svgMouseEvents.bind(s2, i2), { capture: false, passive: true });
    }), a3.config.chart.zoom.enabled && a3.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", s2.mouseWheelEvent.bind(s2), { capture: false, passive: false });
  } }, { key: "destroy", value: function() {
    this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  } }, { key: "svgMouseEvents", value: function(t3, e3) {
    var i2 = this.w, a3 = this.ctx.toolbar, s2 = i2.globals.zoomEnabled ? i2.config.chart.zoom.type : i2.config.chart.selection.type, r2 = i2.config.chart.toolbar.autoSelected;
    if (e3.shiftKey ? (this.shiftWasPressed = true, a3.enableZoomPanFromToolbar(r2 === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (a3.enableZoomPanFromToolbar(r2), this.shiftWasPressed = false), e3.target) {
      var n2, o2 = e3.target.classList;
      if (e3.target.parentNode && e3.target.parentNode !== null && (n2 = e3.target.parentNode.classList), !(o2.contains("apexcharts-legend-marker") || o2.contains("apexcharts-legend-text") || n2 && n2.contains("apexcharts-toolbar"))) {
        if (this.clientX = e3.type === "touchmove" || e3.type === "touchstart" ? e3.touches[0].clientX : e3.type === "touchend" ? e3.changedTouches[0].clientX : e3.clientX, this.clientY = e3.type === "touchmove" || e3.type === "touchstart" ? e3.touches[0].clientY : e3.type === "touchend" ? e3.changedTouches[0].clientY : e3.clientY, e3.type === "mousedown" && e3.which === 1 || e3.type === "touchstart") {
          var l2 = this.gridRect.getBoundingClientRect();
          this.startX = this.clientX - l2.left - i2.globals.barPadForNumericAxis, this.startY = this.clientY - l2.top, this.dragged = false, this.w.globals.mousedown = true;
        }
        (e3.type === "mousemove" && e3.which === 1 || e3.type === "touchmove") && (this.dragged = true, i2.globals.panEnabled ? (i2.globals.selection = null, this.w.globals.mousedown && this.panDragging({ context: this, zoomtype: s2, xyRatios: t3 })) : (this.w.globals.mousedown && i2.globals.zoomEnabled || this.w.globals.mousedown && i2.globals.selectionEnabled) && (this.selection = this.selectionDrawing({ context: this, zoomtype: s2 }))), e3.type !== "mouseup" && e3.type !== "touchend" && e3.type !== "mouseleave" || this.handleMouseUp({ zoomtype: s2 }), this.makeSelectionRectDraggable();
      }
    }
  } }, { key: "handleMouseUp", value: function(t3) {
    var e3, i2 = t3.zoomtype, a3 = t3.isResized, s2 = this.w, r2 = (e3 = this.gridRect) === null || e3 === undefined ? undefined : e3.getBoundingClientRect();
    r2 && (this.w.globals.mousedown || a3) && (this.endX = this.clientX - r2.left - s2.globals.barPadForNumericAxis, this.endY = this.clientY - r2.top, this.dragX = Math.abs(this.endX - this.startX), this.dragY = Math.abs(this.endY - this.startY), (s2.globals.zoomEnabled || s2.globals.selectionEnabled) && this.selectionDrawn({ context: this, zoomtype: i2 }), s2.globals.panEnabled && s2.config.xaxis.convertedCatToNumeric && this.delayedPanScrolled()), s2.globals.zoomEnabled && this.hideSelectionRect(this.selectionRect), this.dragged = false, this.w.globals.mousedown = false;
  } }, { key: "mouseWheelEvent", value: function(t3) {
    var e3 = this, i2 = this.w;
    t3.preventDefault();
    var a3 = Date.now();
    a3 - i2.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(t3), i2.globals.lastWheelExecution = a3), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(function() {
      a3 - i2.globals.lastWheelExecution > e3.wheelDelay && (e3.executeMouseWheelZoom(t3), i2.globals.lastWheelExecution = a3);
    }, this.debounceDelay);
  } }, { key: "executeMouseWheelZoom", value: function(t3) {
    var e3, i2 = this.w;
    this.minX = i2.globals.isRangeBar ? i2.globals.minY : i2.globals.minX, this.maxX = i2.globals.isRangeBar ? i2.globals.maxY : i2.globals.maxX;
    var a3 = (e3 = this.gridRect) === null || e3 === undefined ? undefined : e3.getBoundingClientRect();
    if (a3) {
      var s2, r2, n2, o2 = (t3.clientX - a3.left) / a3.width, l2 = this.minX, h2 = this.maxX, c2 = h2 - l2;
      if (t3.deltaY < 0) {
        var d2 = l2 + o2 * c2;
        r2 = d2 - (s2 = 0.5 * c2) / 2, n2 = d2 + s2 / 2;
      } else
        r2 = l2 - (s2 = 1.5 * c2) / 2, n2 = h2 + s2 / 2;
      if (!i2.globals.isRangeBar) {
        r2 = Math.max(r2, i2.globals.initialMinX), n2 = Math.min(n2, i2.globals.initialMaxX);
        var u2 = 0.01 * (i2.globals.initialMaxX - i2.globals.initialMinX);
        if (n2 - r2 < u2) {
          var g2 = (r2 + n2) / 2;
          r2 = g2 - u2 / 2, n2 = g2 + u2 / 2;
        }
      }
      var p2 = this._getNewMinXMaxX(r2, n2);
      isNaN(p2.minX) || isNaN(p2.maxX) || this.zoomUpdateOptions(p2.minX, p2.maxX);
    }
  } }, { key: "makeSelectionRectDraggable", value: function() {
    var t3 = this, e3 = this.w;
    if (this.selectionRect) {
      var i2 = this.selectionRect.node.getBoundingClientRect();
      i2.width > 0 && i2.height > 0 && (this.selectionRect.select(false).resize(false), this.selectionRect.select({ createRot: function() {
      }, updateRot: function() {
      }, createHandle: function(t4, e4, i3, a3, s2) {
        return s2 === "l" || s2 === "r" ? t4.circle(8).css({ "stroke-width": 1, stroke: "#333", fill: "#fff" }) : t4.circle(0);
      }, updateHandle: function(t4, e4) {
        return t4.center(e4[0], e4[1]);
      } }).resize().on("resize", function() {
        var i3 = e3.globals.zoomEnabled ? e3.config.chart.zoom.type : e3.config.chart.selection.type;
        t3.handleMouseUp({ zoomtype: i3, isResized: true });
      }));
    }
  } }, { key: "preselectedSelection", value: function() {
    var t3 = this.w, e3 = this.xyRatios;
    if (!t3.globals.zoomEnabled) {
      if (t3.globals.selection !== undefined && t3.globals.selection !== null)
        this.drawSelectionRect(u(u({}, t3.globals.selection), {}, { translateX: t3.globals.translateX, translateY: t3.globals.translateY }));
      else if (t3.config.chart.selection.xaxis.min !== undefined && t3.config.chart.selection.xaxis.max !== undefined) {
        var i2 = (t3.config.chart.selection.xaxis.min - t3.globals.minX) / e3.xRatio, a3 = t3.globals.gridWidth - (t3.globals.maxX - t3.config.chart.selection.xaxis.max) / e3.xRatio - i2;
        t3.globals.isRangeBar && (i2 = (t3.config.chart.selection.xaxis.min - t3.globals.yAxisScale[0].niceMin) / e3.invertedYRatio, a3 = (t3.config.chart.selection.xaxis.max - t3.config.chart.selection.xaxis.min) / e3.invertedYRatio);
        var s2 = { x: i2, y: 0, width: a3, height: t3.globals.gridHeight, translateX: t3.globals.translateX, translateY: t3.globals.translateY, selectionEnabled: true };
        this.drawSelectionRect(s2), this.makeSelectionRectDraggable(), typeof t3.config.chart.events.selection == "function" && t3.config.chart.events.selection(this.ctx, { xaxis: { min: t3.config.chart.selection.xaxis.min, max: t3.config.chart.selection.xaxis.max }, yaxis: {} });
      }
    }
  } }, { key: "drawSelectionRect", value: function(t3) {
    var { x: e3, y: i2, width: a3, height: s2, translateX: r2 } = t3, n2 = r2 === undefined ? 0 : r2, o2 = t3.translateY, l2 = o2 === undefined ? 0 : o2, h2 = this.w, c2 = this.zoomRect, d2 = this.selectionRect;
    if (this.dragged || h2.globals.selection !== null) {
      var u2 = { transform: "translate(" + n2 + ", " + l2 + ")" };
      h2.globals.zoomEnabled && this.dragged && (a3 < 0 && (a3 = 1), c2.attr({ x: e3, y: i2, width: a3, height: s2, fill: h2.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h2.config.chart.zoom.zoomedArea.fill.opacity, stroke: h2.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h2.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h2.config.chart.zoom.zoomedArea.stroke.opacity }), Mi.setAttrs(c2.node, u2)), h2.globals.selectionEnabled && (d2.attr({ x: e3, y: i2, width: a3 > 0 ? a3 : 0, height: s2 > 0 ? s2 : 0, fill: h2.config.chart.selection.fill.color, "fill-opacity": h2.config.chart.selection.fill.opacity, stroke: h2.config.chart.selection.stroke.color, "stroke-width": h2.config.chart.selection.stroke.width, "stroke-dasharray": h2.config.chart.selection.stroke.dashArray, "stroke-opacity": h2.config.chart.selection.stroke.opacity }), Mi.setAttrs(d2.node, u2));
    }
  } }, { key: "hideSelectionRect", value: function(t3) {
    t3 && t3.attr({ x: 0, y: 0, width: 0, height: 0 });
  } }, { key: "selectionDrawing", value: function(t3) {
    var { context: e3, zoomtype: i2 } = t3, a3 = this.w, s2 = e3, r2 = this.gridRect.getBoundingClientRect(), n2 = s2.startX - 1, o2 = s2.startY, l2 = false, h2 = false, c2 = s2.clientX - r2.left - a3.globals.barPadForNumericAxis, d2 = s2.clientY - r2.top, g2 = c2 - n2, p2 = d2 - o2, f2 = { translateX: a3.globals.translateX, translateY: a3.globals.translateY };
    return Math.abs(g2 + n2) > a3.globals.gridWidth ? g2 = a3.globals.gridWidth - n2 : c2 < 0 && (g2 = n2), n2 > c2 && (l2 = true, g2 = Math.abs(g2)), o2 > d2 && (h2 = true, p2 = Math.abs(p2)), f2 = u(u({}, f2 = i2 === "x" ? { x: l2 ? n2 - g2 : n2, y: 0, width: g2, height: a3.globals.gridHeight } : i2 === "y" ? { x: 0, y: h2 ? o2 - p2 : o2, width: a3.globals.gridWidth, height: p2 } : { x: l2 ? n2 - g2 : n2, y: h2 ? o2 - p2 : o2, width: g2, height: p2 }), {}, { translateX: a3.globals.translateX, translateY: a3.globals.translateY }), s2.drawSelectionRect(f2), s2.selectionDragging("resizing"), f2;
  } }, { key: "selectionDragging", value: function(t3, e3) {
    var i2 = this, a3 = this.w;
    if (e3) {
      e3.preventDefault();
      var s2 = e3.detail, r2 = s2.handler, n2 = s2.box, o2 = n2.x, l2 = n2.y;
      o2 < this.constraints.x && (o2 = this.constraints.x), l2 < this.constraints.y && (l2 = this.constraints.y), n2.x2 > this.constraints.x2 && (o2 = this.constraints.x2 - n2.w), n2.y2 > this.constraints.y2 && (l2 = this.constraints.y2 - n2.h), r2.move(o2, l2);
      var h2 = this.xyRatios, c2 = this.selectionRect, d2 = 0;
      t3 === "resizing" && (d2 = 30);
      var u2 = function(t4) {
        return parseFloat(c2.node.getAttribute(t4));
      }, g2 = { x: u2("x"), y: u2("y"), width: u2("width"), height: u2("height") };
      a3.globals.selection = g2, typeof a3.config.chart.events.selection == "function" && a3.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var t4, e4, s3, r3, n3 = i2.gridRect.getBoundingClientRect(), o3 = c2.node.getBoundingClientRect();
        a3.globals.isRangeBar ? (t4 = a3.globals.yAxisScale[0].niceMin + (o3.left - n3.left) * h2.invertedYRatio, e4 = a3.globals.yAxisScale[0].niceMin + (o3.right - n3.left) * h2.invertedYRatio, s3 = 0, r3 = 1) : (t4 = a3.globals.xAxisScale.niceMin + (o3.left - n3.left) * h2.xRatio, e4 = a3.globals.xAxisScale.niceMin + (o3.right - n3.left) * h2.xRatio, s3 = a3.globals.yAxisScale[0].niceMin + (n3.bottom - o3.bottom) * h2.yRatio[0], r3 = a3.globals.yAxisScale[0].niceMax - (o3.top - n3.top) * h2.yRatio[0]);
        var l3 = { xaxis: { min: t4, max: e4 }, yaxis: { min: s3, max: r3 } };
        a3.config.chart.events.selection(i2.ctx, l3), a3.config.chart.brush.enabled && a3.config.chart.events.brushScrolled !== undefined && a3.config.chart.events.brushScrolled(i2.ctx, l3);
      }, d2));
    }
  } }, { key: "selectionDrawn", value: function(t3) {
    var e3, i2, a3 = t3.context, s2 = t3.zoomtype, r2 = this.w, n2 = a3, o2 = this.xyRatios, l2 = this.ctx.toolbar, h2 = r2.globals.zoomEnabled ? n2.zoomRect.node.getBoundingClientRect() : n2.selectionRect.node.getBoundingClientRect(), c2 = n2.gridRect.getBoundingClientRect(), d2 = h2.left - c2.left - r2.globals.barPadForNumericAxis, u2 = h2.right - c2.left - r2.globals.barPadForNumericAxis, g2 = h2.top - c2.top, p2 = h2.bottom - c2.top;
    r2.globals.isRangeBar ? (e3 = r2.globals.yAxisScale[0].niceMin + d2 * o2.invertedYRatio, i2 = r2.globals.yAxisScale[0].niceMin + u2 * o2.invertedYRatio) : (e3 = r2.globals.xAxisScale.niceMin + d2 * o2.xRatio, i2 = r2.globals.xAxisScale.niceMin + u2 * o2.xRatio);
    var f2 = [], x2 = [];
    if (r2.config.yaxis.forEach(function(t4, e4) {
      var i3 = r2.globals.seriesYAxisMap[e4][0], a4 = r2.globals.yAxisScale[e4].niceMax - o2.yRatio[i3] * g2, s3 = r2.globals.yAxisScale[e4].niceMax - o2.yRatio[i3] * p2;
      f2.push(a4), x2.push(s3);
    }), n2.dragged && (n2.dragX > 10 || n2.dragY > 10) && e3 !== i2) {
      if (r2.globals.zoomEnabled) {
        var b2 = v.clone(r2.globals.initialConfig.yaxis), m2 = v.clone(r2.globals.initialConfig.xaxis);
        if (r2.globals.zoomed = true, r2.config.xaxis.convertedCatToNumeric && (e3 = Math.floor(e3), i2 = Math.floor(i2), e3 < 1 && (e3 = 1, i2 = r2.globals.dataPoints), i2 - e3 < 2 && (i2 = e3 + 1)), s2 !== "xy" && s2 !== "x" || (m2 = { min: e3, max: i2 }), s2 !== "xy" && s2 !== "y" || b2.forEach(function(t4, e4) {
          b2[e4].min = x2[e4], b2[e4].max = f2[e4];
        }), l2) {
          var y2 = l2.getBeforeZoomRange(m2, b2);
          y2 && (m2 = y2.xaxis ? y2.xaxis : m2, b2 = y2.yaxis ? y2.yaxis : b2);
        }
        var w2 = { xaxis: m2 };
        r2.config.chart.group || (w2.yaxis = b2), n2.ctx.updateHelpers._updateOptions(w2, false, n2.w.config.chart.animations.dynamicAnimation.enabled), typeof r2.config.chart.events.zoomed == "function" && l2.zoomCallback(m2, b2);
      } else if (r2.globals.selectionEnabled) {
        var k2, A2 = null;
        k2 = { min: e3, max: i2 }, s2 !== "xy" && s2 !== "y" || (A2 = v.clone(r2.config.yaxis)).forEach(function(t4, e4) {
          A2[e4].min = x2[e4], A2[e4].max = f2[e4];
        }), r2.globals.selection = n2.selection, typeof r2.config.chart.events.selection == "function" && r2.config.chart.events.selection(n2.ctx, { xaxis: k2, yaxis: A2 });
      }
    }
  } }, { key: "panDragging", value: function(t3) {
    var e3 = t3.context, i2 = this.w, a3 = e3;
    if (i2.globals.lastClientPosition.x !== undefined) {
      var s2 = i2.globals.lastClientPosition.x - a3.clientX, r2 = i2.globals.lastClientPosition.y - a3.clientY;
      Math.abs(s2) > Math.abs(r2) && s2 > 0 ? this.moveDirection = "left" : Math.abs(s2) > Math.abs(r2) && s2 < 0 ? this.moveDirection = "right" : Math.abs(r2) > Math.abs(s2) && r2 > 0 ? this.moveDirection = "up" : Math.abs(r2) > Math.abs(s2) && r2 < 0 && (this.moveDirection = "down");
    }
    i2.globals.lastClientPosition = { x: a3.clientX, y: a3.clientY };
    var n2 = i2.globals.isRangeBar ? i2.globals.minY : i2.globals.minX, o2 = i2.globals.isRangeBar ? i2.globals.maxY : i2.globals.maxX;
    i2.config.xaxis.convertedCatToNumeric || a3.panScrolled(n2, o2);
  } }, { key: "delayedPanScrolled", value: function() {
    var t3 = this.w, e3 = t3.globals.minX, i2 = t3.globals.maxX, a3 = (t3.globals.maxX - t3.globals.minX) / 2;
    this.moveDirection === "left" ? (e3 = t3.globals.minX + a3, i2 = t3.globals.maxX + a3) : this.moveDirection === "right" && (e3 = t3.globals.minX - a3, i2 = t3.globals.maxX - a3), e3 = Math.floor(e3), i2 = Math.floor(i2), this.updateScrolledChart({ xaxis: { min: e3, max: i2 } }, e3, i2);
  } }, { key: "panScrolled", value: function(t3, e3) {
    var i2 = this.w, a3 = this.xyRatios, s2 = v.clone(i2.globals.initialConfig.yaxis), r2 = a3.xRatio, n2 = i2.globals.minX, o2 = i2.globals.maxX;
    i2.globals.isRangeBar && (r2 = a3.invertedYRatio, n2 = i2.globals.minY, o2 = i2.globals.maxY), this.moveDirection === "left" ? (t3 = n2 + i2.globals.gridWidth / 15 * r2, e3 = o2 + i2.globals.gridWidth / 15 * r2) : this.moveDirection === "right" && (t3 = n2 - i2.globals.gridWidth / 15 * r2, e3 = o2 - i2.globals.gridWidth / 15 * r2), i2.globals.isRangeBar || (t3 < i2.globals.initialMinX || e3 > i2.globals.initialMaxX) && (t3 = n2, e3 = o2);
    var l2 = { xaxis: { min: t3, max: e3 } };
    i2.config.chart.group || (l2.yaxis = s2), this.updateScrolledChart(l2, t3, e3);
  } }, { key: "updateScrolledChart", value: function(t3, e3, i2) {
    var a3 = this.w;
    this.ctx.updateHelpers._updateOptions(t3, false, false), typeof a3.config.chart.events.scrolled == "function" && a3.config.chart.events.scrolled(this.ctx, { xaxis: { min: e3, max: i2 } });
  } }]), a2;
}();
var va = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx;
  }
  return s(t2, [{ key: "getNearestValues", value: function(t3) {
    var { hoverArea: e2, elGrid: i2, clientX: a2, clientY: s2 } = t3, r2 = this.w, n2 = i2.getBoundingClientRect(), o2 = n2.width, l2 = n2.height, h2 = o2 / (r2.globals.dataPoints - 1), c2 = l2 / r2.globals.dataPoints, d2 = this.hasBars();
    !r2.globals.comboCharts && !d2 || r2.config.xaxis.convertedCatToNumeric || (h2 = o2 / r2.globals.dataPoints);
    var u2 = a2 - n2.left - r2.globals.barPadForNumericAxis, g2 = s2 - n2.top;
    u2 < 0 || g2 < 0 || u2 > o2 || g2 > l2 ? (e2.classList.remove("hovering-zoom"), e2.classList.remove("hovering-pan")) : r2.globals.zoomEnabled ? (e2.classList.remove("hovering-pan"), e2.classList.add("hovering-zoom")) : r2.globals.panEnabled && (e2.classList.remove("hovering-zoom"), e2.classList.add("hovering-pan"));
    var p2 = Math.round(u2 / h2), f2 = Math.floor(g2 / c2);
    d2 && !r2.config.xaxis.convertedCatToNumeric && (p2 = Math.ceil(u2 / h2), p2 -= 1);
    var x2 = null, b2 = null, m2 = r2.globals.seriesXvalues.map(function(t4) {
      return t4.filter(function(t5) {
        return v.isNumber(t5);
      });
    }), y2 = r2.globals.seriesYvalues.map(function(t4) {
      return t4.filter(function(t5) {
        return v.isNumber(t5);
      });
    });
    if (r2.globals.isXNumeric) {
      var w2 = this.ttCtx.getElGrid().getBoundingClientRect(), k2 = u2 * (w2.width / o2), A2 = g2 * (w2.height / l2);
      x2 = (b2 = this.closestInMultiArray(k2, A2, m2, y2)).index, p2 = b2.j, x2 !== null && r2.globals.hasNullValues && (m2 = r2.globals.seriesXvalues[x2], p2 = (b2 = this.closestInArray(k2, m2)).j);
    }
    return r2.globals.capturedSeriesIndex = x2 === null ? -1 : x2, (!p2 || p2 < 1) && (p2 = 0), r2.globals.isBarHorizontal ? r2.globals.capturedDataPointIndex = f2 : r2.globals.capturedDataPointIndex = p2, { capturedSeries: x2, j: r2.globals.isBarHorizontal ? f2 : p2, hoverX: u2, hoverY: g2 };
  } }, { key: "getFirstActiveXArray", value: function(t3) {
    for (var e2 = this.w, i2 = 0, a2 = t3.map(function(t4, e3) {
      return t4.length > 0 ? e3 : -1;
    }), s2 = 0;s2 < a2.length; s2++)
      if (a2[s2] !== -1 && e2.globals.collapsedSeriesIndices.indexOf(s2) === -1 && e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2) === -1) {
        i2 = a2[s2];
        break;
      }
    return i2;
  } }, { key: "closestInMultiArray", value: function(t3, e2, i2, a2) {
    for (var s2, r2 = this.w, n2 = 1 / 0, o2 = null, l2 = null, h2 = 0;h2 < i2.length; h2++)
      if (s2 = h2, r2.globals.collapsedSeriesIndices.indexOf(s2) === -1 && r2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2) === -1)
        for (var c2 = i2[h2], d2 = a2[h2], u2 = Math.min(c2.length, d2.length), g2 = 0;g2 < u2; g2++) {
          var p2 = t3 - c2[g2], f2 = Math.sqrt(p2 * p2);
          if (!r2.globals.allSeriesHasEqualX) {
            var x2 = e2 - d2[g2];
            f2 = Math.sqrt(p2 * p2 + x2 * x2);
          }
          f2 < n2 && (n2 = f2, o2 = h2, l2 = g2);
        }
    return { index: o2, j: l2 };
  } }, { key: "closestInArray", value: function(t3, e2) {
    for (var i2 = e2[0], a2 = null, s2 = Math.abs(t3 - i2), r2 = 0;r2 < e2.length; r2++) {
      var n2 = Math.abs(t3 - e2[r2]);
      n2 < s2 && (s2 = n2, a2 = r2);
    }
    return { j: a2 };
  } }, { key: "isXoverlap", value: function(t3) {
    var e2 = [], i2 = this.w.globals.seriesX.filter(function(t4) {
      return t4[0] !== undefined;
    });
    if (i2.length > 0)
      for (var a2 = 0;a2 < i2.length - 1; a2++)
        i2[a2][t3] !== undefined && i2[a2 + 1][t3] !== undefined && i2[a2][t3] !== i2[a2 + 1][t3] && e2.push("unEqual");
    return e2.length === 0;
  } }, { key: "isInitialSeriesSameLen", value: function() {
    for (var t3 = true, e2 = this.w.globals.initialSeries, i2 = 0;i2 < e2.length - 1; i2++)
      if (e2[i2].data.length !== e2[i2 + 1].data.length) {
        t3 = false;
        break;
      }
    return t3;
  } }, { key: "getBarsHeight", value: function(t3) {
    return f(t3).reduce(function(t4, e2) {
      return t4 + e2.getBBox().height;
    }, 0);
  } }, { key: "getElMarkers", value: function(t3) {
    return typeof t3 == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
  } }, { key: "getAllMarkers", value: function() {
    var t3 = this, e2 = arguments.length > 0 && arguments[0] !== undefined && arguments[0], i2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
    i2 = f(i2), e2 && (i2 = i2.filter(function(e3) {
      var i3 = Number(e3.getAttribute("data:realIndex"));
      return t3.w.globals.collapsedSeriesIndices.indexOf(i3) === -1;
    })), i2.sort(function(t4, e3) {
      var i3 = Number(t4.getAttribute("data:realIndex")), a3 = Number(e3.getAttribute("data:realIndex"));
      return a3 < i3 ? 1 : a3 > i3 ? -1 : 0;
    });
    var a2 = [];
    return i2.forEach(function(t4) {
      a2.push(t4.querySelector(".apexcharts-marker"));
    }), a2;
  } }, { key: "hasMarkers", value: function(t3) {
    return this.getElMarkers(t3).length > 0;
  } }, { key: "getPathFromPoint", value: function(t3, e2) {
    var i2 = Number(t3.getAttribute("cx")), a2 = Number(t3.getAttribute("cy")), s2 = t3.getAttribute("shape");
    return new Mi(this.ctx).getMarkerPath(i2, a2, s2, e2);
  } }, { key: "getElBars", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
  } }, { key: "hasBars", value: function() {
    return this.getElBars().length > 0;
  } }, { key: "getHoverMarkerSize", value: function(t3) {
    var e2 = this.w, i2 = e2.config.markers.hover.size;
    return i2 === undefined && (i2 = e2.globals.markers.size[t3] + e2.config.markers.hover.sizeOffset), i2;
  } }, { key: "toggleAllTooltipSeriesGroups", value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    i2.allTooltipSeriesGroups.length === 0 && (i2.allTooltipSeriesGroups = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
    for (var a2 = i2.allTooltipSeriesGroups, s2 = 0;s2 < a2.length; s2++)
      t3 === "enable" ? (a2[s2].classList.add("apexcharts-active"), a2[s2].style.display = e2.config.tooltip.items.display) : (a2[s2].classList.remove("apexcharts-active"), a2[s2].style.display = "none");
  } }]), t2;
}();
var ya = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ctx = e2.ctx, this.ttCtx = e2, this.tooltipUtil = new va(e2);
  }
  return s(t2, [{ key: "drawSeriesTexts", value: function(t3) {
    var e2 = t3.shared, i2 = e2 === undefined || e2, a2 = t3.ttItems, s2 = t3.i, r2 = s2 === undefined ? 0 : s2, n2 = t3.j, o2 = n2 === undefined ? null : n2, l2 = t3.y1, h2 = t3.y2, c2 = t3.e, d2 = this.w;
    d2.config.tooltip.custom !== undefined ? this.handleCustomTooltip({ i: r2, j: o2, y1: l2, y2: h2, w: d2 }) : this.toggleActiveInactiveSeries(i2, r2);
    var u2 = this.getValuesToPrint({ i: r2, j: o2 });
    this.printLabels({ i: r2, j: o2, values: u2, ttItems: a2, shared: i2, e: c2 });
    var g2 = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = g2.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = g2.getBoundingClientRect().height;
  } }, { key: "printLabels", value: function(t3) {
    var e2, i2 = this, a2 = t3.i, s2 = t3.j, r2 = t3.values, n2 = t3.ttItems, o2 = t3.shared, l2 = t3.e, h2 = this.w, c2 = [], d2 = function(t4) {
      return h2.globals.seriesGoals[t4] && h2.globals.seriesGoals[t4][s2] && Array.isArray(h2.globals.seriesGoals[t4][s2]);
    }, g2 = r2.xVal, p2 = r2.zVal, f2 = r2.xAxisTTVal, x2 = "", b2 = h2.globals.colors[a2];
    s2 !== null && h2.config.plotOptions.bar.distributed && (b2 = h2.globals.colors[s2]);
    for (var m2 = function(t4, r3) {
      var m3 = i2.getFormatters(a2);
      x2 = i2.getSeriesName({ fn: m3.yLbTitleFormatter, index: a2, seriesIndex: a2, j: s2 }), h2.config.chart.type === "treemap" && (x2 = m3.yLbTitleFormatter(String(h2.config.series[a2].data[s2].x), { series: h2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: h2 }));
      var v3 = h2.config.tooltip.inverseOrder ? r3 : t4;
      if (h2.globals.axisCharts) {
        var y3 = function(t5) {
          var e3, i3, a3, r4;
          return h2.globals.isRangeData ? m3.yLbFormatter((e3 = h2.globals.seriesRangeStart) === null || e3 === undefined || (i3 = e3[t5]) === null || i3 === undefined ? undefined : i3[s2], { series: h2.globals.seriesRangeStart, seriesIndex: t5, dataPointIndex: s2, w: h2 }) + " - " + m3.yLbFormatter((a3 = h2.globals.seriesRangeEnd) === null || a3 === undefined || (r4 = a3[t5]) === null || r4 === undefined ? undefined : r4[s2], { series: h2.globals.seriesRangeEnd, seriesIndex: t5, dataPointIndex: s2, w: h2 }) : m3.yLbFormatter(h2.globals.series[t5][s2], { series: h2.globals.series, seriesIndex: t5, dataPointIndex: s2, w: h2 });
        };
        if (o2)
          m3 = i2.getFormatters(v3), x2 = i2.getSeriesName({ fn: m3.yLbTitleFormatter, index: v3, seriesIndex: a2, j: s2 }), b2 = h2.globals.colors[v3], e2 = y3(v3), d2(v3) && (c2 = h2.globals.seriesGoals[v3][s2].map(function(t5) {
            return { attrs: t5, val: m3.yLbFormatter(t5.value, { seriesIndex: v3, dataPointIndex: s2, w: h2 }) };
          }));
        else {
          var w2, k2 = l2 == null || (w2 = l2.target) === null || w2 === undefined ? undefined : w2.getAttribute("fill");
          k2 && (k2.indexOf("url") !== -1 ? k2.indexOf("Pattern") !== -1 && (b2 = h2.globals.dom.baseEl.querySelector(k2.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke")) : b2 = k2), e2 = y3(a2), d2(a2) && Array.isArray(h2.globals.seriesGoals[a2][s2]) && (c2 = h2.globals.seriesGoals[a2][s2].map(function(t5) {
            return { attrs: t5, val: m3.yLbFormatter(t5.value, { seriesIndex: a2, dataPointIndex: s2, w: h2 }) };
          }));
        }
      }
      s2 === null && (e2 = m3.yLbFormatter(h2.globals.series[a2], u(u({}, h2), {}, { seriesIndex: a2, dataPointIndex: a2 }))), i2.DOMHandling({ i: a2, t: v3, j: s2, ttItems: n2, values: { val: e2, goalVals: c2, xVal: g2, xAxisTTVal: f2, zVal: p2 }, seriesName: x2, shared: o2, pColor: b2 });
    }, v2 = 0, y2 = h2.globals.series.length - 1;v2 < h2.globals.series.length; v2++, y2--)
      m2(v2, y2);
  } }, { key: "getFormatters", value: function(t3) {
    var e2, i2 = this.w, a2 = i2.globals.yLabelFormatters[t3];
    return i2.globals.ttVal !== undefined ? Array.isArray(i2.globals.ttVal) ? (a2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].formatter, e2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].title && i2.globals.ttVal[t3].title.formatter) : (a2 = i2.globals.ttVal.formatter, typeof i2.globals.ttVal.title.formatter == "function" && (e2 = i2.globals.ttVal.title.formatter)) : e2 = i2.config.tooltip.y.title.formatter, typeof a2 != "function" && (a2 = i2.globals.yLabelFormatters[0] ? i2.globals.yLabelFormatters[0] : function(t4) {
      return t4;
    }), typeof e2 != "function" && (e2 = function(t4) {
      return t4 ? t4 + ": " : "";
    }), { yLbFormatter: a2, yLbTitleFormatter: e2 };
  } }, { key: "getSeriesName", value: function(t3) {
    var { fn: e2, index: i2, seriesIndex: a2, j: s2 } = t3, r2 = this.w;
    return e2(String(r2.globals.seriesNames[i2]), { series: r2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: r2 });
  } }, { key: "DOMHandling", value: function(t3) {
    t3.i;
    var { t: e2, j: i2, ttItems: a2, values: s2, seriesName: r2, shared: n2, pColor: o2 } = t3, l2 = this.w, h2 = this.ttCtx, c2 = s2.val, d2 = s2.goalVals, u2 = s2.xVal, g2 = s2.xAxisTTVal, p2 = s2.zVal, f2 = null;
    f2 = a2[e2].children, l2.config.tooltip.fillSeriesColor && (a2[e2].style.backgroundColor = o2, f2[0].style.display = "none"), h2.showTooltipTitle && (h2.tooltipTitle === null && (h2.tooltipTitle = l2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h2.tooltipTitle.innerHTML = u2), h2.isXAxisTooltipEnabled && (h2.xaxisTooltipText.innerHTML = g2 !== "" ? g2 : u2);
    var x2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-label");
    x2 && (x2.innerHTML = r2 || "");
    var b2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-value");
    b2 && (b2.innerHTML = c2 !== undefined ? c2 : ""), f2[0] && f2[0].classList.contains("apexcharts-tooltip-marker") && (l2.config.tooltip.marker.fillColors && Array.isArray(l2.config.tooltip.marker.fillColors) && (o2 = l2.config.tooltip.marker.fillColors[e2]), l2.config.tooltip.fillSeriesColor ? f2[0].style.backgroundColor = o2 : f2[0].style.color = o2), l2.config.tooltip.marker.show || (f2[0].style.display = "none");
    var m2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-label"), v2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-value");
    if (d2.length && l2.globals.seriesGoals[e2]) {
      var y2 = function() {
        var t4 = "<div>", e3 = "<div>";
        d2.forEach(function(i3, a3) {
          t4 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i3.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i3.attrs.name, "</div>"), e3 += "<div>".concat(i3.val, "</div>");
        }), m2.innerHTML = t4 + "</div>", v2.innerHTML = e3 + "</div>";
      };
      n2 ? l2.globals.seriesGoals[e2][i2] && Array.isArray(l2.globals.seriesGoals[e2][i2]) ? y2() : (m2.innerHTML = "", v2.innerHTML = "") : y2();
    } else
      m2.innerHTML = "", v2.innerHTML = "";
    p2 !== null && (a2[e2].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l2.config.tooltip.z.title, a2[e2].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = p2 !== undefined ? p2 : "");
    if (n2 && f2[0]) {
      if (l2.config.tooltip.hideEmptySeries) {
        var w2 = a2[e2].querySelector(".apexcharts-tooltip-marker"), k2 = a2[e2].querySelector(".apexcharts-tooltip-text");
        parseFloat(c2) == 0 ? (w2.style.display = "none", k2.style.display = "none") : (w2.style.display = "block", k2.style.display = "block");
      }
      c2 == null || l2.globals.ancillaryCollapsedSeriesIndices.indexOf(e2) > -1 || l2.globals.collapsedSeriesIndices.indexOf(e2) > -1 || Array.isArray(h2.tConfig.enabledOnSeries) && h2.tConfig.enabledOnSeries.indexOf(e2) === -1 ? f2[0].parentNode.style.display = "none" : f2[0].parentNode.style.display = l2.config.tooltip.items.display;
    } else
      Array.isArray(h2.tConfig.enabledOnSeries) && h2.tConfig.enabledOnSeries.indexOf(e2) === -1 && (f2[0].parentNode.style.display = "none");
  } }, { key: "toggleActiveInactiveSeries", value: function(t3, e2) {
    var i2 = this.w;
    if (t3)
      this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
      var a2 = i2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(e2));
      a2 && (a2.classList.add("apexcharts-active"), a2.style.display = i2.config.tooltip.items.display);
    }
  } }, { key: "getValuesToPrint", value: function(t3) {
    var { i: e2, j: i2 } = t3, a2 = this.w, s2 = this.ctx.series.filteredSeriesX(), r2 = "", n2 = "", o2 = null, l2 = null, h2 = { series: a2.globals.series, seriesIndex: e2, dataPointIndex: i2, w: a2 }, c2 = a2.globals.ttZFormatter;
    i2 === null ? l2 = a2.globals.series[e2] : a2.globals.isXNumeric && a2.config.chart.type !== "treemap" ? (r2 = s2[e2][i2], s2[e2].length === 0 && (r2 = s2[this.tooltipUtil.getFirstActiveXArray(s2)][i2])) : r2 = new $i(this.ctx).isFormatXY() ? a2.config.series[e2].data[i2] !== undefined ? a2.config.series[e2].data[i2].x : "" : a2.globals.labels[i2] !== undefined ? a2.globals.labels[i2] : "";
    var d2 = r2;
    a2.globals.isXNumeric && a2.config.xaxis.type === "datetime" ? r2 = new Xi(this.ctx).xLabelFormat(a2.globals.ttKeyFormatter, d2, d2, { i: undefined, dateFormatter: new zi(this.ctx).formatDate, w: this.w }) : r2 = a2.globals.isBarHorizontal ? a2.globals.yLabelFormatters[0](d2, h2) : a2.globals.xLabelFormatter(d2, h2);
    return a2.config.tooltip.x.formatter !== undefined && (r2 = a2.globals.ttKeyFormatter(d2, h2)), a2.globals.seriesZ.length > 0 && a2.globals.seriesZ[e2].length > 0 && (o2 = c2(a2.globals.seriesZ[e2][i2], a2)), n2 = typeof a2.config.xaxis.tooltip.formatter == "function" ? a2.globals.xaxisTooltipFormatter(d2, h2) : r2, { val: Array.isArray(l2) ? l2.join(" ") : l2, xVal: Array.isArray(r2) ? r2.join(" ") : r2, xAxisTTVal: Array.isArray(n2) ? n2.join(" ") : n2, zVal: o2 };
  } }, { key: "handleCustomTooltip", value: function(t3) {
    var { i: e2, j: i2, y1: a2, y2: s2, w: r2 } = t3, n2 = this.ttCtx.getElTooltip(), o2 = r2.config.tooltip.custom;
    Array.isArray(o2) && o2[e2] && (o2 = o2[e2]);
    var l2 = o2({ ctx: this.ctx, series: r2.globals.series, seriesIndex: e2, dataPointIndex: i2, y1: a2, y2: s2, w: r2 });
    typeof l2 == "string" ? n2.innerHTML = l2 : (l2 instanceof Element || typeof l2.nodeName == "string") && (n2.innerHTML = "", n2.appendChild(l2.cloneNode(true)));
  } }]), t2;
}();
var wa = function() {
  function t2(e2) {
    i(this, t2), this.ttCtx = e2, this.ctx = e2.ctx, this.w = e2.w;
  }
  return s(t2, [{ key: "moveXCrosshairs", value: function(t3) {
    var e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null, i2 = this.ttCtx, a2 = this.w, s2 = i2.getElXCrosshairs(), r2 = t3 - i2.xcrosshairsWidth / 2, n2 = a2.globals.labels.slice().length;
    if (e2 !== null && (r2 = a2.globals.gridWidth / n2 * e2), s2 === null || a2.globals.isBarHorizontal || (s2.setAttribute("x", r2), s2.setAttribute("x1", r2), s2.setAttribute("x2", r2), s2.setAttribute("y2", a2.globals.gridHeight), s2.classList.add("apexcharts-active")), r2 < 0 && (r2 = 0), r2 > a2.globals.gridWidth && (r2 = a2.globals.gridWidth), i2.isXAxisTooltipEnabled) {
      var o2 = r2;
      a2.config.xaxis.crosshairs.width !== "tickWidth" && a2.config.xaxis.crosshairs.width !== "barWidth" || (o2 = r2 + i2.xcrosshairsWidth / 2), this.moveXAxisTooltip(o2);
    }
  } }, { key: "moveYCrosshairs", value: function(t3) {
    var e2 = this.ttCtx;
    e2.ycrosshairs !== null && Mi.setAttrs(e2.ycrosshairs, { y1: t3, y2: t3 }), e2.ycrosshairsHidden !== null && Mi.setAttrs(e2.ycrosshairsHidden, { y1: t3, y2: t3 });
  } }, { key: "moveXAxisTooltip", value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    if (i2.xaxisTooltip !== null && i2.xcrosshairsWidth !== 0) {
      i2.xaxisTooltip.classList.add("apexcharts-active");
      var a2 = i2.xaxisOffY + e2.config.xaxis.tooltip.offsetY + e2.globals.translateY + 1 + e2.config.xaxis.offsetY;
      if (t3 -= i2.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t3)) {
        t3 += e2.globals.translateX;
        var s2;
        s2 = new Mi(this.ctx).getTextRects(i2.xaxisTooltipText.innerHTML), i2.xaxisTooltipText.style.minWidth = s2.width + "px", i2.xaxisTooltip.style.left = t3 + "px", i2.xaxisTooltip.style.top = a2 + "px";
      }
    }
  } }, { key: "moveYAxisTooltip", value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    i2.yaxisTTEls === null && (i2.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
    var a2 = parseInt(i2.ycrosshairsHidden.getAttribute("y1"), 10), s2 = e2.globals.translateY + a2, r2 = i2.yaxisTTEls[t3].getBoundingClientRect().height, n2 = e2.globals.translateYAxisX[t3] - 2;
    e2.config.yaxis[t3].opposite && (n2 -= 26), s2 -= r2 / 2, e2.globals.ignoreYAxisIndexes.indexOf(t3) === -1 ? (i2.yaxisTTEls[t3].classList.add("apexcharts-active"), i2.yaxisTTEls[t3].style.top = s2 + "px", i2.yaxisTTEls[t3].style.left = n2 + e2.config.yaxis[t3].tooltip.offsetX + "px") : i2.yaxisTTEls[t3].classList.remove("apexcharts-active");
  } }, { key: "moveTooltip", value: function(t3, e2) {
    var i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null, a2 = this.w, s2 = this.ttCtx, r2 = s2.getElTooltip(), n2 = s2.tooltipRect, o2 = i2 !== null ? parseFloat(i2) : 1, l2 = parseFloat(t3) + o2 + 5, h2 = parseFloat(e2) + o2 / 2;
    if (l2 > a2.globals.gridWidth / 2 && (l2 = l2 - n2.ttWidth - o2 - 10), l2 > a2.globals.gridWidth - n2.ttWidth - 10 && (l2 = a2.globals.gridWidth - n2.ttWidth), l2 < -20 && (l2 = -20), a2.config.tooltip.followCursor) {
      var c2 = s2.getElGrid().getBoundingClientRect();
      (l2 = s2.e.clientX - c2.left) > a2.globals.gridWidth / 2 && (l2 -= s2.tooltipRect.ttWidth), (h2 = s2.e.clientY + a2.globals.translateY - c2.top) > a2.globals.gridHeight / 2 && (h2 -= s2.tooltipRect.ttHeight);
    } else
      a2.globals.isBarHorizontal || n2.ttHeight / 2 + h2 > a2.globals.gridHeight && (h2 = a2.globals.gridHeight - n2.ttHeight + a2.globals.translateY);
    isNaN(l2) || (l2 += a2.globals.translateX, r2.style.left = l2 + "px", r2.style.top = h2 + "px");
  } }, { key: "moveMarkers", value: function(t3, e2) {
    var i2 = this.w, a2 = this.ttCtx;
    if (i2.globals.markers.size[t3] > 0)
      for (var s2 = i2.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-marker")), r2 = 0;r2 < s2.length; r2++)
        parseInt(s2[r2].getAttribute("rel"), 10) === e2 && (a2.marker.resetPointsSize(), a2.marker.enlargeCurrentPoint(e2, s2[r2]));
    else
      a2.marker.resetPointsSize(), this.moveDynamicPointOnHover(e2, t3);
  } }, { key: "moveDynamicPointOnHover", value: function(t3, e2) {
    var i2, a2, s2, r2, n2 = this.w, o2 = this.ttCtx, l2 = new Mi(this.ctx), h2 = n2.globals.pointsArray, c2 = o2.tooltipUtil.getHoverMarkerSize(e2), d2 = n2.config.series[e2].type;
    if (!d2 || d2 !== "column" && d2 !== "candlestick" && d2 !== "boxPlot") {
      s2 = (i2 = h2[e2][t3]) === null || i2 === undefined ? undefined : i2[0], r2 = ((a2 = h2[e2][t3]) === null || a2 === undefined ? undefined : a2[1]) || 0;
      var u2 = n2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e2, "'] .apexcharts-series-markers path"));
      if (u2 && r2 < n2.globals.gridHeight && r2 > 0) {
        var g2 = u2.getAttribute("shape"), p2 = l2.getMarkerPath(s2, r2, g2, 1.5 * c2);
        u2.setAttribute("d", p2);
      }
      this.moveXCrosshairs(s2), o2.fixedTooltip || this.moveTooltip(s2, r2, c2);
    }
  } }, { key: "moveDynamicPointsOnHover", value: function(t3) {
    var e2, i2 = this.ttCtx, a2 = i2.w, s2 = 0, r2 = 0, n2 = a2.globals.pointsArray, o2 = new Zi(this.ctx), l2 = new Mi(this.ctx);
    e2 = o2.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
    var h2 = i2.tooltipUtil.getHoverMarkerSize(e2);
    if (n2[e2] && (s2 = n2[e2][t3][0], r2 = n2[e2][t3][1]), !isNaN(s2)) {
      var c2 = i2.tooltipUtil.getAllMarkers();
      if (c2.length)
        for (var d2 = 0;d2 < a2.globals.series.length; d2++) {
          var u2 = n2[d2];
          if (a2.globals.comboCharts && u2 === undefined && c2.splice(d2, 0, null), u2 && u2.length) {
            var g2 = n2[d2][t3][1], p2 = undefined;
            c2[d2].setAttribute("cx", s2);
            var f2 = c2[d2].getAttribute("shape");
            if (a2.config.chart.type === "rangeArea" && !a2.globals.comboCharts) {
              var x2 = t3 + a2.globals.series[d2].length;
              p2 = n2[d2][x2][1], g2 -= Math.abs(g2 - p2) / 2;
            }
            if (g2 !== null && !isNaN(g2) && g2 < a2.globals.gridHeight + h2 && g2 + h2 > 0) {
              var b2 = l2.getMarkerPath(s2, g2, f2, h2);
              c2[d2].setAttribute("d", b2);
            } else
              c2[d2].setAttribute("d", "");
          }
        }
      this.moveXCrosshairs(s2), i2.fixedTooltip || this.moveTooltip(s2, r2 || a2.globals.gridHeight, h2);
    }
  } }, { key: "moveStickyTooltipOverBars", value: function(t3, e2) {
    var i2 = this.w, a2 = this.ttCtx, s2 = i2.globals.columnSeries ? i2.globals.columnSeries.length : i2.globals.series.length;
    i2.config.chart.stacked && (s2 = i2.globals.barGroups.length);
    var r2 = s2 >= 2 && s2 % 2 == 0 ? Math.floor(s2 / 2) : Math.floor(s2 / 2) + 1;
    i2.globals.isBarHorizontal && (r2 = new Zi(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
    var n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "']"));
    n2 || typeof e2 != "number" || (n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "']")));
    var o2 = n2 ? parseFloat(n2.getAttribute("cx")) : 0, l2 = n2 ? parseFloat(n2.getAttribute("cy")) : 0, h2 = n2 ? parseFloat(n2.getAttribute("barWidth")) : 0, c2 = a2.getElGrid().getBoundingClientRect(), d2 = n2 && (n2.classList.contains("apexcharts-candlestick-area") || n2.classList.contains("apexcharts-boxPlot-area"));
    i2.globals.isXNumeric ? (n2 && !d2 && (o2 -= s2 % 2 != 0 ? h2 / 2 : 0), n2 && d2 && (o2 -= h2 / 2)) : i2.globals.isBarHorizontal || (o2 = a2.xAxisTicksPositions[t3 - 1] + a2.dataPointsDividedWidth / 2, isNaN(o2) && (o2 = a2.xAxisTicksPositions[t3] - a2.dataPointsDividedWidth / 2)), i2.globals.isBarHorizontal ? l2 -= a2.tooltipRect.ttHeight : i2.config.tooltip.followCursor ? l2 = a2.e.clientY - c2.top - a2.tooltipRect.ttHeight / 2 : l2 + a2.tooltipRect.ttHeight + 15 > i2.globals.gridHeight && (l2 = i2.globals.gridHeight), i2.globals.isBarHorizontal || this.moveXCrosshairs(o2), a2.fixedTooltip || this.moveTooltip(o2, l2 || i2.globals.gridHeight);
  } }]), t2;
}();
var ka = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx, this.tooltipPosition = new wa(e2);
  }
  return s(t2, [{ key: "drawDynamicPoints", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = new Vi(this.ctx), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    a2 = f(a2), t3.config.chart.stacked && a2.sort(function(t4, e3) {
      return parseFloat(t4.getAttribute("data:realIndex")) - parseFloat(e3.getAttribute("data:realIndex"));
    });
    for (var s2 = 0;s2 < a2.length; s2++) {
      var r2 = a2[s2].querySelector(".apexcharts-series-markers-wrap");
      if (r2 !== null) {
        var n2 = undefined, o2 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
        t3.config.chart.type !== "line" && t3.config.chart.type !== "area" || t3.globals.comboCharts || t3.config.tooltip.intersect || (o2 += " no-pointer-events");
        var l2 = i2.getMarkerConfig({ cssClass: o2, seriesIndex: Number(r2.getAttribute("data:realIndex")) });
        (n2 = e2.drawMarker(0, 0, l2)).node.setAttribute("default-marker-size", 0);
        var h2 = document.createElementNS(t3.globals.SVGNS, "g");
        h2.classList.add("apexcharts-series-markers"), h2.appendChild(n2.node), r2.appendChild(h2);
      }
    }
  } }, { key: "enlargeCurrentPoint", value: function(t3, e2) {
    var i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null, a2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null, s2 = this.w;
    s2.config.chart.type !== "bubble" && this.newPointSize(t3, e2);
    var r2 = e2.getAttribute("cx"), n2 = e2.getAttribute("cy");
    if (i2 !== null && a2 !== null && (r2 = i2, n2 = a2), this.tooltipPosition.moveXCrosshairs(r2), !this.fixedTooltip) {
      if (s2.config.chart.type === "radar") {
        var o2 = this.ttCtx.getElGrid().getBoundingClientRect();
        r2 = this.ttCtx.e.clientX - o2.left;
      }
      this.tooltipPosition.moveTooltip(r2, n2, s2.config.markers.hover.size);
    }
  } }, { key: "enlargePoints", value: function(t3) {
    for (var e2 = this.w, i2 = this, a2 = this.ttCtx, s2 = t3, r2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n2 = e2.config.markers.hover.size, o2 = 0;o2 < r2.length; o2++) {
      var l2 = r2[o2].getAttribute("rel"), h2 = r2[o2].getAttribute("index");
      if (n2 === undefined && (n2 = e2.globals.markers.size[h2] + e2.config.markers.hover.sizeOffset), s2 === parseInt(l2, 10)) {
        i2.newPointSize(s2, r2[o2]);
        var c2 = r2[o2].getAttribute("cx"), d2 = r2[o2].getAttribute("cy");
        i2.tooltipPosition.moveXCrosshairs(c2), a2.fixedTooltip || i2.tooltipPosition.moveTooltip(c2, d2, n2);
      } else
        i2.oldPointSize(r2[o2]);
    }
  } }, { key: "newPointSize", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.markers.hover.size, s2 = t3 === 0 ? e2.parentNode.firstChild : e2.parentNode.lastChild;
    if (s2.getAttribute("default-marker-size") !== "0") {
      var r2 = parseInt(s2.getAttribute("index"), 10);
      a2 === undefined && (a2 = i2.globals.markers.size[r2] + i2.config.markers.hover.sizeOffset), a2 < 0 && (a2 = 0);
      var n2 = this.ttCtx.tooltipUtil.getPathFromPoint(e2, a2);
      e2.setAttribute("d", n2);
    }
  } }, { key: "oldPointSize", value: function(t3) {
    var e2 = parseFloat(t3.getAttribute("default-marker-size")), i2 = this.ttCtx.tooltipUtil.getPathFromPoint(t3, e2);
    t3.setAttribute("d", i2);
  } }, { key: "resetPointsSize", value: function() {
    for (var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e2 = 0;e2 < t3.length; e2++) {
      var i2 = parseFloat(t3[e2].getAttribute("default-marker-size"));
      if (v.isNumber(i2) && i2 > 0) {
        var a2 = this.ttCtx.tooltipUtil.getPathFromPoint(t3[e2], i2);
        t3[e2].setAttribute("d", a2);
      } else
        t3[e2].setAttribute("d", "M0,0");
    }
  } }]), t2;
}();
var Aa = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w;
    var a2 = this.w;
    this.ttCtx = e2, this.isVerticalGroupedRangeBar = !a2.globals.isBarHorizontal && a2.config.chart.type === "rangeBar" && a2.config.plotOptions.bar.rangeBarGroupRows;
  }
  return s(t2, [{ key: "getAttr", value: function(t3, e2) {
    return parseFloat(t3.target.getAttribute(e2));
  } }, { key: "handleHeatTreeTooltip", value: function(t3) {
    var { e: e2, opt: i2, x: a2, y: s2, type: r2 } = t3, n2 = this.ttCtx, o2 = this.w;
    if (e2.target.classList.contains("apexcharts-".concat(r2, "-rect"))) {
      var l2 = this.getAttr(e2, "i"), h2 = this.getAttr(e2, "j"), c2 = this.getAttr(e2, "cx"), d2 = this.getAttr(e2, "cy"), u2 = this.getAttr(e2, "width"), g2 = this.getAttr(e2, "height");
      if (n2.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: l2, j: h2, shared: false, e: e2 }), o2.globals.capturedSeriesIndex = l2, o2.globals.capturedDataPointIndex = h2, a2 = c2 + n2.tooltipRect.ttWidth / 2 + u2, s2 = d2 + n2.tooltipRect.ttHeight / 2 - g2 / 2, n2.tooltipPosition.moveXCrosshairs(c2 + u2 / 2), a2 > o2.globals.gridWidth / 2 && (a2 = c2 - n2.tooltipRect.ttWidth / 2 + u2), n2.w.config.tooltip.followCursor) {
        var p2 = o2.globals.dom.elWrap.getBoundingClientRect();
        a2 = o2.globals.clientX - p2.left - (a2 > o2.globals.gridWidth / 2 ? n2.tooltipRect.ttWidth : 0), s2 = o2.globals.clientY - p2.top - (s2 > o2.globals.gridHeight / 2 ? n2.tooltipRect.ttHeight : 0);
      }
    }
    return { x: a2, y: s2 };
  } }, { key: "handleMarkerTooltip", value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = t3.x, n2 = t3.y, o2 = this.w, l2 = this.ttCtx;
    if (a2.target.classList.contains("apexcharts-marker")) {
      var h2 = parseInt(s2.paths.getAttribute("cx"), 10), c2 = parseInt(s2.paths.getAttribute("cy"), 10), d2 = parseFloat(s2.paths.getAttribute("val"));
      if (i2 = parseInt(s2.paths.getAttribute("rel"), 10), e2 = parseInt(s2.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l2.intersect) {
        var u2 = v.findAncestor(s2.paths, "apexcharts-series");
        u2 && (e2 = parseInt(u2.getAttribute("data:realIndex"), 10));
      }
      if (l2.tooltipLabels.drawSeriesTexts({ ttItems: s2.ttItems, i: e2, j: i2, shared: !l2.showOnIntersect && o2.config.tooltip.shared, e: a2 }), a2.type === "mouseup" && l2.markerClick(a2, e2, i2), o2.globals.capturedSeriesIndex = e2, o2.globals.capturedDataPointIndex = i2, r2 = h2, n2 = c2 + o2.globals.translateY - 1.4 * l2.tooltipRect.ttHeight, l2.w.config.tooltip.followCursor) {
        var g2 = l2.getElGrid().getBoundingClientRect();
        n2 = l2.e.clientY + o2.globals.translateY - g2.top;
      }
      d2 < 0 && (n2 = c2), l2.marker.enlargeCurrentPoint(i2, s2.paths, r2, n2);
    }
    return { x: r2, y: n2 };
  } }, { key: "handleBarTooltip", value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, n2 = this.ttCtx, o2 = n2.getElTooltip(), l2 = 0, h2 = 0, c2 = 0, d2 = this.getBarTooltipXY({ e: a2, opt: s2 });
    if (d2.j !== null || d2.barHeight !== 0 || d2.barWidth !== 0) {
      e2 = d2.i;
      var u2 = d2.j;
      if (r2.globals.capturedSeriesIndex = e2, r2.globals.capturedDataPointIndex = u2, r2.globals.isBarHorizontal && n2.tooltipUtil.hasBars() || !r2.config.tooltip.shared ? (h2 = d2.x, c2 = d2.y, i2 = Array.isArray(r2.config.stroke.width) ? r2.config.stroke.width[e2] : r2.config.stroke.width, l2 = h2) : r2.globals.comboCharts || r2.config.tooltip.shared || (l2 /= 2), isNaN(c2) && (c2 = r2.globals.svgHeight - n2.tooltipRect.ttHeight), parseInt(s2.paths.parentNode.getAttribute("data:realIndex"), 10), h2 + n2.tooltipRect.ttWidth > r2.globals.gridWidth ? h2 -= n2.tooltipRect.ttWidth : h2 < 0 && (h2 = 0), n2.w.config.tooltip.followCursor) {
        var g2 = n2.getElGrid().getBoundingClientRect();
        c2 = n2.e.clientY - g2.top;
      }
      n2.tooltip === null && (n2.tooltip = r2.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r2.config.tooltip.shared || (r2.globals.comboBarCount > 0 ? n2.tooltipPosition.moveXCrosshairs(l2 + i2 / 2) : n2.tooltipPosition.moveXCrosshairs(l2)), !n2.fixedTooltip && (!r2.config.tooltip.shared || r2.globals.isBarHorizontal && n2.tooltipUtil.hasBars()) && (c2 = c2 + r2.globals.translateY - n2.tooltipRect.ttHeight / 2, o2.style.left = h2 + r2.globals.translateX + "px", o2.style.top = c2 + "px");
    }
  } }, { key: "getBarTooltipXY", value: function(t3) {
    var e2 = this, i2 = t3.e, a2 = t3.opt, s2 = this.w, r2 = null, n2 = this.ttCtx, o2 = 0, l2 = 0, h2 = 0, c2 = 0, d2 = 0, u2 = i2.target.classList;
    if (u2.contains("apexcharts-bar-area") || u2.contains("apexcharts-candlestick-area") || u2.contains("apexcharts-boxPlot-area") || u2.contains("apexcharts-rangebar-area")) {
      var g2 = i2.target, p2 = g2.getBoundingClientRect(), f2 = a2.elGrid.getBoundingClientRect(), x2 = p2.height;
      d2 = p2.height;
      var b2 = p2.width, m2 = parseInt(g2.getAttribute("cx"), 10), v2 = parseInt(g2.getAttribute("cy"), 10);
      c2 = parseFloat(g2.getAttribute("barWidth"));
      var y2 = i2.type === "touchmove" ? i2.touches[0].clientX : i2.clientX;
      r2 = parseInt(g2.getAttribute("j"), 10), o2 = parseInt(g2.parentNode.getAttribute("rel"), 10) - 1;
      var w2 = g2.getAttribute("data-range-y1"), k2 = g2.getAttribute("data-range-y2");
      s2.globals.comboCharts && (o2 = parseInt(g2.parentNode.getAttribute("data:realIndex"), 10));
      var A2 = function(t4) {
        return s2.globals.isXNumeric ? m2 - b2 / 2 : e2.isVerticalGroupedRangeBar ? m2 + b2 / 2 : m2 - n2.dataPointsDividedWidth + b2 / 2;
      }, C2 = function() {
        return v2 - n2.dataPointsDividedHeight + x2 / 2 - n2.tooltipRect.ttHeight / 2;
      };
      n2.tooltipLabels.drawSeriesTexts({ ttItems: a2.ttItems, i: o2, j: r2, y1: w2 ? parseInt(w2, 10) : null, y2: k2 ? parseInt(k2, 10) : null, shared: !n2.showOnIntersect && s2.config.tooltip.shared, e: i2 }), s2.config.tooltip.followCursor ? s2.globals.isBarHorizontal ? (l2 = y2 - f2.left + 15, h2 = C2()) : (l2 = A2(), h2 = i2.clientY - f2.top - n2.tooltipRect.ttHeight / 2 - 15) : s2.globals.isBarHorizontal ? ((l2 = m2) < n2.xyRatios.baseLineInvertedY && (l2 = m2 - n2.tooltipRect.ttWidth), h2 = C2()) : (l2 = A2(), h2 = v2);
    }
    return { x: l2, y: h2, barHeight: d2, barWidth: c2, i: o2, j: r2 };
  } }]), t2;
}();
var Ca = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2;
  }
  return s(t2, [{ key: "drawXaxisTooltip", value: function() {
    var t3 = this.w, e2 = this.ttCtx, i2 = t3.config.xaxis.position === "bottom";
    e2.xaxisOffY = i2 ? t3.globals.gridHeight + 1 : -t3.globals.xAxisHeight - t3.config.xaxis.axisTicks.height + 3;
    var a2 = i2 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s2 = t3.globals.dom.elWrap;
    e2.isXAxisTooltipEnabled && (t3.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (e2.xaxisTooltip = document.createElement("div"), e2.xaxisTooltip.setAttribute("class", a2 + " apexcharts-theme-" + t3.config.tooltip.theme), s2.appendChild(e2.xaxisTooltip), e2.xaxisTooltipText = document.createElement("div"), e2.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e2.xaxisTooltipText.style.fontFamily = t3.config.xaxis.tooltip.style.fontFamily || t3.config.chart.fontFamily, e2.xaxisTooltipText.style.fontSize = t3.config.xaxis.tooltip.style.fontSize, e2.xaxisTooltip.appendChild(e2.xaxisTooltipText)));
  } }, { key: "drawYaxisTooltip", value: function() {
    for (var t3 = this.w, e2 = this.ttCtx, i2 = 0;i2 < t3.config.yaxis.length; i2++) {
      var a2 = t3.config.yaxis[i2].opposite || t3.config.yaxis[i2].crosshairs.opposite;
      e2.yaxisOffX = a2 ? t3.globals.gridWidth + 1 : 1;
      var s2 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i2, a2 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), r2 = t3.globals.dom.elWrap;
      t3.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i2)) === null && (e2.yaxisTooltip = document.createElement("div"), e2.yaxisTooltip.setAttribute("class", s2 + " apexcharts-theme-" + t3.config.tooltip.theme), r2.appendChild(e2.yaxisTooltip), i2 === 0 && (e2.yaxisTooltipText = []), e2.yaxisTooltipText[i2] = document.createElement("div"), e2.yaxisTooltipText[i2].classList.add("apexcharts-yaxistooltip-text"), e2.yaxisTooltip.appendChild(e2.yaxisTooltipText[i2]));
    }
  } }, { key: "setXCrosshairWidth", value: function() {
    var t3 = this.w, e2 = this.ttCtx, i2 = e2.getElXCrosshairs();
    if (e2.xcrosshairsWidth = parseInt(t3.config.xaxis.crosshairs.width, 10), t3.globals.comboCharts) {
      var a2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (a2 !== null && t3.config.xaxis.crosshairs.width === "barWidth") {
        var s2 = parseFloat(a2.getAttribute("barWidth"));
        e2.xcrosshairsWidth = s2;
      } else if (t3.config.xaxis.crosshairs.width === "tickWidth") {
        var r2 = t3.globals.labels.length;
        e2.xcrosshairsWidth = t3.globals.gridWidth / r2;
      }
    } else if (t3.config.xaxis.crosshairs.width === "tickWidth") {
      var n2 = t3.globals.labels.length;
      e2.xcrosshairsWidth = t3.globals.gridWidth / n2;
    } else if (t3.config.xaxis.crosshairs.width === "barWidth") {
      var o2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (o2 !== null) {
        var l2 = parseFloat(o2.getAttribute("barWidth"));
        e2.xcrosshairsWidth = l2;
      } else
        e2.xcrosshairsWidth = 1;
    }
    t3.globals.isBarHorizontal && (e2.xcrosshairsWidth = 0), i2 !== null && e2.xcrosshairsWidth > 0 && i2.setAttribute("width", e2.xcrosshairsWidth);
  } }, { key: "handleYCrosshair", value: function() {
    var t3 = this.w, e2 = this.ttCtx;
    e2.ycrosshairs = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e2.ycrosshairsHidden = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
  } }, { key: "drawYaxisTooltipText", value: function(t3, e2, i2) {
    var a2 = this.ttCtx, s2 = this.w, r2 = s2.globals, n2 = r2.seriesYAxisMap[t3];
    if (a2.yaxisTooltips[t3] && n2.length > 0) {
      var o2 = r2.yLabelFormatters[t3], l2 = a2.getElGrid().getBoundingClientRect(), h2 = n2[0], c2 = 0;
      i2.yRatio.length > 1 && (c2 = h2);
      var d2 = (e2 - l2.top) * i2.yRatio[c2], u2 = r2.maxYArr[h2] - r2.minYArr[h2], g2 = r2.minYArr[h2] + (u2 - d2);
      s2.config.yaxis[t3].reversed && (g2 = r2.maxYArr[h2] - (u2 - d2)), a2.tooltipPosition.moveYCrosshairs(e2 - l2.top), a2.yaxisTooltipText[t3].innerHTML = o2(g2), a2.tooltipPosition.moveYAxisTooltip(t3);
    }
  } }]), t2;
}();
var Sa = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.tConfig = a2.config.tooltip, this.tooltipUtil = new va(this), this.tooltipLabels = new ya(this), this.tooltipPosition = new wa(this), this.marker = new ka(this), this.intersect = new Aa(this), this.axesTooltip = new Ca(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a2.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
  }
  return s(t2, [{ key: "getElTooltip", value: function(t3) {
    return t3 || (t3 = this), t3.w.globals.dom.baseEl ? t3.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
  } }, { key: "getElXCrosshairs", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
  } }, { key: "getElGrid", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
  } }, { key: "drawTooltip", value: function(t3) {
    var e2 = this.w;
    this.xyRatios = t3, this.isXAxisTooltipEnabled = e2.config.xaxis.tooltip.enabled && e2.globals.axisCharts, this.yaxisTooltips = e2.config.yaxis.map(function(t4, i3) {
      return !!(t4.show && t4.tooltip.enabled && e2.globals.axisCharts);
    }), this.allTooltipSeriesGroups = [], e2.globals.axisCharts || (this.showTooltipTitle = false);
    var i2 = document.createElement("div");
    if (i2.classList.add("apexcharts-tooltip"), e2.config.tooltip.cssClass && i2.classList.add(e2.config.tooltip.cssClass), i2.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e2.globals.dom.elWrap.appendChild(i2), e2.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      var a2 = new Qi(this.ctx);
      this.xAxisTicksPositions = a2.getXAxisTicksPositions();
    }
    if (!e2.globals.comboCharts && !this.tConfig.intersect && e2.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = true), e2.config.markers.size !== 0 && e2.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), e2.globals.collapsedSeries.length !== e2.globals.series.length) {
      this.dataPointsDividedHeight = e2.globals.gridHeight / e2.globals.dataPoints, this.dataPointsDividedWidth = e2.globals.gridWidth / e2.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e2.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i2.appendChild(this.tooltipTitle));
      var s2 = e2.globals.series.length;
      (e2.globals.xyCharts || e2.globals.comboCharts) && this.tConfig.shared && (s2 = this.showOnIntersect ? 1 : e2.globals.series.length), this.legendLabels = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s2), this.addSVGEvents();
    }
  } }, { key: "createTTElements", value: function(t3) {
    for (var e2 = this, i2 = this.w, a2 = [], s2 = this.getElTooltip(), r2 = function(r3) {
      var n3 = document.createElement("div");
      n3.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(r3)), n3.style.order = i2.config.tooltip.inverseOrder ? t3 - r3 : r3 + 1;
      var o2 = document.createElement("span");
      o2.classList.add("apexcharts-tooltip-marker"), i2.config.tooltip.fillSeriesColor ? o2.style.backgroundColor = i2.globals.colors[r3] : o2.style.color = i2.globals.colors[r3];
      var l2 = i2.config.markers.shape, h2 = l2;
      Array.isArray(l2) && (h2 = l2[r3]), o2.setAttribute("shape", h2), n3.appendChild(o2);
      var c2 = document.createElement("div");
      c2.classList.add("apexcharts-tooltip-text"), c2.style.fontFamily = e2.tConfig.style.fontFamily || i2.config.chart.fontFamily, c2.style.fontSize = e2.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(t4) {
        var e3 = document.createElement("div");
        e3.classList.add("apexcharts-tooltip-".concat(t4, "-group"));
        var i3 = document.createElement("span");
        i3.classList.add("apexcharts-tooltip-text-".concat(t4, "-label")), e3.appendChild(i3);
        var a3 = document.createElement("span");
        a3.classList.add("apexcharts-tooltip-text-".concat(t4, "-value")), e3.appendChild(a3), c2.appendChild(e3);
      }), n3.appendChild(c2), s2.appendChild(n3), a2.push(n3);
    }, n2 = 0;n2 < t3; n2++)
      r2(n2);
    return a2;
  } }, { key: "addSVGEvents", value: function() {
    var t3 = this.w, e2 = t3.config.chart.type, i2 = this.getElTooltip(), a2 = !(e2 !== "bar" && e2 !== "candlestick" && e2 !== "boxPlot" && e2 !== "rangeBar"), s2 = e2 === "area" || e2 === "line" || e2 === "scatter" || e2 === "bubble" || e2 === "radar", r2 = t3.globals.dom.Paper.node, n2 = this.getElGrid();
    n2 && (this.seriesBound = n2.getBoundingClientRect());
    var o2, l2 = [], h2 = [], c2 = { hoverArea: r2, elGrid: n2, tooltipEl: i2, tooltipY: l2, tooltipX: h2, ttItems: this.ttItems };
    if (t3.globals.axisCharts && (s2 ? o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a2 ? o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : e2 !== "heatmap" && e2 !== "treemap" || (o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o2 && o2.length))
      for (var d2 = 0;d2 < o2.length; d2++)
        l2.push(o2[d2].getAttribute("cy")), h2.push(o2[d2].getAttribute("cx"));
    if (t3.globals.xyCharts && !this.showOnIntersect || t3.globals.comboCharts && !this.showOnIntersect || a2 && this.tooltipUtil.hasBars() && this.tConfig.shared)
      this.addPathsEventListeners([r2], c2);
    else if (a2 && !t3.globals.comboCharts || s2 && this.showOnIntersect)
      this.addDatapointEventsListeners(c2);
    else if (!t3.globals.axisCharts || e2 === "heatmap" || e2 === "treemap") {
      var u2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      this.addPathsEventListeners(u2, c2);
    }
    if (this.showOnIntersect) {
      var g2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
      g2.length > 0 && this.addPathsEventListeners(g2, c2), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c2);
    }
  } }, { key: "drawFixedTooltipRect", value: function() {
    var t3 = this.w, e2 = this.getElTooltip(), i2 = e2.getBoundingClientRect(), a2 = i2.width + 10, s2 = i2.height + 10, r2 = this.tConfig.fixed.offsetX, n2 = this.tConfig.fixed.offsetY, o2 = this.tConfig.fixed.position.toLowerCase();
    return o2.indexOf("right") > -1 && (r2 = r2 + t3.globals.svgWidth - a2 + 10), o2.indexOf("bottom") > -1 && (n2 = n2 + t3.globals.svgHeight - s2 - 10), e2.style.left = r2 + "px", e2.style.top = n2 + "px", { x: r2, y: n2, ttWidth: a2, ttHeight: s2 };
  } }, { key: "addDatapointEventsListeners", value: function(t3) {
    var e2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
    this.addPathsEventListeners(e2, t3);
  } }, { key: "addPathsEventListeners", value: function(t3, e2) {
    for (var i2 = this, a2 = function(a3) {
      var s3 = { paths: t3[a3], tooltipEl: e2.tooltipEl, tooltipY: e2.tooltipY, tooltipX: e2.tooltipX, elGrid: e2.elGrid, hoverArea: e2.hoverArea, ttItems: e2.ttItems };
      ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e3) {
        return t3[a3].addEventListener(e3, i2.onSeriesHover.bind(i2, s3), { capture: false, passive: true });
      });
    }, s2 = 0;s2 < t3.length; s2++)
      a2(s2);
  } }, { key: "onSeriesHover", value: function(t3, e2) {
    var i2 = this, a2 = Date.now() - this.lastHoverTime;
    a2 >= 20 ? this.seriesHover(t3, e2) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
      i2.seriesHover(t3, e2);
    }, 20 - a2));
  } }, { key: "seriesHover", value: function(t3, e2) {
    var i2 = this;
    this.lastHoverTime = Date.now();
    var a2 = [], s2 = this.w;
    s2.config.chart.group && (a2 = this.ctx.getGroupedCharts()), s2.globals.axisCharts && (s2.globals.minX === -1 / 0 && s2.globals.maxX === 1 / 0 || s2.globals.dataPoints === 0) || (a2.length ? a2.forEach(function(a3) {
      var s3 = i2.getElTooltip(a3), r2 = { paths: t3.paths, tooltipEl: s3, tooltipY: t3.tooltipY, tooltipX: t3.tooltipX, elGrid: t3.elGrid, hoverArea: t3.hoverArea, ttItems: a3.w.globals.tooltip.ttItems };
      a3.w.globals.minX === i2.w.globals.minX && a3.w.globals.maxX === i2.w.globals.maxX && a3.w.globals.tooltip.seriesHoverByContext({ chartCtx: a3, ttCtx: a3.w.globals.tooltip, opt: r2, e: e2 });
    }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t3, e: e2 }));
  } }, { key: "seriesHoverByContext", value: function(t3) {
    var { chartCtx: e2, ttCtx: i2, opt: a2, e: s2 } = t3, r2 = e2.w, n2 = this.getElTooltip(e2);
    if (n2) {
      if (i2.tooltipRect = { x: 0, y: 0, ttWidth: n2.getBoundingClientRect().width, ttHeight: n2.getBoundingClientRect().height }, i2.e = s2, i2.tooltipUtil.hasBars() && !r2.globals.comboCharts && !i2.isBarShared) {
        if (this.tConfig.onDatasetHover.highlightDataSeries)
          new Zi(e2).toggleSeriesOnHover(s2, s2.target.parentNode);
      }
      i2.fixedTooltip && i2.drawFixedTooltipRect(), r2.globals.axisCharts ? i2.axisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect }) : i2.nonAxisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect });
    }
  } }, { key: "axisChartsTooltips", value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, n2 = s2.elGrid.getBoundingClientRect(), o2 = a2.type === "touchmove" ? a2.touches[0].clientX : a2.clientX, l2 = a2.type === "touchmove" ? a2.touches[0].clientY : a2.clientY;
    if (this.clientY = l2, this.clientX = o2, r2.globals.capturedSeriesIndex = -1, r2.globals.capturedDataPointIndex = -1, l2 < n2.top || l2 > n2.top + n2.height)
      this.handleMouseOut(s2);
    else {
      if (Array.isArray(this.tConfig.enabledOnSeries) && !r2.config.tooltip.shared) {
        var h2 = parseInt(s2.paths.getAttribute("index"), 10);
        if (this.tConfig.enabledOnSeries.indexOf(h2) < 0)
          return void this.handleMouseOut(s2);
      }
      var c2 = this.getElTooltip(), d2 = this.getElXCrosshairs(), u2 = [];
      r2.config.chart.group && (u2 = this.ctx.getSyncedCharts());
      var g2 = r2.globals.xyCharts || r2.config.chart.type === "bar" && !r2.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r2.globals.comboCharts && this.tooltipUtil.hasBars();
      if (a2.type === "mousemove" || a2.type === "touchmove" || a2.type === "mouseup") {
        if (r2.globals.collapsedSeries.length + r2.globals.ancillaryCollapsedSeries.length === r2.globals.series.length)
          return;
        d2 !== null && d2.classList.add("apexcharts-active");
        var p2 = this.yaxisTooltips.filter(function(t4) {
          return t4 === true;
        });
        if (this.ycrosshairs !== null && p2.length && this.ycrosshairs.classList.add("apexcharts-active"), g2 && !this.showOnIntersect || u2.length > 1)
          this.handleStickyTooltip(a2, o2, l2, s2);
        else if (r2.config.chart.type === "heatmap" || r2.config.chart.type === "treemap") {
          var f2 = this.intersect.handleHeatTreeTooltip({ e: a2, opt: s2, x: e2, y: i2, type: r2.config.chart.type });
          e2 = f2.x, i2 = f2.y, c2.style.left = e2 + "px", c2.style.top = i2 + "px";
        } else
          this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a2, opt: s2 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a2, opt: s2, x: e2, y: i2 });
        if (this.yaxisTooltips.length)
          for (var x2 = 0;x2 < r2.config.yaxis.length; x2++)
            this.axesTooltip.drawYaxisTooltipText(x2, l2, this.xyRatios);
        r2.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), s2.tooltipEl.classList.add("apexcharts-active");
      } else
        a2.type !== "mouseout" && a2.type !== "touchend" || this.handleMouseOut(s2);
    }
  } }, { key: "nonAxisChartsTooltips", value: function(t3) {
    var { e: e2, opt: i2, tooltipRect: a2 } = t3, s2 = this.w, r2 = i2.paths.getAttribute("rel"), n2 = this.getElTooltip(), o2 = s2.globals.dom.elWrap.getBoundingClientRect();
    if (e2.type === "mousemove" || e2.type === "touchmove") {
      s2.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), n2.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: parseInt(r2, 10) - 1, shared: false });
      var l2 = s2.globals.clientX - o2.left - a2.ttWidth / 2, h2 = s2.globals.clientY - o2.top - a2.ttHeight - 10;
      if (n2.style.left = l2 + "px", n2.style.top = h2 + "px", s2.config.legend.tooltipHoverFormatter) {
        var c2 = r2 - 1, d2 = (0, s2.config.legend.tooltipHoverFormatter)(this.legendLabels[c2].getAttribute("data:default-text"), { seriesIndex: c2, dataPointIndex: c2, w: s2 });
        this.legendLabels[c2].innerHTML = d2;
      }
    } else
      e2.type !== "mouseout" && e2.type !== "touchend" || (n2.classList.remove("apexcharts-active"), s2.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), s2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
        var e3 = t4.getAttribute("data:default-text");
        t4.innerHTML = decodeURIComponent(e3);
      }));
  } }, { key: "handleStickyTooltip", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a2.hoverArea, elGrid: a2.elGrid, clientX: e2, clientY: i2 }), n2 = r2.j, o2 = r2.capturedSeries;
    s2.globals.collapsedSeriesIndices.includes(o2) && (o2 = null);
    var l2 = a2.elGrid.getBoundingClientRect();
    if (r2.hoverX < 0 || r2.hoverX > l2.width)
      this.handleMouseOut(a2);
    else if (o2 !== null)
      this.handleStickyCapturedSeries(t3, o2, a2, n2);
    else if (this.tooltipUtil.isXoverlap(n2) || s2.globals.isBarHorizontal) {
      var h2 = s2.globals.series.findIndex(function(t4, e3) {
        return !s2.globals.collapsedSeriesIndices.includes(e3);
      });
      this.create(t3, this, h2, n2, a2.ttItems);
    }
  } }, { key: "handleStickyCapturedSeries", value: function(t3, e2, i2, a2) {
    var s2 = this.w;
    if (!this.tConfig.shared && s2.globals.series[e2][a2] === null)
      return void this.handleMouseOut(i2);
    if (s2.globals.series[e2][a2] !== undefined)
      this.tConfig.shared && this.tooltipUtil.isXoverlap(a2) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t3, this, e2, a2, i2.ttItems) : this.create(t3, this, e2, a2, i2.ttItems, false);
    else if (this.tooltipUtil.isXoverlap(a2)) {
      var r2 = s2.globals.series.findIndex(function(t4, e3) {
        return !s2.globals.collapsedSeriesIndices.includes(e3);
      });
      this.create(t3, this, r2, a2, i2.ttItems);
    }
  } }, { key: "deactivateHoverFilter", value: function() {
    for (var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.globals.dom.Paper.find(".apexcharts-bar-area"), a2 = 0;a2 < i2.length; a2++)
      e2.pathMouseLeave(i2[a2]);
  } }, { key: "handleMouseOut", value: function(t3) {
    var e2 = this.w, i2 = this.getElXCrosshairs();
    if (e2.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), t3.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), e2.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i2 !== null && i2.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
      this.yaxisTTEls === null && (this.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      for (var a2 = 0;a2 < this.yaxisTTEls.length; a2++)
        this.yaxisTTEls[a2].classList.remove("apexcharts-active");
    }
    e2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
      var e3 = t4.getAttribute("data:default-text");
      t4.innerHTML = decodeURIComponent(e3);
    });
  } }, { key: "markerClick", value: function(t3, e2, i2) {
    var a2 = this.w;
    typeof a2.config.chart.events.markerClick == "function" && a2.config.chart.events.markerClick(t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }), this.ctx.events.fireEvent("markerClick", [t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }]);
  } }, { key: "create", value: function(t3, e2, i2, a2, s2) {
    var r2, n2, o2, l2, h2, c2, d2, g2, p2, f2, x2, b2, m2, v2, y2, w2, k2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null, A2 = this.w, C2 = e2;
    t3.type === "mouseup" && this.markerClick(t3, i2, a2), k2 === null && (k2 = this.tConfig.shared);
    var S2 = this.tooltipUtil.hasMarkers(i2), L2 = this.tooltipUtil.getElBars(), M2 = function() {
      A2.globals.markers.largestSize > 0 ? C2.marker.enlargePoints(a2) : C2.tooltipPosition.moveDynamicPointsOnHover(a2);
    };
    if (A2.config.legend.tooltipHoverFormatter) {
      var P2 = A2.config.legend.tooltipHoverFormatter, I2 = Array.from(this.legendLabels);
      I2.forEach(function(t4) {
        var e3 = t4.getAttribute("data:default-text");
        t4.innerHTML = decodeURIComponent(e3);
      });
      for (var T2 = 0;T2 < I2.length; T2++) {
        var z2 = I2[T2], X2 = parseInt(z2.getAttribute("i"), 10), R2 = decodeURIComponent(z2.getAttribute("data:default-text")), E2 = P2(R2, { seriesIndex: k2 ? X2 : i2, dataPointIndex: a2, w: A2 });
        if (k2)
          z2.innerHTML = A2.globals.collapsedSeriesIndices.indexOf(X2) < 0 ? E2 : R2;
        else if (z2.innerHTML = X2 === i2 ? E2 : R2, i2 === X2)
          break;
      }
    }
    var Y2 = u(u({ ttItems: s2, i: i2, j: a2 }, ((r2 = A2.globals.seriesRange) === null || r2 === undefined || (n2 = r2[i2]) === null || n2 === undefined || (o2 = n2[a2]) === null || o2 === undefined || (l2 = o2.y[0]) === null || l2 === undefined ? undefined : l2.y1) !== undefined && { y1: (h2 = A2.globals.seriesRange) === null || h2 === undefined || (c2 = h2[i2]) === null || c2 === undefined || (d2 = c2[a2]) === null || d2 === undefined || (g2 = d2.y[0]) === null || g2 === undefined ? undefined : g2.y1 }), ((p2 = A2.globals.seriesRange) === null || p2 === undefined || (f2 = p2[i2]) === null || f2 === undefined || (x2 = f2[a2]) === null || x2 === undefined || (b2 = x2.y[0]) === null || b2 === undefined ? undefined : b2.y2) !== undefined && { y2: (m2 = A2.globals.seriesRange) === null || m2 === undefined || (v2 = m2[i2]) === null || v2 === undefined || (y2 = v2[a2]) === null || y2 === undefined || (w2 = y2.y[0]) === null || w2 === undefined ? undefined : w2.y2 });
    if (k2) {
      if (C2.tooltipLabels.drawSeriesTexts(u(u({}, Y2), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), S2)
        M2();
      else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(L2), this.barSeriesHeight > 0)) {
        var H2 = new Mi(this.ctx), O2 = A2.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(a2, "']"));
        this.deactivateHoverFilter(), C2.tooltipPosition.moveStickyTooltipOverBars(a2, i2), C2.tooltipUtil.getAllMarkers(true).length && M2();
        for (var F2 = 0;F2 < O2.length; F2++)
          H2.pathMouseEnter(O2[F2]);
      }
    } else
      C2.tooltipLabels.drawSeriesTexts(u({ shared: false }, Y2)), this.tooltipUtil.hasBars() && C2.tooltipPosition.moveStickyTooltipOverBars(a2, i2), S2 && C2.tooltipPosition.moveMarkers(i2, a2);
  } }]), t2;
}();
var La = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.barCtx = e2, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
  }
  return s(t2, [{ key: "handleBarDataLabels", value: function(t3) {
    var e2, i2, a2 = t3.x, s2 = t3.y, r2 = t3.y1, n2 = t3.y2, o2 = t3.i, l2 = t3.j, h2 = t3.realIndex, c2 = t3.columnGroupIndex, d2 = t3.series, g2 = t3.barHeight, p2 = t3.barWidth, f2 = t3.barXPosition, x2 = t3.barYPosition, b2 = t3.visibleSeries, m2 = t3.renderedPath, v2 = this.w, y2 = new Mi(this.barCtx.ctx), w2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h2] : this.barCtx.strokeWidth;
    v2.globals.isXNumeric && !v2.globals.isBarHorizontal ? (e2 = a2 + parseFloat(p2 * (b2 + 1)), i2 = s2 + parseFloat(g2 * (b2 + 1)) - w2) : (e2 = a2 + parseFloat(p2 * b2), i2 = s2 + parseFloat(g2 * b2));
    var k2, A2 = null, C2 = a2, S2 = s2, L2 = {}, M2 = v2.config.dataLabels, P2 = this.barCtx.barOptions.dataLabels, I2 = this.barCtx.barOptions.dataLabels.total;
    x2 !== undefined && this.barCtx.isRangeBar && (i2 = x2, S2 = x2), f2 !== undefined && this.barCtx.isVerticalGroupedRangeBar && (e2 = f2, C2 = f2);
    var { offsetX: T2, offsetY: z2 } = M2, X2 = { width: 0, height: 0 };
    if (v2.config.dataLabels.enabled) {
      var R2 = v2.globals.series[o2][l2];
      X2 = y2.getTextRects(v2.config.dataLabels.formatter ? v2.config.dataLabels.formatter(R2, u(u({}, v2), {}, { seriesIndex: o2, dataPointIndex: l2, w: v2 })) : v2.globals.yLabelFormatters[0](R2), parseFloat(M2.style.fontSize));
    }
    var E2 = { x: a2, y: s2, i: o2, j: l2, realIndex: h2, columnGroupIndex: c2, renderedPath: m2, bcx: e2, bcy: i2, barHeight: g2, barWidth: p2, textRects: X2, strokeWidth: w2, dataLabelsX: C2, dataLabelsY: S2, dataLabelsConfig: M2, barDataLabelsConfig: P2, barTotalDataLabelsConfig: I2, offX: T2, offY: z2 };
    return L2 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(E2) : this.calculateColumnsDataLabelsPosition(E2), m2.attr({ cy: L2.bcy, cx: L2.bcx, j: l2, val: v2.globals.series[o2][l2], barHeight: g2, barWidth: p2 }), k2 = this.drawCalculatedDataLabels({ x: L2.dataLabelsX, y: L2.dataLabelsY, val: this.barCtx.isRangeBar ? [r2, n2] : v2.config.chart.stackType === "100%" ? d2[h2][l2] : v2.globals.series[h2][l2], i: h2, j: l2, barWidth: p2, barHeight: g2, textRects: X2, dataLabelsConfig: M2 }), v2.config.chart.stacked && I2.enabled && (A2 = this.drawTotalDataLabels({ x: L2.totalDataLabelsX, y: L2.totalDataLabelsY, barWidth: p2, barHeight: g2, realIndex: h2, textAnchor: L2.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h2, j: l2 }), dataLabelsConfig: M2, barTotalDataLabelsConfig: I2 })), { dataLabels: k2, totalDataLabels: A2 };
  } }, { key: "getStackedTotalDataLabel", value: function(t3) {
    var { realIndex: e2, j: i2 } = t3, a2 = this.w, s2 = this.barCtx.stackedSeriesTotals[i2];
    return this.totalFormatter && (s2 = this.totalFormatter(s2, u(u({}, a2), {}, { seriesIndex: e2, dataPointIndex: i2, w: a2 }))), s2;
  } }, { key: "calculateColumnsDataLabelsPosition", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = t3.i, s2 = t3.j, r2 = t3.realIndex;
    t3.columnGroupIndex;
    var n2, o2, l2 = t3.y, h2 = t3.bcx, c2 = t3.barWidth, d2 = t3.barHeight, u2 = t3.textRects, g2 = t3.dataLabelsX, p2 = t3.dataLabelsY, f2 = t3.dataLabelsConfig, x2 = t3.barDataLabelsConfig, b2 = t3.barTotalDataLabelsConfig, m2 = t3.strokeWidth, v2 = t3.offX, y2 = t3.offY, w2 = h2;
    d2 = Math.abs(d2);
    var k2 = i2.config.plotOptions.bar.dataLabels.orientation === "vertical", A2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: a2, j: s2 }).zeroEncounters;
    h2 -= m2 / 2;
    var C2 = i2.globals.gridWidth / i2.globals.dataPoints;
    if (this.barCtx.isVerticalGroupedRangeBar ? g2 += c2 / 2 : (g2 = i2.globals.isXNumeric ? h2 - c2 / 2 + v2 : h2 - C2 + c2 / 2 + v2, !i2.config.chart.stacked && A2 > 0 && i2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (g2 -= c2 * A2)), k2) {
      g2 = g2 + u2.height / 2 - m2 / 2 - 2;
    }
    var S2 = i2.globals.series[a2][s2] < 0, L2 = l2;
    switch (this.barCtx.isReversed && (L2 = l2 + (S2 ? d2 : -d2)), x2.position) {
      case "center":
        p2 = k2 ? S2 ? L2 - d2 / 2 + y2 : L2 + d2 / 2 - y2 : S2 ? L2 - d2 / 2 + u2.height / 2 + y2 : L2 + d2 / 2 + u2.height / 2 - y2;
        break;
      case "bottom":
        p2 = k2 ? S2 ? L2 - d2 + y2 : L2 + d2 - y2 : S2 ? L2 - d2 + u2.height + m2 + y2 : L2 + d2 - u2.height / 2 + m2 - y2;
        break;
      case "top":
        p2 = k2 ? S2 ? L2 + y2 : L2 - y2 : S2 ? L2 - u2.height / 2 - y2 : L2 + u2.height + y2;
    }
    var M2 = L2;
    if (i2.globals.seriesGroups.forEach(function(t4) {
      var i3;
      (i3 = e2.barCtx[t4.join(",")]) === null || i3 === undefined || i3.prevY.forEach(function(t5) {
        M2 = S2 ? Math.max(t5[s2], M2) : Math.min(t5[s2], M2);
      });
    }), this.barCtx.lastActiveBarSerieIndex === r2 && b2.enabled) {
      var P2 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r2, j: s2 }), f2.fontSize);
      n2 = S2 ? M2 - P2.height / 2 - y2 - b2.offsetY + 18 : M2 + P2.height + y2 + b2.offsetY - 18;
      var I2 = C2;
      o2 = w2 + (i2.globals.isXNumeric ? -c2 * i2.globals.barGroups.length / 2 : i2.globals.barGroups.length * c2 / 2 - (i2.globals.barGroups.length - 1) * c2 - I2) + b2.offsetX;
    }
    return i2.config.chart.stacked || (p2 < 0 ? p2 = 0 + m2 : p2 + u2.height / 3 > i2.globals.gridHeight && (p2 = i2.globals.gridHeight - m2)), { bcx: h2, bcy: l2, dataLabelsX: g2, dataLabelsY: p2, totalDataLabelsX: o2, totalDataLabelsY: n2, totalDataLabelsAnchor: "middle" };
  } }, { key: "calculateBarsDataLabelsPosition", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = t3.x, s2 = t3.i, r2 = t3.j, n2 = t3.realIndex, o2 = t3.bcy, l2 = t3.barHeight, h2 = t3.barWidth, c2 = t3.textRects, d2 = t3.dataLabelsX, u2 = t3.strokeWidth, g2 = t3.dataLabelsConfig, p2 = t3.barDataLabelsConfig, f2 = t3.barTotalDataLabelsConfig, x2 = t3.offX, b2 = t3.offY, m2 = i2.globals.gridHeight / i2.globals.dataPoints, v2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: s2, j: r2 }).zeroEncounters;
    h2 = Math.abs(h2);
    var y2, w2, k2 = o2 - (this.barCtx.isRangeBar ? 0 : m2) + l2 / 2 + c2.height / 2 + b2 - 3;
    !i2.config.chart.stacked && v2 > 0 && i2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (k2 -= l2 * v2);
    var A2 = "start", C2 = i2.globals.series[s2][r2] < 0, S2 = a2;
    switch (this.barCtx.isReversed && (S2 = a2 + (C2 ? -h2 : h2), A2 = C2 ? "start" : "end"), p2.position) {
      case "center":
        d2 = C2 ? S2 + h2 / 2 - x2 : Math.max(c2.width / 2, S2 - h2 / 2) + x2;
        break;
      case "bottom":
        d2 = C2 ? S2 + h2 - u2 - x2 : S2 - h2 + u2 + x2;
        break;
      case "top":
        d2 = C2 ? S2 - u2 - x2 : S2 - u2 + x2;
    }
    var L2 = S2;
    if (i2.globals.seriesGroups.forEach(function(t4) {
      var i3;
      (i3 = e2.barCtx[t4.join(",")]) === null || i3 === undefined || i3.prevX.forEach(function(t5) {
        L2 = C2 ? Math.min(t5[r2], L2) : Math.max(t5[r2], L2);
      });
    }), this.barCtx.lastActiveBarSerieIndex === n2 && f2.enabled) {
      var M2 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: n2, j: r2 }), g2.fontSize);
      C2 ? (y2 = L2 - u2 - x2 - f2.offsetX, A2 = "end") : y2 = L2 + x2 + f2.offsetX + (this.barCtx.isReversed ? -(h2 + u2) : u2), w2 = k2 - c2.height / 2 + M2.height / 2 + f2.offsetY + u2, i2.globals.barGroups.length > 1 && (w2 -= i2.globals.barGroups.length / 2 * (l2 / 2));
    }
    return i2.config.chart.stacked || (g2.textAnchor === "start" ? d2 - c2.width < 0 ? d2 = C2 ? c2.width + u2 : u2 : d2 + c2.width > i2.globals.gridWidth && (d2 = C2 ? i2.globals.gridWidth - u2 : i2.globals.gridWidth - c2.width - u2) : g2.textAnchor === "middle" ? d2 - c2.width / 2 < 0 ? d2 = c2.width / 2 + u2 : d2 + c2.width / 2 > i2.globals.gridWidth && (d2 = i2.globals.gridWidth - c2.width / 2 - u2) : g2.textAnchor === "end" && (d2 < 1 ? d2 = c2.width + u2 : d2 + 1 > i2.globals.gridWidth && (d2 = i2.globals.gridWidth - c2.width - u2))), { bcx: a2, bcy: o2, dataLabelsX: d2, dataLabelsY: k2, totalDataLabelsX: y2, totalDataLabelsY: w2, totalDataLabelsAnchor: A2 };
  } }, { key: "drawCalculatedDataLabels", value: function(t3) {
    var { x: e2, y: i2, val: a2, i: s2, j: r2, textRects: n2, barHeight: o2, barWidth: l2, dataLabelsConfig: h2 } = t3, c2 = this.w, d2 = "rotate(0)";
    c2.config.plotOptions.bar.dataLabels.orientation === "vertical" && (d2 = "rotate(-90, ".concat(e2, ", ").concat(i2, ")"));
    var g2 = new qi(this.barCtx.ctx), p2 = new Mi(this.barCtx.ctx), f2 = h2.formatter, x2 = null, b2 = c2.globals.collapsedSeriesIndices.indexOf(s2) > -1;
    if (h2.enabled && !b2) {
      x2 = p2.group({ class: "apexcharts-data-labels", transform: d2 });
      var m2 = "";
      a2 !== undefined && (m2 = f2(a2, u(u({}, c2), {}, { seriesIndex: s2, dataPointIndex: r2, w: c2 }))), !a2 && c2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (m2 = "");
      var v2 = c2.globals.series[s2][r2] < 0, y2 = c2.config.plotOptions.bar.dataLabels.position;
      if (c2.config.plotOptions.bar.dataLabels.orientation === "vertical" && (y2 === "top" && (h2.textAnchor = v2 ? "end" : "start"), y2 === "center" && (h2.textAnchor = "middle"), y2 === "bottom" && (h2.textAnchor = v2 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels)
        l2 < p2.getTextRects(m2, parseFloat(h2.style.fontSize)).width && (m2 = "");
      c2.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n2.width / 1.6 > Math.abs(l2) && (m2 = "") : n2.height / 1.6 > Math.abs(o2) && (m2 = ""));
      var w2 = u({}, h2);
      this.barCtx.isHorizontal && a2 < 0 && (h2.textAnchor === "start" ? w2.textAnchor = "end" : h2.textAnchor === "end" && (w2.textAnchor = "start")), g2.plotDataLabelsText({ x: e2, y: i2, text: m2, i: s2, j: r2, parent: x2, dataLabelsConfig: w2, alwaysDrawDataLabel: true, offsetCorrection: true });
    }
    return x2;
  } }, { key: "drawTotalDataLabels", value: function(t3) {
    var { x: e2, y: i2, val: a2, realIndex: s2, textAnchor: r2, barTotalDataLabelsConfig: n2 } = t3;
    this.w;
    var o2, l2 = new Mi(this.barCtx.ctx);
    return n2.enabled && e2 !== undefined && i2 !== undefined && this.barCtx.lastActiveBarSerieIndex === s2 && (o2 = l2.drawText({ x: e2, y: i2, foreColor: n2.style.color, text: a2, textAnchor: r2, fontFamily: n2.style.fontFamily, fontSize: n2.style.fontSize, fontWeight: n2.style.fontWeight })), o2;
  } }]), t2;
}();
var Ma = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.barCtx = e2;
  }
  return s(t2, [{ key: "initVariables", value: function(t3) {
    var e2 = this.w;
    this.barCtx.series = t3, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
    for (var i2 = 0;i2 < t3.length; i2++)
      if (t3[i2].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t3[i2].length), e2.globals.isXNumeric)
        for (var a2 = 0;a2 < t3[i2].length; a2++)
          e2.globals.seriesX[i2][a2] > e2.globals.minX && e2.globals.seriesX[i2][a2] < e2.globals.maxX && this.barCtx.visibleItems++;
      else
        this.barCtx.visibleItems = e2.globals.dataPoints;
    this.arrBorderRadius = this.createBorderRadiusArr(e2.globals.series), this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e2.globals.comboCharts || this.checkZeroSeries({ series: t3 });
  } }, { key: "initialPositions", value: function(t3) {
    var e2, i2, a2, s2, r2, n2, o2, l2, h2 = this.w, c2 = h2.globals.dataPoints;
    this.barCtx.isRangeBar && (c2 = h2.globals.labels.length);
    var d2 = this.barCtx.seriesLen;
    if (h2.config.plotOptions.bar.rangeBarGroupRows && (d2 = 1), this.barCtx.isHorizontal)
      r2 = (a2 = h2.globals.gridHeight / c2) / d2, h2.globals.isXNumeric && (r2 = (a2 = h2.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), r2 = r2 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (r2 = parseInt(this.barCtx.barOptions.barHeight, 10)), l2 = this.barCtx.baseLineInvertedY + h2.globals.padHorizontal + (this.barCtx.isReversed ? h2.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (l2 = h2.globals.gridWidth / 2), i2 = (a2 - r2 * this.barCtx.seriesLen) / 2;
    else {
      if (s2 = h2.globals.gridWidth / this.barCtx.visibleItems, h2.config.xaxis.convertedCatToNumeric && (s2 = h2.globals.gridWidth / h2.globals.dataPoints), n2 = s2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h2.globals.isXNumeric) {
        var u2 = this.barCtx.xRatio;
        h2.globals.minXDiff && h2.globals.minXDiff !== 0.5 && h2.globals.minXDiff / u2 > 0 && (s2 = h2.globals.minXDiff / u2), (n2 = s2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (n2 = 1);
      }
      if (String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (n2 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o2 = h2.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? h2.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), h2.globals.isXNumeric)
        e2 = this.barCtx.getBarXForNumericXAxis({ x: e2, j: 0, realIndex: t3, barWidth: n2 }).x;
      else
        e2 = h2.globals.padHorizontal + v.noExponents(s2 - n2 * this.barCtx.seriesLen) / 2;
    }
    return h2.globals.barHeight = r2, h2.globals.barWidth = n2, { x: e2, y: i2, yDivision: a2, xDivision: s2, barHeight: r2, barWidth: n2, zeroH: o2, zeroW: l2 };
  } }, { key: "initializeStackedPrevVars", value: function(t3) {
    t3.w.globals.seriesGroups.forEach(function(e2) {
      t3[e2] || (t3[e2] = {}), t3[e2].prevY = [], t3[e2].prevX = [], t3[e2].prevYF = [], t3[e2].prevXF = [], t3[e2].prevYVal = [], t3[e2].prevXVal = [];
    });
  } }, { key: "initializeStackedXYVars", value: function(t3) {
    t3.w.globals.seriesGroups.forEach(function(e2) {
      t3[e2] || (t3[e2] = {}), t3[e2].xArrj = [], t3[e2].xArrjF = [], t3[e2].xArrjVal = [], t3[e2].yArrj = [], t3[e2].yArrjF = [], t3[e2].yArrjVal = [];
    });
  } }, { key: "getPathFillColor", value: function(t3, e2, i2, a2) {
    var s2, r2, n2, o2, l2 = this.w, h2 = this.barCtx.ctx.fill, c2 = null, d2 = this.barCtx.barOptions.distributed ? i2 : e2, u2 = false;
    this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(a3) {
      t3[e2][i2] >= a3.from && t3[e2][i2] <= a3.to && (c2 = a3.color, u2 = true);
    });
    return { color: h2.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? d2 : a2, dataPointIndex: i2, color: c2, value: t3[e2][i2], fillConfig: (s2 = l2.config.series[e2].data[i2]) === null || s2 === undefined ? undefined : s2.fill, fillType: (r2 = l2.config.series[e2].data[i2]) !== null && r2 !== undefined && (n2 = r2.fill) !== null && n2 !== undefined && n2.type ? (o2 = l2.config.series[e2].data[i2]) === null || o2 === undefined ? undefined : o2.fill.type : Array.isArray(l2.config.fill.type) ? l2.config.fill.type[a2] : l2.config.fill.type }), useRangeColor: u2 };
  } }, { key: "getStrokeWidth", value: function(t3, e2, i2) {
    var a2 = 0, s2 = this.w;
    return this.barCtx.series[t3][e2] ? this.barCtx.isNullValue = false : this.barCtx.isNullValue = true, s2.config.stroke.show && (this.barCtx.isNullValue || (a2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i2] : this.barCtx.strokeWidth)), a2;
  } }, { key: "createBorderRadiusArr", value: function(t3) {
    var e2, i2 = this.w, a2 = !this.w.config.chart.stacked || i2.config.plotOptions.bar.borderRadius <= 0, s2 = t3.length, n2 = 0 | ((e2 = t3[0]) === null || e2 === undefined ? undefined : e2.length), o2 = Array.from({ length: s2 }, function() {
      return Array(n2).fill(a2 ? "top" : "none");
    });
    if (a2)
      return o2;
    for (var l2 = 0;l2 < n2; l2++) {
      for (var h2 = [], c2 = [], d2 = 0, u2 = 0;u2 < s2; u2++) {
        var g2 = t3[u2][l2];
        g2 > 0 ? (h2.push(u2), d2++) : g2 < 0 && (c2.push(u2), d2++);
      }
      if (h2.length > 0 && c2.length === 0)
        if (h2.length === 1)
          o2[h2[0]][l2] = "both";
        else {
          var p2, f2 = h2[0], x2 = h2[h2.length - 1], b2 = r(h2);
          try {
            for (b2.s();!(p2 = b2.n()).done; ) {
              var m2 = p2.value;
              o2[m2][l2] = m2 === f2 ? "bottom" : m2 === x2 ? "top" : "none";
            }
          } catch (t4) {
            b2.e(t4);
          } finally {
            b2.f();
          }
        }
      else if (c2.length > 0 && h2.length === 0)
        if (c2.length === 1)
          o2[c2[0]][l2] = "both";
        else {
          var v2, y2 = Math.max.apply(Math, c2), w2 = Math.min.apply(Math, c2), k2 = r(c2);
          try {
            for (k2.s();!(v2 = k2.n()).done; ) {
              var A2 = v2.value;
              o2[A2][l2] = A2 === y2 ? "bottom" : A2 === w2 ? "top" : "none";
            }
          } catch (t4) {
            k2.e(t4);
          } finally {
            k2.f();
          }
        }
      else if (h2.length > 0 && c2.length > 0) {
        var C2, S2 = h2[h2.length - 1], L2 = r(h2);
        try {
          for (L2.s();!(C2 = L2.n()).done; ) {
            var M2 = C2.value;
            o2[M2][l2] = M2 === S2 ? "top" : "none";
          }
        } catch (t4) {
          L2.e(t4);
        } finally {
          L2.f();
        }
        var P2, I2 = Math.max.apply(Math, c2), T2 = r(c2);
        try {
          for (T2.s();!(P2 = T2.n()).done; ) {
            var z2 = P2.value;
            o2[z2][l2] = z2 === I2 ? "bottom" : "none";
          }
        } catch (t4) {
          T2.e(t4);
        } finally {
          T2.f();
        }
      } else if (d2 === 1) {
        o2[h2[0] || c2[0]][l2] = "both";
      }
    }
    return o2;
  } }, { key: "barBackground", value: function(t3) {
    var { j: e2, i: i2, x1: a2, x2: s2, y1: r2, y2: n2, elSeries: o2 } = t3, l2 = this.w, h2 = new Mi(this.barCtx.ctx), c2 = new Zi(this.barCtx.ctx).getActiveConfigSeriesIndex();
    if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c2 === i2) {
      e2 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e2 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
      var d2 = this.barCtx.barOptions.colors.backgroundBarColors[e2], u2 = h2.drawRect(a2 !== undefined ? a2 : 0, r2 !== undefined ? r2 : 0, s2 !== undefined ? s2 : l2.globals.gridWidth, n2 !== undefined ? n2 : l2.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d2, this.barCtx.barOptions.colors.backgroundBarOpacity);
      o2.add(u2), u2.node.classList.add("apexcharts-backgroundBar");
    }
  } }, { key: "getColumnPaths", value: function(t3) {
    var e2, i2 = t3.barWidth, a2 = t3.barXPosition, s2 = t3.y1, r2 = t3.y2, n2 = t3.strokeWidth, o2 = t3.isReversed, l2 = t3.series, h2 = t3.seriesGroup, c2 = t3.realIndex, d2 = t3.i, u2 = t3.j, g2 = t3.w, p2 = new Mi(this.barCtx.ctx);
    (n2 = Array.isArray(n2) ? n2[c2] : n2) || (n2 = 0);
    var f2 = i2, x2 = a2;
    (e2 = g2.config.series[c2].data[u2]) !== null && e2 !== undefined && e2.columnWidthOffset && (x2 = a2 - g2.config.series[c2].data[u2].columnWidthOffset / 2, f2 = i2 + g2.config.series[c2].data[u2].columnWidthOffset);
    var b2 = n2 / 2, m2 = x2 + b2, v2 = x2 + f2 - b2, y2 = (l2[d2][u2] >= 0 ? 1 : -1) * (o2 ? -1 : 1);
    s2 += 0.001 - b2 * y2, r2 += 0.001 + b2 * y2;
    var w2 = p2.move(m2, s2), k2 = p2.move(m2, s2), A2 = p2.line(v2, s2);
    if (g2.globals.previousPaths.length > 0 && (k2 = this.barCtx.getPreviousPath(c2, u2, false)), w2 = w2 + p2.line(m2, r2) + p2.line(v2, r2) + A2 + (g2.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[c2][u2] === "both" ? " Z" : " z"), k2 = k2 + p2.line(m2, s2) + A2 + A2 + A2 + A2 + A2 + p2.line(m2, s2) + (g2.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[c2][u2] === "both" ? " Z" : " z"), this.arrBorderRadius[c2][u2] !== "none" && (w2 = p2.roundPathCorners(w2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
      var C2 = this.barCtx;
      (C2 = this.barCtx[h2]).yArrj.push(r2 - b2 * y2), C2.yArrjF.push(Math.abs(s2 - r2 + n2 * y2)), C2.yArrjVal.push(this.barCtx.series[d2][u2]);
    }
    return { pathTo: w2, pathFrom: k2 };
  } }, { key: "getBarpaths", value: function(t3) {
    var e2, i2 = t3.barYPosition, a2 = t3.barHeight, s2 = t3.x1, r2 = t3.x2, n2 = t3.strokeWidth, o2 = t3.isReversed, l2 = t3.series, h2 = t3.seriesGroup, c2 = t3.realIndex, d2 = t3.i, u2 = t3.j, g2 = t3.w, p2 = new Mi(this.barCtx.ctx);
    (n2 = Array.isArray(n2) ? n2[c2] : n2) || (n2 = 0);
    var f2 = i2, x2 = a2;
    (e2 = g2.config.series[c2].data[u2]) !== null && e2 !== undefined && e2.barHeightOffset && (f2 = i2 - g2.config.series[c2].data[u2].barHeightOffset / 2, x2 = a2 + g2.config.series[c2].data[u2].barHeightOffset);
    var b2 = n2 / 2, m2 = f2 + b2, v2 = f2 + x2 - b2, y2 = (l2[d2][u2] >= 0 ? 1 : -1) * (o2 ? -1 : 1);
    s2 += 0.001 + b2 * y2, r2 += 0.001 - b2 * y2;
    var w2 = p2.move(s2, m2), k2 = p2.move(s2, m2);
    g2.globals.previousPaths.length > 0 && (k2 = this.barCtx.getPreviousPath(c2, u2, false));
    var A2 = p2.line(s2, v2);
    if (w2 = w2 + p2.line(r2, m2) + p2.line(r2, v2) + A2 + (g2.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[c2][u2] === "both" ? " Z" : " z"), k2 = k2 + p2.line(s2, m2) + A2 + A2 + A2 + A2 + A2 + p2.line(s2, m2) + (g2.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[c2][u2] === "both" ? " Z" : " z"), this.arrBorderRadius[c2][u2] !== "none" && (w2 = p2.roundPathCorners(w2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
      var C2 = this.barCtx;
      (C2 = this.barCtx[h2]).xArrj.push(r2 + b2 * y2), C2.xArrjF.push(Math.abs(s2 - r2 - n2 * y2)), C2.xArrjVal.push(this.barCtx.series[d2][u2]);
    }
    return { pathTo: w2, pathFrom: k2 };
  } }, { key: "checkZeroSeries", value: function(t3) {
    for (var e2 = t3.series, i2 = this.w, a2 = 0;a2 < e2.length; a2++) {
      for (var s2 = 0, r2 = 0;r2 < e2[i2.globals.maxValsInArrayIndex].length; r2++)
        s2 += e2[a2][r2];
      s2 === 0 && this.barCtx.zeroSerieses.push(a2);
    }
  } }, { key: "getXForValue", value: function(t3, e2) {
    var i2 = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2] ? e2 : null;
    return t3 != null && (i2 = e2 + t3 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t3 / this.barCtx.invertedYRatio : 0)), i2;
  } }, { key: "getYForValue", value: function(t3, e2, i2) {
    var a2 = !(arguments.length > 3 && arguments[3] !== undefined) || arguments[3] ? e2 : null;
    return t3 != null && (a2 = e2 - t3 / this.barCtx.yRatio[i2] + 2 * (this.barCtx.isReversed ? t3 / this.barCtx.yRatio[i2] : 0)), a2;
  } }, { key: "getGoalValues", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = this, l2 = this.w, h2 = [], c2 = function(a3, s3) {
      var l3;
      h2.push((o(l3 = {}, t3, t3 === "x" ? n2.getXForValue(a3, e2, false) : n2.getYForValue(a3, i2, r2, false)), o(l3, "attrs", s3), l3));
    };
    if (l2.globals.seriesGoals[a2] && l2.globals.seriesGoals[a2][s2] && Array.isArray(l2.globals.seriesGoals[a2][s2]) && l2.globals.seriesGoals[a2][s2].forEach(function(t4) {
      c2(t4.value, t4);
    }), this.barCtx.barOptions.isDumbbell && l2.globals.seriesRange.length) {
      var d2 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l2.globals.colors, g2 = { strokeHeight: t3 === "x" ? 0 : l2.globals.markers.size[a2], strokeWidth: t3 === "x" ? l2.globals.markers.size[a2] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(d2[a2]) ? d2[a2][0] : d2[a2] };
      c2(l2.globals.seriesRangeStart[a2][s2], g2), c2(l2.globals.seriesRangeEnd[a2][s2], u(u({}, g2), {}, { strokeColor: Array.isArray(d2[a2]) ? d2[a2][1] : d2[a2] }));
    }
    return h2;
  } }, { key: "drawGoalLine", value: function(t3) {
    var { barXPosition: e2, barYPosition: i2, goalX: a2, goalY: s2, barWidth: r2, barHeight: n2 } = t3, o2 = new Mi(this.barCtx.ctx), l2 = o2.group({ className: "apexcharts-bar-goals-groups" });
    l2.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l2.node }), l2.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
    var h2 = null;
    return this.barCtx.isHorizontal ? Array.isArray(a2) && a2.forEach(function(t4) {
      if (t4.x >= -1 && t4.x <= o2.w.globals.gridWidth + 1) {
        var e3 = t4.attrs.strokeHeight !== undefined ? t4.attrs.strokeHeight : n2 / 2, a3 = i2 + e3 + n2 / 2;
        h2 = o2.drawLine(t4.x, a3 - 2 * e3, t4.x, a3, t4.attrs.strokeColor ? t4.attrs.strokeColor : undefined, t4.attrs.strokeDashArray, t4.attrs.strokeWidth ? t4.attrs.strokeWidth : 2, t4.attrs.strokeLineCap), l2.add(h2);
      }
    }) : Array.isArray(s2) && s2.forEach(function(t4) {
      if (t4.y >= -1 && t4.y <= o2.w.globals.gridHeight + 1) {
        var i3 = t4.attrs.strokeWidth !== undefined ? t4.attrs.strokeWidth : r2 / 2, a3 = e2 + i3 + r2 / 2;
        h2 = o2.drawLine(a3 - 2 * i3, t4.y, a3, t4.y, t4.attrs.strokeColor ? t4.attrs.strokeColor : undefined, t4.attrs.strokeDashArray, t4.attrs.strokeHeight ? t4.attrs.strokeHeight : 2, t4.attrs.strokeLineCap), l2.add(h2);
      }
    }), l2;
  } }, { key: "drawBarShadow", value: function(t3) {
    var { prevPaths: e2, currPaths: i2, color: a2 } = t3, s2 = this.w, r2 = e2.x, n2 = e2.x1, o2 = e2.barYPosition, l2 = i2.x, h2 = i2.x1, c2 = i2.barYPosition, d2 = o2 + i2.barHeight, u2 = new Mi(this.barCtx.ctx), g2 = new v, p2 = u2.move(n2, d2) + u2.line(r2, d2) + u2.line(l2, c2) + u2.line(h2, c2) + u2.line(n2, d2) + (s2.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[realIndex][j] === "both" ? " Z" : " z");
    return u2.drawPath({ d: p2, fill: g2.shadeColor(0.5, v.rgb2hex(a2)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadow apexcharts-decoration-element" });
  } }, { key: "getZeroValueEncounters", value: function(t3) {
    var e2, i2 = t3.i, a2 = t3.j, s2 = this.w, r2 = 0, n2 = 0;
    return (s2.config.plotOptions.bar.horizontal ? s2.globals.series.map(function(t4, e3) {
      return e3;
    }) : ((e2 = s2.globals.columnSeries) === null || e2 === undefined ? undefined : e2.i.map(function(t4) {
      return t4;
    })) || []).forEach(function(t4) {
      var e3 = s2.globals.seriesPercent[t4][a2];
      e3 && r2++, t4 < i2 && e3 === 0 && n2++;
    }), { nonZeroColumns: r2, zeroEncounters: n2 };
  } }, { key: "getGroupIndex", value: function(t3) {
    var e2 = this.w, i2 = e2.globals.seriesGroups.findIndex(function(i3) {
      return i3.indexOf(e2.globals.seriesNames[t3]) > -1;
    }), a2 = this.barCtx.columnGroupIndices, s2 = a2.indexOf(i2);
    return s2 < 0 && (a2.push(i2), s2 = a2.length - 1), { groupIndex: i2, columnGroupIndex: s2 };
  } }]), t2;
}();
var Pa = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var s2 = this.w;
    this.barOptions = s2.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s2.config.stroke.width, this.isNullValue = false, this.isRangeBar = s2.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s2.globals.isBarHorizontal && s2.globals.seriesRange.length && s2.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = a2, this.xyRatios !== null && (this.xRatio = a2.xRatio, this.yRatio = a2.yRatio, this.invertedXRatio = a2.invertedXRatio, this.invertedYRatio = a2.invertedYRatio, this.baseLineY = a2.baseLineY, this.baseLineInvertedY = a2.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
    var r2 = new Zi(this.ctx);
    this.lastActiveBarSerieIndex = r2.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
    var n2 = r2.getBarSeriesIndices(), o2 = new Pi(this.ctx);
    this.stackedSeriesTotals = o2.getStackedSeriesTotals(this.w.config.series.map(function(t3, e3) {
      return n2.indexOf(e3) === -1 ? e3 : -1;
    }).filter(function(t3) {
      return t3 !== -1;
    })), this.barHelpers = new Ma(this);
  }
  return s(t2, [{ key: "draw", value: function(t3, e2) {
    var i2 = this.w, a2 = new Mi(this.ctx), s2 = new Pi(this.ctx, i2);
    t3 = s2.getLogSeries(t3), this.series = t3, this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
    var r2 = a2.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
    i2.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
    for (var n2 = 0, o2 = 0;n2 < t3.length; n2++, o2++) {
      var l2, h2, c2, d2, g2 = undefined, p2 = undefined, f2 = [], x2 = [], b2 = i2.globals.comboCharts ? e2[n2] : n2, m2 = this.barHelpers.getGroupIndex(b2).columnGroupIndex, y2 = a2.group({ class: "apexcharts-series", rel: n2 + 1, seriesName: v.escapeString(i2.globals.seriesNames[b2]), "data:realIndex": b2 });
      this.ctx.series.addCollapsedClassToSeries(y2, b2), t3[n2].length > 0 && (this.visibleI = this.visibleI + 1);
      var w2 = 0, k2 = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i2.globals.seriesYAxisReverseMap[b2], this.translationsIndex = b2);
      var A2 = this.translationsIndex;
      this.isReversed = i2.config.yaxis[this.yaxisIndex] && i2.config.yaxis[this.yaxisIndex].reversed;
      var C2 = this.barHelpers.initialPositions(b2);
      p2 = C2.y, w2 = C2.barHeight, h2 = C2.yDivision, d2 = C2.zeroW, g2 = C2.x, k2 = C2.barWidth, l2 = C2.xDivision, c2 = C2.zeroH, this.isHorizontal || x2.push(g2 + k2 / 2);
      var S2 = a2.group({ class: "apexcharts-datalabels", "data:realIndex": b2 });
      i2.globals.delayedElements.push({ el: S2.node }), S2.node.classList.add("apexcharts-element-hidden");
      var L2 = a2.group({ class: "apexcharts-bar-goals-markers" }), M2 = a2.group({ class: "apexcharts-bar-shadows" });
      i2.globals.delayedElements.push({ el: M2.node }), M2.node.classList.add("apexcharts-element-hidden");
      for (var P2 = 0;P2 < t3[n2].length; P2++) {
        var I2 = this.barHelpers.getStrokeWidth(n2, P2, b2), T2 = null, z2 = { indexes: { i: n2, j: P2, realIndex: b2, translationsIndex: A2, bc: o2 }, x: g2, y: p2, strokeWidth: I2, elSeries: y2 };
        this.isHorizontal ? (T2 = this.drawBarPaths(u(u({}, z2), {}, { barHeight: w2, zeroW: d2, yDivision: h2 })), k2 = this.series[n2][P2] / this.invertedYRatio) : (T2 = this.drawColumnPaths(u(u({}, z2), {}, { xDivision: l2, barWidth: k2, zeroH: c2 })), w2 = this.series[n2][P2] / this.yRatio[A2]);
        var X2 = this.barHelpers.getPathFillColor(t3, n2, P2, b2);
        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && P2 > 0) {
          var R2, E2 = this.barHelpers.drawBarShadow({ color: typeof X2.color == "string" && ((R2 = X2.color) === null || R2 === undefined ? undefined : R2.indexOf("url")) === -1 ? X2.color : v.hexToRgba(i2.globals.colors[n2]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: T2 });
          if (M2.add(E2), i2.config.chart.dropShadow.enabled)
            new Li(this.ctx).dropShadow(E2, i2.config.chart.dropShadow, b2);
        }
        this.pathArr.push(T2);
        var Y2 = this.barHelpers.drawGoalLine({ barXPosition: T2.barXPosition, barYPosition: T2.barYPosition, goalX: T2.goalX, goalY: T2.goalY, barHeight: w2, barWidth: k2 });
        Y2 && L2.add(Y2), p2 = T2.y, g2 = T2.x, P2 > 0 && x2.push(g2 + k2 / 2), f2.push(p2), this.renderSeries(u(u({ realIndex: b2, pathFill: X2.color }, X2.useRangeColor ? { lineFill: X2.color } : {}), {}, { j: P2, i: n2, columnGroupIndex: m2, pathFrom: T2.pathFrom, pathTo: T2.pathTo, strokeWidth: I2, elSeries: y2, x: g2, y: p2, series: t3, barHeight: Math.abs(T2.barHeight ? T2.barHeight : w2), barWidth: Math.abs(T2.barWidth ? T2.barWidth : k2), elDataLabelsWrap: S2, elGoalsMarkers: L2, elBarShadows: M2, visibleSeries: this.visibleI, type: "bar" }));
      }
      i2.globals.seriesXvalues[b2] = x2, i2.globals.seriesYvalues[b2] = f2, r2.add(y2);
    }
    return r2;
  } }, { key: "renderSeries", value: function(t3) {
    var { realIndex: e2, pathFill: i2, lineFill: a2, j: s2, i: r2, columnGroupIndex: n2, pathFrom: o2, pathTo: l2, strokeWidth: h2, elSeries: c2, x: d2, y: u2, y1: g2, y2: p2, series: f2, barHeight: x2, barWidth: b2, barXPosition: m2, barYPosition: v2, elDataLabelsWrap: y2, elGoalsMarkers: w2, elBarShadows: k2, visibleSeries: A2, type: C2, classes: S2 } = t3, L2 = this.w, M2 = new Mi(this.ctx);
    if (!a2) {
      var P2 = typeof L2.globals.stroke.colors[e2] == "function" ? function(t4) {
        var e3, i3 = L2.config.stroke.colors;
        return Array.isArray(i3) && i3.length > 0 && ((e3 = i3[t4]) || (e3 = ""), typeof e3 == "function") ? e3({ value: L2.globals.series[t4][s2], dataPointIndex: s2, w: L2 }) : e3;
      }(e2) : L2.globals.stroke.colors[e2];
      a2 = this.barOptions.distributed ? L2.globals.stroke.colors[s2] : P2;
    }
    L2.config.series[r2].data[s2] && L2.config.series[r2].data[s2].strokeColor && (a2 = L2.config.series[r2].data[s2].strokeColor), this.isNullValue && (i2 = "none");
    var I2 = s2 / L2.config.chart.animations.animateGradually.delay * (L2.config.chart.animations.speed / L2.globals.dataPoints) / 2.4, T2 = M2.renderPaths({ i: r2, j: s2, realIndex: e2, pathFrom: o2, pathTo: l2, stroke: a2, strokeWidth: h2, strokeLineCap: L2.config.stroke.lineCap, fill: i2, animationDelay: I2, initialSpeed: L2.config.chart.animations.speed, dataChangeSpeed: L2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(C2, "-area ").concat(S2), chartType: C2 });
    T2.attr("clip-path", "url(#gridRectBarMask".concat(L2.globals.cuid, ")"));
    var z2 = L2.config.forecastDataPoints;
    z2.count > 0 && s2 >= L2.globals.dataPoints - z2.count && (T2.node.setAttribute("stroke-dasharray", z2.dashArray), T2.node.setAttribute("stroke-width", z2.strokeWidth), T2.node.setAttribute("fill-opacity", z2.fillOpacity)), g2 !== undefined && p2 !== undefined && (T2.attr("data-range-y1", g2), T2.attr("data-range-y2", p2)), new Li(this.ctx).setSelectionFilter(T2, e2, s2), c2.add(T2);
    var X2 = new La(this).handleBarDataLabels({ x: d2, y: u2, y1: g2, y2: p2, i: r2, j: s2, series: f2, realIndex: e2, columnGroupIndex: n2, barHeight: x2, barWidth: b2, barXPosition: m2, barYPosition: v2, renderedPath: T2, visibleSeries: A2 });
    return X2.dataLabels !== null && y2.add(X2.dataLabels), X2.totalDataLabels && y2.add(X2.totalDataLabels), c2.add(y2), w2 && c2.add(w2), k2 && c2.add(k2), c2;
  } }, { key: "drawBarPaths", value: function(t3) {
    var e2, i2 = t3.indexes, a2 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, n2 = t3.x, o2 = t3.y, l2 = t3.yDivision, h2 = t3.elSeries, c2 = this.w, d2 = i2.i, u2 = i2.j;
    if (c2.globals.isXNumeric)
      e2 = (o2 = (c2.globals.seriesX[d2][u2] - c2.globals.minX) / this.invertedXRatio - a2) + a2 * this.visibleI;
    else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var g2 = this.barHelpers.getZeroValueEncounters({ i: d2, j: u2 }), p2 = g2.nonZeroColumns, f2 = g2.zeroEncounters;
      p2 > 0 && (a2 = this.seriesLen * a2 / p2), e2 = o2 + a2 * this.visibleI, e2 -= a2 * f2;
    } else
      e2 = o2 + a2 * this.visibleI;
    this.isFunnel && (r2 -= (this.barHelpers.getXForValue(this.series[d2][u2], r2) - r2) / 2), n2 = this.barHelpers.getXForValue(this.series[d2][u2], r2);
    var x2 = this.barHelpers.getBarpaths({ barYPosition: e2, barHeight: a2, x1: r2, x2: n2, strokeWidth: s2, isReversed: this.isReversed, series: this.series, realIndex: i2.realIndex, i: d2, j: u2, w: c2 });
    return c2.globals.isXNumeric || (o2 += l2), this.barHelpers.barBackground({ j: u2, i: d2, y1: e2 - a2 * this.visibleI, y2: a2 * this.seriesLen, elSeries: h2 }), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, x1: r2, x: n2, y: o2, goalX: this.barHelpers.getGoalValues("x", r2, null, d2, u2), barYPosition: e2, barHeight: a2 };
  } }, { key: "drawColumnPaths", value: function(t3) {
    var e2, i2 = t3.indexes, a2 = t3.x, s2 = t3.y, r2 = t3.xDivision, n2 = t3.barWidth, o2 = t3.zeroH, l2 = t3.strokeWidth, h2 = t3.elSeries, c2 = this.w, d2 = i2.realIndex, u2 = i2.translationsIndex, g2 = i2.i, p2 = i2.j, f2 = i2.bc;
    if (c2.globals.isXNumeric) {
      var x2 = this.getBarXForNumericXAxis({ x: a2, j: p2, realIndex: d2, barWidth: n2 });
      a2 = x2.x, e2 = x2.barXPosition;
    } else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var b2 = this.barHelpers.getZeroValueEncounters({ i: g2, j: p2 }), m2 = b2.nonZeroColumns, v2 = b2.zeroEncounters;
      m2 > 0 && (n2 = this.seriesLen * n2 / m2), e2 = a2 + n2 * this.visibleI, e2 -= n2 * v2;
    } else
      e2 = a2 + n2 * this.visibleI;
    s2 = this.barHelpers.getYForValue(this.series[g2][p2], o2, u2);
    var y2 = this.barHelpers.getColumnPaths({ barXPosition: e2, barWidth: n2, y1: o2, y2: s2, strokeWidth: l2, isReversed: this.isReversed, series: this.series, realIndex: d2, i: g2, j: p2, w: c2 });
    return c2.globals.isXNumeric || (a2 += r2), this.barHelpers.barBackground({ bc: f2, j: p2, i: g2, x1: e2 - l2 / 2 - n2 * this.visibleI, x2: n2 * this.seriesLen + l2 / 2, elSeries: h2 }), { pathTo: y2.pathTo, pathFrom: y2.pathFrom, x: a2, y: s2, goalY: this.barHelpers.getGoalValues("y", null, o2, g2, p2, u2), barXPosition: e2, barWidth: n2 };
  } }, { key: "getBarXForNumericXAxis", value: function(t3) {
    var { x: e2, barWidth: i2, realIndex: a2, j: s2 } = t3, r2 = this.w, n2 = a2;
    return r2.globals.seriesX[a2].length || (n2 = r2.globals.maxValsInArrayIndex), v.isNumber(r2.globals.seriesX[n2][s2]) && (e2 = (r2.globals.seriesX[n2][s2] - r2.globals.minX) / this.xRatio - i2 * this.seriesLen / 2), { barXPosition: e2 + i2 * this.visibleI, x: e2 };
  } }, { key: "getPreviousPath", value: function(t3, e2) {
    for (var i2, a2 = this.w, s2 = 0;s2 < a2.globals.previousPaths.length; s2++) {
      var r2 = a2.globals.previousPaths[s2];
      r2.paths && r2.paths.length > 0 && parseInt(r2.realIndex, 10) === parseInt(t3, 10) && a2.globals.previousPaths[s2].paths[e2] !== undefined && (i2 = a2.globals.previousPaths[s2].paths[e2].d);
    }
    return i2;
  } }]), t2;
}();
var Ia = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3) {
    var i2 = this, a3 = this.w;
    this.graphics = new Mi(this.ctx), this.bar = new Pa(this.ctx, this.xyRatios);
    var s2 = new Pi(this.ctx, a3);
    t3 = s2.getLogSeries(t3), this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3), a3.config.chart.stackType === "100%" && (t3 = a3.globals.comboCharts ? e3.map(function(t4) {
      return a3.globals.seriesPercent[t4];
    }) : a3.globals.seriesPercent.slice()), this.series = t3, this.barHelpers.initializeStackedPrevVars(this);
    for (var r2 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n2 = 0, o2 = 0, l2 = function(s3, l3) {
      var h3 = undefined, c3 = undefined, d2 = undefined, g2 = undefined, p2 = a3.globals.comboCharts ? e3[s3] : s3, f2 = i2.barHelpers.getGroupIndex(p2), x2 = f2.groupIndex, b2 = f2.columnGroupIndex;
      i2.groupCtx = i2[a3.globals.seriesGroups[x2]];
      var m2 = [], y2 = [], w2 = 0;
      i2.yRatio.length > 1 && (i2.yaxisIndex = a3.globals.seriesYAxisReverseMap[p2][0], w2 = p2), i2.isReversed = a3.config.yaxis[i2.yaxisIndex] && a3.config.yaxis[i2.yaxisIndex].reversed;
      var k2 = i2.graphics.group({ class: "apexcharts-series", seriesName: v.escapeString(a3.globals.seriesNames[p2]), rel: s3 + 1, "data:realIndex": p2 });
      i2.ctx.series.addCollapsedClassToSeries(k2, p2);
      var A2 = i2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": p2 }), C2 = i2.graphics.group({ class: "apexcharts-bar-goals-markers" }), S2 = 0, L2 = 0, M2 = i2.initialPositions(n2, o2, h3, c3, d2, g2, w2);
      o2 = M2.y, S2 = M2.barHeight, c3 = M2.yDivision, g2 = M2.zeroW, n2 = M2.x, L2 = M2.barWidth, h3 = M2.xDivision, d2 = M2.zeroH, a3.globals.barHeight = S2, a3.globals.barWidth = L2, i2.barHelpers.initializeStackedXYVars(i2), i2.groupCtx.prevY.length === 1 && i2.groupCtx.prevY[0].every(function(t4) {
        return isNaN(t4);
      }) && (i2.groupCtx.prevY[0] = i2.groupCtx.prevY[0].map(function() {
        return d2;
      }), i2.groupCtx.prevYF[0] = i2.groupCtx.prevYF[0].map(function() {
        return 0;
      }));
      for (var P2 = 0;P2 < a3.globals.dataPoints; P2++) {
        var I2 = i2.barHelpers.getStrokeWidth(s3, P2, p2), T2 = { indexes: { i: s3, j: P2, realIndex: p2, translationsIndex: w2, bc: l3 }, strokeWidth: I2, x: n2, y: o2, elSeries: k2, columnGroupIndex: b2, seriesGroup: a3.globals.seriesGroups[x2] }, z2 = null;
        i2.isHorizontal ? (z2 = i2.drawStackedBarPaths(u(u({}, T2), {}, { zeroW: g2, barHeight: S2, yDivision: c3 })), L2 = i2.series[s3][P2] / i2.invertedYRatio) : (z2 = i2.drawStackedColumnPaths(u(u({}, T2), {}, { xDivision: h3, barWidth: L2, zeroH: d2 })), S2 = i2.series[s3][P2] / i2.yRatio[w2]);
        var X2 = i2.barHelpers.drawGoalLine({ barXPosition: z2.barXPosition, barYPosition: z2.barYPosition, goalX: z2.goalX, goalY: z2.goalY, barHeight: S2, barWidth: L2 });
        X2 && C2.add(X2), o2 = z2.y, n2 = z2.x, m2.push(n2), y2.push(o2);
        var R2 = i2.barHelpers.getPathFillColor(t3, s3, P2, p2), E2 = "", Y2 = a3.globals.isBarHorizontal ? "apexcharts-flip-x" : "apexcharts-flip-y";
        (i2.barHelpers.arrBorderRadius[p2][P2] === "bottom" && a3.globals.series[p2][P2] > 0 || i2.barHelpers.arrBorderRadius[p2][P2] === "top" && a3.globals.series[p2][P2] < 0) && (E2 = Y2), k2 = i2.renderSeries(u(u({ realIndex: p2, pathFill: R2.color }, R2.useRangeColor ? { lineFill: R2.color } : {}), {}, { j: P2, i: s3, columnGroupIndex: b2, pathFrom: z2.pathFrom, pathTo: z2.pathTo, strokeWidth: I2, elSeries: k2, x: n2, y: o2, series: t3, barHeight: S2, barWidth: L2, elDataLabelsWrap: A2, elGoalsMarkers: C2, type: "bar", visibleSeries: b2, classes: E2 }));
      }
      a3.globals.seriesXvalues[p2] = m2, a3.globals.seriesYvalues[p2] = y2, i2.groupCtx.prevY.push(i2.groupCtx.yArrj), i2.groupCtx.prevYF.push(i2.groupCtx.yArrjF), i2.groupCtx.prevYVal.push(i2.groupCtx.yArrjVal), i2.groupCtx.prevX.push(i2.groupCtx.xArrj), i2.groupCtx.prevXF.push(i2.groupCtx.xArrjF), i2.groupCtx.prevXVal.push(i2.groupCtx.xArrjVal), r2.add(k2);
    }, h2 = 0, c2 = 0;h2 < t3.length; h2++, c2++)
      l2(h2, c2);
    return r2;
  } }, { key: "initialPositions", value: function(t3, e3, i2, a3, s2, r2, n2) {
    var o2, l2, h2 = this.w;
    if (this.isHorizontal) {
      a3 = h2.globals.gridHeight / h2.globals.dataPoints;
      var c2 = h2.config.plotOptions.bar.barHeight;
      o2 = String(c2).indexOf("%") === -1 ? parseInt(c2, 10) : a3 * parseInt(c2, 10) / 100, r2 = h2.globals.padHorizontal + (this.isReversed ? h2.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), e3 = (a3 - o2) / 2;
    } else {
      l2 = i2 = h2.globals.gridWidth / h2.globals.dataPoints;
      var d2 = h2.config.plotOptions.bar.columnWidth;
      h2.globals.isXNumeric && h2.globals.dataPoints > 1 ? l2 = (i2 = h2.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : String(d2).indexOf("%") === -1 ? l2 = parseInt(d2, 10) : l2 *= parseInt(d2, 10) / 100, s2 = this.isReversed ? this.baseLineY[n2] : h2.globals.gridHeight - this.baseLineY[n2], t3 = h2.globals.padHorizontal + (i2 - l2) / 2;
    }
    var u2 = h2.globals.barGroups.length || 1;
    return { x: t3, y: e3, yDivision: a3, xDivision: i2, barHeight: o2 / u2, barWidth: l2 / u2, zeroH: s2, zeroW: r2 };
  } }, { key: "drawStackedBarPaths", value: function(t3) {
    for (var e3, i2 = t3.indexes, a3 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, n2 = t3.x, o2 = t3.y, l2 = t3.columnGroupIndex, h2 = t3.seriesGroup, c2 = t3.yDivision, d2 = t3.elSeries, u2 = this.w, g2 = o2 + l2 * a3, p2 = i2.i, f2 = i2.j, x2 = i2.realIndex, b2 = i2.translationsIndex, m2 = 0, v2 = 0;v2 < this.groupCtx.prevXF.length; v2++)
      m2 += this.groupCtx.prevXF[v2][f2];
    var y2 = p2;
    if (u2.config.series[x2].name && (y2 = h2.indexOf(u2.config.series[x2].name)), y2 > 0) {
      var w2 = r2;
      this.groupCtx.prevXVal[y2 - 1][f2] < 0 ? w2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[y2 - 1][f2] + m2 - 2 * (this.isReversed ? m2 : 0) : this.groupCtx.prevX[y2 - 1][f2] : this.groupCtx.prevXVal[y2 - 1][f2] >= 0 && (w2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[y2 - 1][f2] : this.groupCtx.prevX[y2 - 1][f2] - m2 + 2 * (this.isReversed ? m2 : 0)), e3 = w2;
    } else
      e3 = r2;
    n2 = this.series[p2][f2] === null ? e3 : e3 + this.series[p2][f2] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p2][f2] / this.invertedYRatio : 0);
    var k2 = this.barHelpers.getBarpaths({ barYPosition: g2, barHeight: a3, x1: e3, x2: n2, strokeWidth: s2, isReversed: this.isReversed, series: this.series, realIndex: i2.realIndex, seriesGroup: h2, i: p2, j: f2, w: u2 });
    return this.barHelpers.barBackground({ j: f2, i: p2, y1: g2, y2: a3, elSeries: d2 }), o2 += c2, { pathTo: k2.pathTo, pathFrom: k2.pathFrom, goalX: this.barHelpers.getGoalValues("x", r2, null, p2, f2, b2), barXPosition: e3, barYPosition: g2, x: n2, y: o2 };
  } }, { key: "drawStackedColumnPaths", value: function(t3) {
    var { indexes: e3, x: i2, y: a3, xDivision: s2, barWidth: r2, zeroH: n2, columnGroupIndex: o2, seriesGroup: l2, elSeries: h2 } = t3, c2 = this.w, d2 = e3.i, u2 = e3.j, g2 = e3.bc, p2 = e3.realIndex, f2 = e3.translationsIndex;
    if (c2.globals.isXNumeric) {
      var x2 = c2.globals.seriesX[p2][u2];
      x2 || (x2 = 0), i2 = (x2 - c2.globals.minX) / this.xRatio - r2 / 2 * c2.globals.barGroups.length;
    }
    for (var b2, m2 = i2 + o2 * r2, v2 = 0, y2 = 0;y2 < this.groupCtx.prevYF.length; y2++)
      v2 += isNaN(this.groupCtx.prevYF[y2][u2]) ? 0 : this.groupCtx.prevYF[y2][u2];
    var w2 = d2;
    if (l2 && (w2 = l2.indexOf(c2.globals.seriesNames[p2])), w2 > 0 && !c2.globals.isXNumeric || w2 > 0 && c2.globals.isXNumeric && c2.globals.seriesX[p2 - 1][u2] === c2.globals.seriesX[p2][u2]) {
      var k2, A2, C2, S2 = Math.min(this.yRatio.length + 1, p2 + 1);
      if (this.groupCtx.prevY[w2 - 1] !== undefined && this.groupCtx.prevY[w2 - 1].length)
        for (var L2 = 1;L2 < S2; L2++) {
          var M2;
          if (!isNaN((M2 = this.groupCtx.prevY[w2 - L2]) === null || M2 === undefined ? undefined : M2[u2])) {
            C2 = this.groupCtx.prevY[w2 - L2][u2];
            break;
          }
        }
      for (var P2 = 1;P2 < S2; P2++) {
        var I2, T2;
        if (((I2 = this.groupCtx.prevYVal[w2 - P2]) === null || I2 === undefined ? undefined : I2[u2]) < 0) {
          A2 = this.series[d2][u2] >= 0 ? C2 - v2 + 2 * (this.isReversed ? v2 : 0) : C2;
          break;
        }
        if (((T2 = this.groupCtx.prevYVal[w2 - P2]) === null || T2 === undefined ? undefined : T2[u2]) >= 0) {
          A2 = this.series[d2][u2] >= 0 ? C2 : C2 + v2 - 2 * (this.isReversed ? v2 : 0);
          break;
        }
      }
      A2 === undefined && (A2 = c2.globals.gridHeight), b2 = (k2 = this.groupCtx.prevYF[0]) !== null && k2 !== undefined && k2.every(function(t4) {
        return t4 === 0;
      }) && this.groupCtx.prevYF.slice(1, w2).every(function(t4) {
        return t4.every(function(t5) {
          return isNaN(t5);
        });
      }) ? n2 : A2;
    } else
      b2 = n2;
    a3 = this.series[d2][u2] ? b2 - this.series[d2][u2] / this.yRatio[f2] + 2 * (this.isReversed ? this.series[d2][u2] / this.yRatio[f2] : 0) : b2;
    var z2 = this.barHelpers.getColumnPaths({ barXPosition: m2, barWidth: r2, y1: b2, y2: a3, yRatio: this.yRatio[f2], strokeWidth: this.strokeWidth, isReversed: this.isReversed, series: this.series, seriesGroup: l2, realIndex: e3.realIndex, i: d2, j: u2, w: c2 });
    return this.barHelpers.barBackground({ bc: g2, j: u2, i: d2, x1: m2, x2: r2, elSeries: h2 }), { pathTo: z2.pathTo, pathFrom: z2.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, n2, d2, u2), barXPosition: m2, x: c2.globals.isXNumeric ? i2 : i2 + s2, y: a3 };
  } }]), a2;
}();
var Ta = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3, i2) {
    var a3 = this, s2 = this.w, r2 = new Mi(this.ctx), n2 = s2.globals.comboCharts ? e3 : s2.config.chart.type, o2 = new ji(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s2.config.plotOptions.bar.horizontal;
    var l2 = new Pi(this.ctx, s2);
    t3 = l2.getLogSeries(t3), this.series = t3, this.yRatio = l2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
    for (var h2 = r2.group({ class: "apexcharts-".concat(n2, "-series apexcharts-plot-series") }), c2 = function(e4) {
      a3.isBoxPlot = s2.config.chart.type === "boxPlot" || s2.config.series[e4].type === "boxPlot";
      var n3, l3, c3, d3, g2 = undefined, p2 = undefined, f2 = [], x2 = [], b2 = s2.globals.comboCharts ? i2[e4] : e4, m2 = a3.barHelpers.getGroupIndex(b2).columnGroupIndex, y2 = r2.group({ class: "apexcharts-series", seriesName: v.escapeString(s2.globals.seriesNames[b2]), rel: e4 + 1, "data:realIndex": b2 });
      a3.ctx.series.addCollapsedClassToSeries(y2, b2), t3[e4].length > 0 && (a3.visibleI = a3.visibleI + 1);
      var w2, k2, A2 = 0;
      a3.yRatio.length > 1 && (a3.yaxisIndex = s2.globals.seriesYAxisReverseMap[b2][0], A2 = b2);
      var C2 = a3.barHelpers.initialPositions(b2);
      p2 = C2.y, w2 = C2.barHeight, l3 = C2.yDivision, d3 = C2.zeroW, g2 = C2.x, k2 = C2.barWidth, n3 = C2.xDivision, c3 = C2.zeroH, x2.push(g2 + k2 / 2);
      for (var S2 = r2.group({ class: "apexcharts-datalabels", "data:realIndex": b2 }), L2 = r2.group({ class: "apexcharts-bar-goals-markers" }), M2 = function(i3) {
        var r3 = a3.barHelpers.getStrokeWidth(e4, i3, b2), h3 = null, v2 = { indexes: { i: e4, j: i3, realIndex: b2, translationsIndex: A2 }, x: g2, y: p2, strokeWidth: r3, elSeries: y2 };
        h3 = a3.isHorizontal ? a3.drawHorizontalBoxPaths(u(u({}, v2), {}, { yDivision: l3, barHeight: w2, zeroW: d3 })) : a3.drawVerticalBoxPaths(u(u({}, v2), {}, { xDivision: n3, barWidth: k2, zeroH: c3 })), p2 = h3.y, g2 = h3.x;
        var C3 = a3.barHelpers.drawGoalLine({ barXPosition: h3.barXPosition, barYPosition: h3.barYPosition, goalX: h3.goalX, goalY: h3.goalY, barHeight: w2, barWidth: k2 });
        C3 && L2.add(C3), i3 > 0 && x2.push(g2 + k2 / 2), f2.push(p2), h3.pathTo.forEach(function(n4, l4) {
          var c4 = !a3.isBoxPlot && a3.candlestickOptions.wick.useFillColor ? h3.color[l4] : s2.globals.stroke.colors[e4], d4 = o2.fillPath({ seriesNumber: b2, dataPointIndex: i3, color: h3.color[l4], value: t3[e4][i3] });
          a3.renderSeries({ realIndex: b2, pathFill: d4, lineFill: c4, j: i3, i: e4, pathFrom: h3.pathFrom, pathTo: n4, strokeWidth: r3, elSeries: y2, x: g2, y: p2, series: t3, columnGroupIndex: m2, barHeight: w2, barWidth: k2, elDataLabelsWrap: S2, elGoalsMarkers: L2, visibleSeries: a3.visibleI, type: s2.config.chart.type });
        });
      }, P2 = 0;P2 < s2.globals.dataPoints; P2++)
        M2(P2);
      s2.globals.seriesXvalues[b2] = x2, s2.globals.seriesYvalues[b2] = f2, h2.add(y2);
    }, d2 = 0;d2 < t3.length; d2++)
      c2(d2);
    return h2;
  } }, { key: "drawVerticalBoxPaths", value: function(t3) {
    var { indexes: e3, x: i2 } = t3;
    t3.y;
    var { xDivision: a3, barWidth: s2, zeroH: r2, strokeWidth: n2 } = t3, o2 = this.w, l2 = new Mi(this.ctx), h2 = e3.i, c2 = e3.j, d2 = o2.config.plotOptions.candlestick.colors, u2 = this.boxOptions.colors, g2 = e3.realIndex, p2 = function(t4) {
      return Array.isArray(t4) ? t4[g2] : t4;
    }, f2 = p2(d2.upward), x2 = p2(d2.downward), b2 = this.yRatio[e3.translationsIndex], m2 = this.getOHLCValue(g2, c2), v2 = r2, y2 = r2, w2 = m2.o < m2.c ? [f2] : [x2];
    this.isBoxPlot && (w2 = [p2(u2.lower), p2(u2.upper)]);
    var k2 = Math.min(m2.o, m2.c), A2 = Math.max(m2.o, m2.c), C2 = m2.m;
    o2.globals.isXNumeric && (i2 = (o2.globals.seriesX[g2][c2] - o2.globals.minX) / this.xRatio - s2 / 2);
    var S2 = i2 + s2 * this.visibleI;
    this.series[h2][c2] === undefined || this.series[h2][c2] === null ? (k2 = r2, A2 = r2) : (k2 = r2 - k2 / b2, A2 = r2 - A2 / b2, v2 = r2 - m2.h / b2, y2 = r2 - m2.l / b2, C2 = r2 - m2.m / b2);
    var L2 = l2.move(S2, r2), M2 = l2.move(S2 + s2 / 2, k2);
    return o2.globals.previousPaths.length > 0 && (M2 = this.getPreviousPath(g2, c2, true)), L2 = this.isBoxPlot ? [l2.move(S2, k2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 4, v2) + l2.line(S2 + s2 - s2 / 4, v2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2, k2) + l2.line(S2 + s2, C2) + l2.line(S2, C2) + l2.line(S2, k2 + n2 / 2), l2.move(S2, C2) + l2.line(S2 + s2, C2) + l2.line(S2 + s2, A2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 - s2 / 4, y2) + l2.line(S2 + s2 / 4, y2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2, A2) + l2.line(S2, C2) + "z"] : [l2.move(S2, A2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2, A2) + l2.line(S2 + s2, k2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2, k2) + l2.line(S2, A2 - n2 / 2)], M2 += l2.move(S2, k2), o2.globals.isXNumeric || (i2 += a3), { pathTo: L2, pathFrom: M2, x: i2, y: A2, goalY: this.barHelpers.getGoalValues("y", null, r2, h2, c2, e3.translationsIndex), barXPosition: S2, color: w2 };
  } }, { key: "drawHorizontalBoxPaths", value: function(t3) {
    var e3 = t3.indexes;
    t3.x;
    var { y: i2, yDivision: a3, barHeight: s2, zeroW: r2, strokeWidth: n2 } = t3, o2 = this.w, l2 = new Mi(this.ctx), h2 = e3.i, c2 = e3.j, d2 = this.boxOptions.colors.lower;
    this.isBoxPlot && (d2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    var u2 = this.invertedYRatio, g2 = e3.realIndex, p2 = this.getOHLCValue(g2, c2), f2 = r2, x2 = r2, b2 = Math.min(p2.o, p2.c), m2 = Math.max(p2.o, p2.c), v2 = p2.m;
    o2.globals.isXNumeric && (i2 = (o2.globals.seriesX[g2][c2] - o2.globals.minX) / this.invertedXRatio - s2 / 2);
    var y2 = i2 + s2 * this.visibleI;
    this.series[h2][c2] === undefined || this.series[h2][c2] === null ? (b2 = r2, m2 = r2) : (b2 = r2 + b2 / u2, m2 = r2 + m2 / u2, f2 = r2 + p2.h / u2, x2 = r2 + p2.l / u2, v2 = r2 + p2.m / u2);
    var w2 = l2.move(r2, y2), k2 = l2.move(b2, y2 + s2 / 2);
    return o2.globals.previousPaths.length > 0 && (k2 = this.getPreviousPath(g2, c2, true)), w2 = [l2.move(b2, y2) + l2.line(b2, y2 + s2 / 2) + l2.line(f2, y2 + s2 / 2) + l2.line(f2, y2 + s2 / 2 - s2 / 4) + l2.line(f2, y2 + s2 / 2 + s2 / 4) + l2.line(f2, y2 + s2 / 2) + l2.line(b2, y2 + s2 / 2) + l2.line(b2, y2 + s2) + l2.line(v2, y2 + s2) + l2.line(v2, y2) + l2.line(b2 + n2 / 2, y2), l2.move(v2, y2) + l2.line(v2, y2 + s2) + l2.line(m2, y2 + s2) + l2.line(m2, y2 + s2 / 2) + l2.line(x2, y2 + s2 / 2) + l2.line(x2, y2 + s2 - s2 / 4) + l2.line(x2, y2 + s2 / 4) + l2.line(x2, y2 + s2 / 2) + l2.line(m2, y2 + s2 / 2) + l2.line(m2, y2) + l2.line(v2, y2) + "z"], k2 += l2.move(b2, y2), o2.globals.isXNumeric || (i2 += a3), { pathTo: w2, pathFrom: k2, x: m2, y: i2, goalX: this.barHelpers.getGoalValues("x", r2, null, h2, c2), barYPosition: y2, color: d2 };
  } }, { key: "getOHLCValue", value: function(t3, e3) {
    var i2 = this.w, a3 = new Pi(this.ctx, i2), s2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleH[t3][e3], t3), r2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleO[t3][e3], t3), n2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleM[t3][e3], t3), o2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleC[t3][e3], t3), l2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleL[t3][e3], t3);
    return { o: this.isBoxPlot ? s2 : r2, h: this.isBoxPlot ? r2 : s2, m: n2, l: this.isBoxPlot ? o2 : l2, c: this.isBoxPlot ? l2 : o2 };
  } }]), a2;
}();
var za = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "checkColorRange", value: function() {
    var t3 = this.w, e2 = false, i2 = t3.config.plotOptions[t3.config.chart.type];
    return i2.colorScale.ranges.length > 0 && i2.colorScale.ranges.map(function(t4, i3) {
      t4.from <= 0 && (e2 = true);
    }), e2;
  } }, { key: "getShadeColor", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = 1, n2 = s2.config.plotOptions[t3].shadeIntensity, o2 = this.determineColor(t3, e2, i2);
    s2.globals.hasNegs || a2 ? r2 = s2.config.plotOptions[t3].reverseNegativeShade ? o2.percent < 0 ? o2.percent / 100 * (1.25 * n2) : (1 - o2.percent / 100) * (1.25 * n2) : o2.percent <= 0 ? 1 - (1 + o2.percent / 100) * n2 : (1 - o2.percent / 100) * n2 : (r2 = 1 - o2.percent / 100, t3 === "treemap" && (r2 = (1 - o2.percent / 100) * (1.25 * n2)));
    var l2 = o2.color, h2 = new v;
    if (s2.config.plotOptions[t3].enableShades)
      if (this.w.config.theme.mode === "dark") {
        var c2 = h2.shadeColor(-1 * r2, o2.color);
        l2 = v.hexToRgba(v.isColorHex(c2) ? c2 : v.rgb2hex(c2), s2.config.fill.opacity);
      } else {
        var d2 = h2.shadeColor(r2, o2.color);
        l2 = v.hexToRgba(v.isColorHex(d2) ? d2 : v.rgb2hex(d2), s2.config.fill.opacity);
      }
    return { color: l2, colorProps: o2 };
  } }, { key: "determineColor", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.globals.series[e2][i2], r2 = a2.config.plotOptions[t3], n2 = r2.colorScale.inverse ? i2 : e2;
    r2.distributed && a2.config.chart.type === "treemap" && (n2 = i2);
    var o2 = a2.globals.colors[n2], l2 = null, h2 = Math.min.apply(Math, f(a2.globals.series[e2])), c2 = Math.max.apply(Math, f(a2.globals.series[e2]));
    r2.distributed || t3 !== "heatmap" || (h2 = a2.globals.minY, c2 = a2.globals.maxY), r2.colorScale.min !== undefined && (h2 = r2.colorScale.min < a2.globals.minY ? r2.colorScale.min : a2.globals.minY, c2 = r2.colorScale.max > a2.globals.maxY ? r2.colorScale.max : a2.globals.maxY);
    var d2 = Math.abs(c2) + Math.abs(h2), u2 = 100 * s2 / (d2 === 0 ? d2 - 0.000001 : d2);
    r2.colorScale.ranges.length > 0 && r2.colorScale.ranges.map(function(t4, e3) {
      if (s2 >= t4.from && s2 <= t4.to) {
        o2 = t4.color, l2 = t4.foreColor ? t4.foreColor : null, h2 = t4.from, c2 = t4.to;
        var i3 = Math.abs(c2) + Math.abs(h2);
        u2 = 100 * s2 / (i3 === 0 ? i3 - 0.000001 : i3);
      }
    });
    return { color: o2, foreColor: l2, percent: u2 };
  } }, { key: "calculateDataLabels", value: function(t3) {
    var { text: e2, x: i2, y: a2, i: s2, j: r2, colorProps: n2, fontSize: o2 } = t3, l2 = this.w.config.dataLabels, h2 = new Mi(this.ctx), c2 = new qi(this.ctx), d2 = null;
    if (l2.enabled) {
      d2 = h2.group({ class: "apexcharts-data-labels" });
      var { offsetX: u2, offsetY: g2 } = l2, p2 = i2 + u2, f2 = a2 + parseFloat(l2.style.fontSize) / 3 + g2;
      c2.plotDataLabelsText({ x: p2, y: f2, text: e2, i: s2, j: r2, color: n2.foreColor, parent: d2, fontSize: o2, dataLabelsConfig: l2 });
    }
    return d2;
  } }, { key: "addListeners", value: function(t3) {
    var e2 = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", e2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", e2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mousedown", e2.pathMouseDown.bind(this, t3));
  } }]), t2;
}();
var Xa = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.xRatio = a2.xRatio, this.yRatio = a2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new za(e2), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = i2.group({ class: "apexcharts-heatmap" });
    a2.attr("clip-path", "url(#gridRectMask".concat(e2.globals.cuid, ")"));
    var s2 = e2.globals.gridWidth / e2.globals.dataPoints, r2 = e2.globals.gridHeight / e2.globals.series.length, n2 = 0, o2 = false;
    this.negRange = this.helpers.checkColorRange();
    var l2 = t3.slice();
    e2.config.yaxis[0].reversed && (o2 = true, l2.reverse());
    for (var h2 = o2 ? 0 : l2.length - 1;o2 ? h2 < l2.length : h2 >= 0; o2 ? h2++ : h2--) {
      var c2 = i2.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: v.escapeString(e2.globals.seriesNames[h2]), rel: h2 + 1, "data:realIndex": h2 });
      if (this.ctx.series.addCollapsedClassToSeries(c2, h2), e2.config.chart.dropShadow.enabled) {
        var d2 = e2.config.chart.dropShadow;
        new Li(this.ctx).dropShadow(c2, d2, h2);
      }
      for (var u2 = 0, g2 = e2.config.plotOptions.heatmap.shadeIntensity, p2 = 0, f2 = 0;f2 < e2.globals.dataPoints; f2++)
        if (e2.globals.seriesX.length && !e2.globals.allSeriesHasEqualX && e2.globals.minX + e2.globals.minXDiff * f2 < e2.globals.seriesX[h2][p2])
          u2 += s2;
        else {
          if (p2 >= l2[h2].length)
            break;
          var x2 = this.helpers.getShadeColor(e2.config.chart.type, h2, p2, this.negRange), b2 = x2.color, m2 = x2.colorProps;
          if (e2.config.fill.type === "image")
            b2 = new ji(this.ctx).fillPath({ seriesNumber: h2, dataPointIndex: p2, opacity: e2.globals.hasNegs ? m2.percent < 0 ? 1 - (1 + m2.percent / 100) : g2 + m2.percent / 100 : m2.percent / 100, patternID: v.randomId(), width: e2.config.fill.image.width ? e2.config.fill.image.width : s2, height: e2.config.fill.image.height ? e2.config.fill.image.height : r2 });
          var y2 = this.rectRadius, w2 = i2.drawRect(u2, n2, s2, r2, y2);
          if (w2.attr({ cx: u2, cy: n2 }), w2.node.classList.add("apexcharts-heatmap-rect"), c2.add(w2), w2.attr({ fill: b2, i: h2, index: h2, j: p2, val: t3[h2][p2], "stroke-width": this.strokeWidth, stroke: e2.config.plotOptions.heatmap.useFillColorAsStroke ? b2 : e2.globals.stroke.colors[0], color: b2 }), this.helpers.addListeners(w2), e2.config.chart.animations.enabled && !e2.globals.dataChanged) {
            var k2 = 1;
            e2.globals.resized || (k2 = e2.config.chart.animations.speed), this.animateHeatMap(w2, u2, n2, s2, r2, k2);
          }
          if (e2.globals.dataChanged) {
            var A2 = 1;
            if (this.dynamicAnim.enabled && e2.globals.shouldAnimate) {
              A2 = this.dynamicAnim.speed;
              var C2 = e2.globals.previousPaths[h2] && e2.globals.previousPaths[h2][p2] && e2.globals.previousPaths[h2][p2].color;
              C2 || (C2 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(w2, v.isColorHex(C2) ? C2 : v.rgb2hex(C2), v.isColorHex(b2) ? b2 : v.rgb2hex(b2), A2);
            }
          }
          var S2 = (0, e2.config.dataLabels.formatter)(e2.globals.series[h2][p2], { value: e2.globals.series[h2][p2], seriesIndex: h2, dataPointIndex: p2, w: e2 }), L2 = this.helpers.calculateDataLabels({ text: S2, x: u2 + s2 / 2, y: n2 + r2 / 2, i: h2, j: p2, colorProps: m2, series: l2 });
          L2 !== null && c2.add(L2), u2 += s2, p2++;
        }
      n2 += r2, a2.add(c2);
    }
    var M2 = e2.globals.yAxisScale[0].result.slice();
    return e2.config.yaxis[0].reversed ? M2.unshift("") : M2.push(""), e2.globals.yAxisScale[0].result = M2, a2;
  } }, { key: "animateHeatMap", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = new y(this.ctx);
    n2.animateRect(t3, { x: e2 + a2 / 2, y: i2 + s2 / 2, width: 0, height: 0 }, { x: e2, y: i2, width: a2, height: s2 }, r2, function() {
      n2.animationCompleted(t3);
    });
  } }, { key: "animateHeatColor", value: function(t3, e2, i2, a2) {
    t3.attr({ fill: e2 }).animate(a2).attr({ fill: i2 });
  } }]), t2;
}();
var Ra = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawYAxisTexts", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = s2.config.yaxis[0], n2 = s2.globals.yLabelFormatters[0];
    return new Mi(this.ctx).drawText({ x: t3 + r2.labels.offsetX, y: e2 + r2.labels.offsetY, text: n2(a2, i2), textAnchor: "middle", fontSize: r2.labels.style.fontSize, fontFamily: r2.labels.style.fontFamily, foreColor: Array.isArray(r2.labels.style.colors) ? r2.labels.style.colors[i2] : r2.labels.style.colors });
  } }]), t2;
}();
var Ea = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = a2.globals.stroke.colors !== undefined ? a2.globals.stroke.colors : a2.globals.colors, this.defaultSize = Math.min(a2.globals.gridWidth, a2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = a2.globals.gridWidth / 2, a2.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(a2.config.plotOptions.pie.endAngle - a2.config.plotOptions.pie.startAngle), this.initialAngle = a2.config.plotOptions.pie.startAngle % this.fullAngle, a2.globals.radialSize = this.defaultSize / 2.05 - a2.config.stroke.width - (a2.config.chart.sparkline.enabled ? 0 : a2.config.chart.dropShadow.blur), this.donutSize = a2.globals.radialSize * parseInt(a2.config.plotOptions.pie.donut.size, 10) / 100;
    var s2 = a2.config.plotOptions.pie.customScale, r2 = a2.globals.gridWidth / 2, n2 = a2.globals.gridHeight / 2;
    this.translateX = r2 - r2 * s2, this.translateY = n2 - n2 * s2, this.dataLabelsGroup = new Mi(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(s2, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = a2.group({ class: "apexcharts-pie" });
    if (i2.globals.noData)
      return s2;
    for (var r2 = 0, n2 = 0;n2 < t3.length; n2++)
      r2 += v.negToZero(t3[n2]);
    var o2 = [], l2 = a2.group();
    r2 === 0 && (r2 = 0.00001), t3.forEach(function(t4) {
      e2.maxY = Math.max(e2.maxY, t4);
    }), i2.config.yaxis[0].max && (this.maxY = i2.config.yaxis[0].max), i2.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(s2);
    for (var h2 = 0;h2 < t3.length; h2++) {
      var c2 = this.fullAngle * v.negToZero(t3[h2]) / r2;
      o2.push(c2), this.chartType === "polarArea" ? (o2[h2] = this.fullAngle / t3.length, this.sliceSizes.push(i2.globals.radialSize * t3[h2] / this.maxY)) : this.sliceSizes.push(i2.globals.radialSize);
    }
    if (i2.globals.dataChanged) {
      for (var d2, u2 = 0, g2 = 0;g2 < i2.globals.previousPaths.length; g2++)
        u2 += v.negToZero(i2.globals.previousPaths[g2]);
      for (var p2 = 0;p2 < i2.globals.previousPaths.length; p2++)
        d2 = this.fullAngle * v.negToZero(i2.globals.previousPaths[p2]) / u2, this.prevSectorAngleArr.push(d2);
    }
    if (this.donutSize < 0 && (this.donutSize = 0), this.chartType === "donut") {
      var f2 = a2.drawCircle(this.donutSize);
      f2.attr({ cx: this.centerX, cy: this.centerY, fill: i2.config.plotOptions.pie.donut.background ? i2.config.plotOptions.pie.donut.background : "transparent" }), l2.add(f2);
    }
    var x2 = this.drawArcs(o2, t3);
    if (this.sliceLabels.forEach(function(t4) {
      x2.add(t4);
    }), l2.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i2.config.plotOptions.pie.customScale, ")") }), l2.add(x2), s2.add(l2), this.donutDataLabels.show) {
      var b2 = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      s2.add(b2);
    }
    return i2.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(s2), s2;
  } }, { key: "drawArcs", value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = new Mi(this.ctx), r2 = new ji(this.ctx), n2 = s2.group({ class: "apexcharts-slices" }), o2 = this.initialAngle, l2 = this.initialAngle, h2 = this.initialAngle, c2 = this.initialAngle;
    this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0;
    for (var d2 = 0;d2 < t3.length; d2++) {
      var u2 = s2.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: v.escapeString(i2.globals.seriesNames[d2]), rel: d2 + 1, "data:realIndex": d2 });
      n2.add(u2), l2 = c2, h2 = (o2 = h2) + t3[d2], c2 = l2 + this.prevSectorAngleArr[d2];
      var g2 = h2 < o2 ? this.fullAngle + h2 - o2 : h2 - o2, p2 = r2.fillPath({ seriesNumber: d2, size: this.sliceSizes[d2], value: e2[d2] }), f2 = this.getChangedPath(l2, c2), x2 = s2.drawPath({ d: f2, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d2] : this.lineColorArr, strokeWidth: 0, fill: p2, fillOpacity: i2.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d2) });
      if (x2.attr({ index: 0, j: d2 }), a2.setSelectionFilter(x2, 0, d2), i2.config.chart.dropShadow.enabled) {
        var b2 = i2.config.chart.dropShadow;
        a2.dropShadow(x2, b2, d2);
      }
      this.addListeners(x2, this.donutDataLabels), Mi.setAttrs(x2.node, { "data:angle": g2, "data:startAngle": o2, "data:strokeWidth": this.strokeWidth, "data:value": e2[d2] });
      var m2 = { x: 0, y: 0 };
      this.chartType === "pie" || this.chartType === "polarArea" ? m2 = v.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize / 1.25 + i2.config.plotOptions.pie.dataLabels.offset, (o2 + g2 / 2) % this.fullAngle) : this.chartType === "donut" && (m2 = v.polarToCartesian(this.centerX, this.centerY, (i2.globals.radialSize + this.donutSize) / 2 + i2.config.plotOptions.pie.dataLabels.offset, (o2 + g2 / 2) % this.fullAngle)), u2.add(x2);
      var y2 = 0;
      if (!this.initialAnim || i2.globals.resized || i2.globals.dataChanged ? this.animBeginArr.push(0) : ((y2 = g2 / this.fullAngle * i2.config.chart.animations.speed) === 0 && (y2 = 1), this.animDur = y2 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i2.globals.dataChanged ? this.animatePaths(x2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: o2, prevStartAngle: l2, prevEndAngle: c2, animateStartingPos: true, i: d2, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i2.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(x2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: o2, i: d2, totalItems: t3.length - 1, animBeginArr: this.animBeginArr, dur: y2 }), i2.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && x2.node.addEventListener("mouseup", this.pieClicked.bind(this, d2)), i2.globals.selectedDataPoints[0] !== undefined && i2.globals.selectedDataPoints[0].indexOf(d2) > -1 && this.pieClicked(d2), i2.config.dataLabels.enabled) {
        var { x: w2, y: k2 } = m2, A2 = 100 * g2 / this.fullAngle + "%";
        if (g2 !== 0 && i2.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t3[d2]) {
          var C2 = i2.config.dataLabels.formatter;
          C2 !== undefined && (A2 = C2(i2.globals.seriesPercent[d2][0], { seriesIndex: d2, w: i2 }));
          var S2 = i2.globals.dataLabels.style.colors[d2], L2 = s2.group({ class: "apexcharts-datalabels" }), M2 = s2.drawText({ x: w2, y: k2, text: A2, textAnchor: "middle", fontSize: i2.config.dataLabels.style.fontSize, fontFamily: i2.config.dataLabels.style.fontFamily, fontWeight: i2.config.dataLabels.style.fontWeight, foreColor: S2 });
          if (L2.add(M2), i2.config.dataLabels.dropShadow.enabled) {
            var P2 = i2.config.dataLabels.dropShadow;
            a2.dropShadow(M2, P2);
          }
          M2.node.classList.add("apexcharts-pie-label"), i2.config.chart.animations.animate && i2.globals.resized === false && (M2.node.classList.add("apexcharts-pie-label-delay"), M2.node.style.animationDelay = i2.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(L2);
        }
      }
    }
    return n2;
  } }, { key: "addListeners", value: function(t3, e2) {
    var i2 = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this, t3)), this.donutDataLabels.total.showAlways || (t3.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t3.node, e2)));
  } }, { key: "animatePaths", value: function(t3, e2) {
    var i2 = this.w, a2 = e2.endAngle < e2.startAngle ? this.fullAngle + e2.endAngle - e2.startAngle : e2.endAngle - e2.startAngle, s2 = a2, r2 = e2.startAngle, n2 = e2.startAngle;
    e2.prevStartAngle !== undefined && e2.prevEndAngle !== undefined && (r2 = e2.prevEndAngle, s2 = e2.prevEndAngle < e2.prevStartAngle ? this.fullAngle + e2.prevEndAngle - e2.prevStartAngle : e2.prevEndAngle - e2.prevStartAngle), e2.i === i2.config.series.length - 1 && (a2 + n2 > this.fullAngle ? e2.endAngle = e2.endAngle - (a2 + n2) : a2 + n2 < this.fullAngle && (e2.endAngle = e2.endAngle + (this.fullAngle - (a2 + n2)))), a2 === this.fullAngle && (a2 = this.fullAngle - 0.01), this.animateArc(t3, r2, n2, a2, s2, e2);
  } }, { key: "animateArc", value: function(t3, e2, i2, a2, s2, r2) {
    var n2, o2 = this, l2 = this.w, h2 = new y(this.ctx), c2 = r2.size;
    (isNaN(e2) || isNaN(s2)) && (e2 = i2, s2 = a2, r2.dur = 0);
    var d2 = a2, u2 = i2, g2 = e2 < i2 ? this.fullAngle + e2 - i2 : e2 - i2;
    l2.globals.dataChanged && r2.shouldSetPrevPaths && r2.prevEndAngle && (n2 = o2.getPiePath({ me: o2, startAngle: r2.prevStartAngle, angle: r2.prevEndAngle < r2.prevStartAngle ? this.fullAngle + r2.prevEndAngle - r2.prevStartAngle : r2.prevEndAngle - r2.prevStartAngle, size: c2 }), t3.attr({ d: n2 })), r2.dur !== 0 ? t3.animate(r2.dur, r2.animBeginArr[r2.i]).after(function() {
      o2.chartType !== "pie" && o2.chartType !== "donut" && o2.chartType !== "polarArea" || this.animate(l2.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": o2.strokeWidth }), r2.i === l2.config.series.length - 1 && h2.animationCompleted(t3);
    }).during(function(l3) {
      d2 = g2 + (a2 - g2) * l3, r2.animateStartingPos && (d2 = s2 + (a2 - s2) * l3, u2 = e2 - s2 + (i2 - (e2 - s2)) * l3), n2 = o2.getPiePath({ me: o2, startAngle: u2, angle: d2, size: c2 }), t3.node.setAttribute("data:pathOrig", n2), t3.attr({ d: n2 });
    }) : (n2 = o2.getPiePath({ me: o2, startAngle: u2, angle: a2, size: c2 }), r2.isTrack || (l2.globals.animationEnded = true), t3.node.setAttribute("data:pathOrig", n2), t3.attr({ d: n2, "stroke-width": o2.strokeWidth }));
  } }, { key: "pieClicked", value: function(t3) {
    var e2, i2 = this.w, a2 = this, s2 = a2.sliceSizes[t3] + (i2.config.plotOptions.pie.expandOnClick ? 4 : 0), r2 = i2.globals.dom.Paper.findOne(".apexcharts-".concat(a2.chartType.toLowerCase(), "-slice-").concat(t3));
    if (r2.attr("data:pieClicked") !== "true") {
      var n2 = i2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
      Array.prototype.forEach.call(n2, function(t4) {
        t4.setAttribute("data:pieClicked", "false");
        var e3 = t4.getAttribute("data:pathOrig");
        e3 && t4.setAttribute("d", e3);
      }), i2.globals.capturedDataPointIndex = t3, r2.attr("data:pieClicked", "true");
      var o2 = parseInt(r2.attr("data:startAngle"), 10), l2 = parseInt(r2.attr("data:angle"), 10);
      e2 = a2.getPiePath({ me: a2, startAngle: o2, angle: l2, size: s2 }), l2 !== 360 && r2.plot(e2);
    } else {
      r2.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r2.node, this.donutDataLabels);
      var h2 = r2.attr("data:pathOrig");
      r2.attr({ d: h2 });
    }
  } }, { key: "getChangedPath", value: function(t3, e2) {
    var i2 = "";
    return this.dynamicAnim && this.w.globals.dataChanged && (i2 = this.getPiePath({ me: this, startAngle: t3, angle: e2 - t3, size: this.size })), i2;
  } }, { key: "getPiePath", value: function(t3) {
    var e2, i2 = t3.me, a2 = t3.startAngle, s2 = t3.angle, r2 = t3.size, n2 = new Mi(this.ctx), o2 = a2, l2 = Math.PI * (o2 - 90) / 180, h2 = s2 + a2;
    Math.ceil(h2) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h2 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h2) > this.fullAngle && (h2 -= this.fullAngle);
    var c2 = Math.PI * (h2 - 90) / 180, d2 = i2.centerX + r2 * Math.cos(l2), u2 = i2.centerY + r2 * Math.sin(l2), g2 = i2.centerX + r2 * Math.cos(c2), p2 = i2.centerY + r2 * Math.sin(c2), f2 = v.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, h2), x2 = v.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, o2), b2 = s2 > 180 ? 1 : 0, m2 = ["M", d2, u2, "A", r2, r2, 0, b2, 1, g2, p2];
    return e2 = i2.chartType === "donut" ? [].concat(m2, ["L", f2.x, f2.y, "A", i2.donutSize, i2.donutSize, 0, b2, 0, x2.x, x2.y, "L", d2, u2, "z"]).join(" ") : i2.chartType === "pie" || i2.chartType === "polarArea" ? [].concat(m2, ["L", i2.centerX, i2.centerY, "L", d2, u2]).join(" ") : [].concat(m2).join(" "), n2.roundPathCorners(e2, 2 * this.strokeWidth);
  } }, { key: "drawPolarElements", value: function(t3) {
    var e2 = this.w, i2 = new ta(this.ctx), a2 = new Mi(this.ctx), s2 = new Ra(this.ctx), r2 = a2.group(), n2 = a2.group(), o2 = i2.niceScale(0, Math.ceil(this.maxY), 0), l2 = o2.result.reverse(), h2 = o2.result.length;
    this.maxY = o2.niceMax;
    for (var c2 = e2.globals.radialSize, d2 = c2 / (h2 - 1), u2 = 0;u2 < h2 - 1; u2++) {
      var g2 = a2.drawCircle(c2);
      if (g2.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e2.config.plotOptions.polarArea.rings.strokeWidth, stroke: e2.config.plotOptions.polarArea.rings.strokeColor }), e2.config.yaxis[0].show) {
        var p2 = s2.drawYAxisTexts(this.centerX, this.centerY - c2 + parseInt(e2.config.yaxis[0].labels.style.fontSize, 10) / 2, u2, l2[u2]);
        n2.add(p2);
      }
      r2.add(g2), c2 -= d2;
    }
    this.drawSpokes(t3), t3.add(r2), t3.add(n2);
  } }, { key: "renderInnerDataLabels", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx), r2 = e2.total.show;
    t3.node.innerHTML = "", t3.node.style.opacity = i2.opacity;
    var n2, o2, l2 = i2.centerX, h2 = this.donutDataLabels.total.label ? i2.centerY : i2.centerY - i2.centerY / 6;
    n2 = e2.name.color === undefined ? a2.globals.colors[0] : e2.name.color;
    var c2 = e2.name.fontSize, d2 = e2.name.fontFamily, u2 = e2.name.fontWeight;
    o2 = e2.value.color === undefined ? a2.config.chart.foreColor : e2.value.color;
    var g2 = e2.value.formatter, p2 = "", f2 = "";
    if (r2 ? (n2 = e2.total.color, c2 = e2.total.fontSize, d2 = e2.total.fontFamily, u2 = e2.total.fontWeight, f2 = this.donutDataLabels.total.label ? e2.total.label : "", p2 = e2.total.formatter(a2)) : a2.globals.series.length === 1 && (p2 = g2(a2.globals.series[0], a2), f2 = a2.globals.seriesNames[0]), f2 && (f2 = e2.name.formatter(f2, e2.total.show, a2)), e2.name.show) {
      var x2 = s2.drawText({ x: l2, y: h2 + parseFloat(e2.name.offsetY), text: f2, textAnchor: "middle", foreColor: n2, fontSize: c2, fontWeight: u2, fontFamily: d2 });
      x2.node.classList.add("apexcharts-datalabel-label"), t3.add(x2);
    }
    if (e2.value.show) {
      var b2 = e2.name.show ? parseFloat(e2.value.offsetY) + 16 : e2.value.offsetY, m2 = s2.drawText({ x: l2, y: h2 + b2, text: p2, textAnchor: "middle", foreColor: o2, fontWeight: e2.value.fontWeight, fontSize: e2.value.fontSize, fontFamily: e2.value.fontFamily });
      m2.node.classList.add("apexcharts-datalabel-value"), t3.add(m2);
    }
    return t3;
  } }, { key: "printInnerLabels", value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w;
    a2 ? s2 = t3.name.color === undefined ? r2.globals.colors[parseInt(a2.parentNode.getAttribute("rel"), 10) - 1] : t3.name.color : r2.globals.series.length > 1 && t3.total.show && (s2 = t3.total.color);
    var n2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), o2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
    i2 = (0, t3.value.formatter)(i2, r2), a2 || typeof t3.total.formatter != "function" || (i2 = t3.total.formatter(r2));
    var l2 = e2 === t3.total.label;
    e2 = this.donutDataLabels.total.label ? t3.name.formatter(e2, l2, r2) : "", n2 !== null && (n2.textContent = e2), o2 !== null && (o2.textContent = i2), n2 !== null && (n2.style.fill = s2);
  } }, { key: "printDataLabelsInner", value: function(t3, e2) {
    var i2 = this.w, a2 = t3.getAttribute("data:value"), s2 = i2.globals.seriesNames[parseInt(t3.parentNode.getAttribute("rel"), 10) - 1];
    i2.globals.series.length > 1 && this.printInnerLabels(e2, s2, a2, t3);
    var r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
    r2 !== null && (r2.style.opacity = 1);
  } }, { key: "drawSpokes", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = i2.config.plotOptions.polarArea.spokes;
    if (s2.strokeWidth !== 0) {
      for (var r2 = [], n2 = 360 / i2.globals.series.length, o2 = 0;o2 < i2.globals.series.length; o2++)
        r2.push(v.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize, i2.config.plotOptions.pie.startAngle + n2 * o2));
      r2.forEach(function(i3, r3) {
        var n3 = a2.drawLine(i3.x, i3.y, e2.centerX, e2.centerY, Array.isArray(s2.connectorColors) ? s2.connectorColors[r3] : s2.connectorColors);
        t3.add(n3);
      });
    }
  } }, { key: "revertDataLabelsInner", value: function() {
    var t3 = this.w;
    if (this.donutDataLabels.show) {
      var e2 = t3.globals.dom.Paper.findOne(".apexcharts-datalabels-group"), i2 = this.renderInnerDataLabels(e2, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      t3.globals.dom.Paper.findOne(".apexcharts-radialbar, .apexcharts-pie").add(i2);
    }
  } }]), t2;
}();
var Ya = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var a2 = this.w;
    this.graphics = new Mi(this.ctx), this.lineColorArr = a2.globals.stroke.colors !== undefined ? a2.globals.stroke.colors : a2.globals.colors, this.defaultSize = a2.globals.svgHeight < a2.globals.svgWidth ? a2.globals.gridHeight : a2.globals.gridWidth, this.isLog = a2.config.yaxis[0].logarithmic, this.logBase = a2.config.yaxis[0].logBase, this.coreUtils = new Pi(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, a2.globals.maxY, 0) : a2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : a2.globals.minY, this.polygons = a2.config.plotOptions.radar.polygons, this.strokeWidth = a2.config.stroke.show ? a2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a2.config.chart.dropShadow.blur, a2.config.xaxis.labels.show && (this.size = this.size - a2.globals.xAxisLabelsWidth / 1.75), a2.config.plotOptions.radar.size !== undefined && (this.size = a2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new ji(this.ctx), s2 = [], r2 = new qi(this.ctx);
    t3.length && (this.dataPointsLen = t3[i2.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
    var n2 = i2.globals.gridWidth / 2, o2 = i2.globals.gridHeight / 2, l2 = n2 + i2.config.plotOptions.radar.offsetX, h2 = o2 + i2.config.plotOptions.radar.offsetY, c2 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(l2 || 0, ", ").concat(h2 || 0, ")") }), d2 = [], g2 = null, p2 = null;
    if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t3.forEach(function(t4, n3) {
      var o3 = t4.length === i2.globals.dataPoints, l3 = e2.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": o3, seriesName: v.escapeString(i2.globals.seriesNames[n3]), rel: n3 + 1, "data:realIndex": n3 });
      e2.dataRadiusOfPercent[n3] = [], e2.dataRadius[n3] = [], e2.angleArr[n3] = [], t4.forEach(function(t5, i3) {
        var a3 = Math.abs(e2.maxValue - e2.minValue);
        t5 -= e2.minValue, e2.isLog && (t5 = e2.coreUtils.getLogVal(e2.logBase, t5, 0)), e2.dataRadiusOfPercent[n3][i3] = t5 / a3, e2.dataRadius[n3][i3] = e2.dataRadiusOfPercent[n3][i3] * e2.size, e2.angleArr[n3][i3] = i3 * e2.disAngle;
      }), d2 = e2.getDataPointsPos(e2.dataRadius[n3], e2.angleArr[n3]);
      var h3 = e2.createPaths(d2, { x: 0, y: 0 });
      g2 = e2.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p2 = e2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": n3 }), i2.globals.delayedElements.push({ el: g2.node, index: n3 });
      var c3 = { i: n3, realIndex: n3, animationDelay: n3, initialSpeed: i2.config.chart.animations.speed, dataChangeSpeed: i2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: i2.globals.stroke.colors[n3], strokeLineCap: i2.config.stroke.lineCap }, f3 = null;
      i2.globals.previousPaths.length > 0 && (f3 = e2.getPreviousPath(n3));
      for (var x2 = 0;x2 < h3.linePathsTo.length; x2++) {
        var b2 = e2.graphics.renderPaths(u(u({}, c3), {}, { pathFrom: f3 === null ? h3.linePathsFrom[x2] : f3, pathTo: h3.linePathsTo[x2], strokeWidth: Array.isArray(e2.strokeWidth) ? e2.strokeWidth[n3] : e2.strokeWidth, fill: "none", drawShadow: false }));
        l3.add(b2);
        var m2 = a2.fillPath({ seriesNumber: n3 }), y2 = e2.graphics.renderPaths(u(u({}, c3), {}, { pathFrom: f3 === null ? h3.areaPathsFrom[x2] : f3, pathTo: h3.areaPathsTo[x2], strokeWidth: 0, fill: m2, drawShadow: false }));
        if (i2.config.chart.dropShadow.enabled) {
          var w2 = new Li(e2.ctx), k2 = i2.config.chart.dropShadow;
          w2.dropShadow(y2, Object.assign({}, k2, { noUserSpaceOnUse: true }), n3);
        }
        l3.add(y2);
      }
      t4.forEach(function(t5, a3) {
        var s3 = new Vi(e2.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n3, dataPointIndex: a3 }), o4 = e2.graphics.drawMarker(d2[a3].x, d2[a3].y, s3);
        o4.attr("rel", a3), o4.attr("j", a3), o4.attr("index", n3), o4.node.setAttribute("default-marker-size", s3.pSize);
        var h4 = e2.graphics.group({ class: "apexcharts-series-markers" });
        h4 && h4.add(o4), g2.add(h4), l3.add(g2);
        var c4 = i2.config.dataLabels;
        if (c4.enabled) {
          var f4 = c4.formatter(i2.globals.series[n3][a3], { seriesIndex: n3, dataPointIndex: a3, w: i2 });
          r2.plotDataLabelsText({ x: d2[a3].x, y: d2[a3].y, text: f4, textAnchor: "middle", i: n3, j: n3, parent: p2, offsetCorrection: false, dataLabelsConfig: u({}, c4) });
        }
        l3.add(p2);
      }), s2.push(l3);
    }), this.drawPolygons({ parent: c2 }), i2.config.xaxis.labels.show) {
      var f2 = this.drawXAxisTexts();
      c2.add(f2);
    }
    return s2.forEach(function(t4) {
      c2.add(t4);
    }), c2.add(this.yaxisLabels), c2;
  } }, { key: "drawPolygons", value: function(t3) {
    for (var e2 = this, i2 = this.w, a2 = t3.parent, s2 = new Ra(this.ctx), r2 = i2.globals.yAxisScale[0].result.reverse(), n2 = r2.length, o2 = [], l2 = this.size / (n2 - 1), h2 = 0;h2 < n2; h2++)
      o2[h2] = l2 * h2;
    o2.reverse();
    var c2 = [], d2 = [];
    o2.forEach(function(t4, i3) {
      var a3 = v.getPolygonPos(t4, e2.dataPointsLen), s3 = "";
      a3.forEach(function(t5, a4) {
        if (i3 === 0) {
          var r3 = e2.graphics.drawLine(t5.x, t5.y, 0, 0, Array.isArray(e2.polygons.connectorColors) ? e2.polygons.connectorColors[a4] : e2.polygons.connectorColors);
          d2.push(r3);
        }
        a4 === 0 && e2.yaxisLabelsTextsPos.push({ x: t5.x, y: t5.y }), s3 += t5.x + "," + t5.y + " ";
      }), c2.push(s3);
    }), c2.forEach(function(t4, s3) {
      var r3 = e2.polygons.strokeColors, n3 = e2.polygons.strokeWidth, o3 = e2.graphics.drawPolygon(t4, Array.isArray(r3) ? r3[s3] : r3, Array.isArray(n3) ? n3[s3] : n3, i2.globals.radarPolygons.fill.colors[s3]);
      a2.add(o3);
    }), d2.forEach(function(t4) {
      a2.add(t4);
    }), i2.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t4, i3) {
      var a3 = s2.drawYAxisTexts(t4.x, t4.y, i3, r2[i3]);
      e2.yaxisLabels.add(a3);
    });
  } }, { key: "drawXAxisTexts", value: function() {
    var t3 = this, e2 = this.w, i2 = e2.config.xaxis.labels, a2 = this.graphics.group({ class: "apexcharts-xaxis" }), s2 = v.getPolygonPos(this.size, this.dataPointsLen);
    return e2.globals.labels.forEach(function(r2, n2) {
      var o2 = e2.config.xaxis.labels.formatter, l2 = new qi(t3.ctx);
      if (s2[n2]) {
        var h2 = t3.getTextPos(s2[n2], t3.size), c2 = o2(r2, { seriesIndex: -1, dataPointIndex: n2, w: e2 });
        l2.plotDataLabelsText({ x: h2.newX, y: h2.newY, text: c2, textAnchor: h2.textAnchor, i: n2, j: n2, parent: a2, className: "apexcharts-xaxis-label", color: Array.isArray(i2.style.colors) && i2.style.colors[n2] ? i2.style.colors[n2] : "#a8a8a8", dataLabelsConfig: u({ textAnchor: h2.textAnchor, dropShadow: { enabled: false } }, i2), offsetCorrection: false }).on("click", function(i3) {
          if (typeof e2.config.chart.events.xAxisLabelClick == "function") {
            var a3 = Object.assign({}, e2, { labelIndex: n2 });
            e2.config.chart.events.xAxisLabelClick(i3, t3.ctx, a3);
          }
        });
      }
    }), a2;
  } }, { key: "createPaths", value: function(t3, e2) {
    var i2 = this, a2 = [], s2 = [], r2 = [], n2 = [];
    if (t3.length) {
      s2 = [this.graphics.move(e2.x, e2.y)], n2 = [this.graphics.move(e2.x, e2.y)];
      var o2 = this.graphics.move(t3[0].x, t3[0].y), l2 = this.graphics.move(t3[0].x, t3[0].y);
      t3.forEach(function(e3, a3) {
        o2 += i2.graphics.line(e3.x, e3.y), l2 += i2.graphics.line(e3.x, e3.y), a3 === t3.length - 1 && (o2 += "Z", l2 += "Z");
      }), a2.push(o2), r2.push(l2);
    }
    return { linePathsFrom: s2, linePathsTo: a2, areaPathsFrom: n2, areaPathsTo: r2 };
  } }, { key: "getTextPos", value: function(t3, e2) {
    var i2 = "middle", a2 = t3.x, s2 = t3.y;
    return Math.abs(t3.x) >= 10 ? t3.x > 0 ? (i2 = "start", a2 += 10) : t3.x < 0 && (i2 = "end", a2 -= 10) : i2 = "middle", Math.abs(t3.y) >= e2 - 10 && (t3.y < 0 ? s2 -= 10 : t3.y > 0 && (s2 += 10)), { textAnchor: i2, newX: a2, newY: s2 };
  } }, { key: "getPreviousPath", value: function(t3) {
    for (var e2 = this.w, i2 = null, a2 = 0;a2 < e2.globals.previousPaths.length; a2++) {
      var s2 = e2.globals.previousPaths[a2];
      s2.paths.length > 0 && parseInt(s2.realIndex, 10) === parseInt(t3, 10) && e2.globals.previousPaths[a2].paths[0] !== undefined && (i2 = e2.globals.previousPaths[a2].paths[0].d);
    }
    return i2;
  } }, { key: "getDataPointsPos", value: function(t3, e2) {
    var i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dataPointsLen;
    t3 = t3 || [], e2 = e2 || [];
    for (var a2 = [], s2 = 0;s2 < i2; s2++) {
      var r2 = {};
      r2.x = t3[s2] * Math.sin(e2[s2]), r2.y = -t3[s2] * Math.cos(e2[s2]), a2.push(r2);
    }
    return a2;
  } }]), t2;
}();
var Ha = function(t2) {
  h(r2, Ea);
  var a2 = n(r2);
  function r2(t3) {
    var s2;
    i(this, r2), (s2 = a2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.animBeginArr = [0], s2.animDur = 0;
    var n2 = s2.w;
    return s2.startAngle = n2.config.plotOptions.radialBar.startAngle, s2.endAngle = n2.config.plotOptions.radialBar.endAngle, s2.totalAngle = Math.abs(n2.config.plotOptions.radialBar.endAngle - n2.config.plotOptions.radialBar.startAngle), s2.trackStartAngle = n2.config.plotOptions.radialBar.track.startAngle, s2.trackEndAngle = n2.config.plotOptions.radialBar.track.endAngle, s2.barLabels = s2.w.config.plotOptions.radialBar.barLabels, s2.donutDataLabels = s2.w.config.plotOptions.radialBar.dataLabels, s2.radialDataLabels = s2.donutDataLabels, s2.trackStartAngle || (s2.trackStartAngle = s2.startAngle), s2.trackEndAngle || (s2.trackEndAngle = s2.endAngle), s2.endAngle === 360 && (s2.endAngle = 359.99), s2.margin = parseInt(n2.config.plotOptions.radialBar.track.margin, 10), s2.onBarLabelClick = s2.onBarLabelClick.bind(e(s2)), s2;
  }
  return s(r2, [{ key: "draw", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = i2.group({ class: "apexcharts-radialbar" });
    if (e2.globals.noData)
      return a3;
    var s2 = i2.group(), r3 = this.defaultSize / 2, n2 = e2.globals.gridWidth / 2, o2 = this.defaultSize / 2.05;
    e2.config.chart.sparkline.enabled || (o2 = o2 - e2.config.stroke.width - e2.config.chart.dropShadow.blur);
    var l2 = e2.globals.fill.colors;
    if (e2.config.plotOptions.radialBar.track.show) {
      var h2 = this.drawTracks({ size: o2, centerX: n2, centerY: r3, colorArr: l2, series: t3 });
      s2.add(h2);
    }
    var c2 = this.drawArcs({ size: o2, centerX: n2, centerY: r3, colorArr: l2, series: t3 }), d2 = 360;
    e2.config.plotOptions.radialBar.startAngle < 0 && (d2 = this.totalAngle);
    var u2 = (360 - d2) / 360;
    if (e2.globals.radialSize = o2 - o2 * u2, this.radialDataLabels.value.show) {
      var g2 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
      e2.globals.radialSize += g2 * u2;
    }
    return s2.add(c2.g), e2.config.plotOptions.radialBar.hollow.position === "front" && (c2.g.add(c2.elHollow), c2.dataLabels && c2.g.add(c2.dataLabels)), a3.add(s2), a3;
  } }, { key: "drawTracks", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = i2.group({ class: "apexcharts-tracks" }), s2 = new Li(this.ctx), r3 = new ji(this.ctx), n2 = this.getStrokeWidth(t3);
    t3.size = t3.size - n2 / 2;
    for (var o2 = 0;o2 < t3.series.length; o2++) {
      var l2 = i2.group({ class: "apexcharts-radialbar-track apexcharts-track" });
      a3.add(l2), l2.attr({ rel: o2 + 1 }), t3.size = t3.size - n2 - this.margin;
      var h2 = e2.config.plotOptions.radialBar.track, c2 = r3.fillPath({ seriesNumber: 0, size: t3.size, fillColors: Array.isArray(h2.background) ? h2.background[o2] : h2.background, solid: true }), d2 = this.trackStartAngle, u2 = this.trackEndAngle;
      Math.abs(u2) + Math.abs(d2) >= 360 && (u2 = 360 - Math.abs(this.startAngle) - 0.1);
      var g2 = i2.drawPath({ d: "", stroke: c2, strokeWidth: n2 * parseInt(h2.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h2.opacity, classes: "apexcharts-radialbar-area" });
      if (h2.dropShadow.enabled) {
        var p2 = h2.dropShadow;
        s2.dropShadow(g2, p2);
      }
      l2.add(g2), g2.attr("id", "apexcharts-radialbarTrack-" + o2), this.animatePaths(g2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: u2, startAngle: d2, size: t3.size, i: o2, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true });
    }
    return a3;
  } }, { key: "drawArcs", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = new ji(this.ctx), s2 = new Li(this.ctx), r3 = i2.group(), n2 = this.getStrokeWidth(t3);
    t3.size = t3.size - n2 / 2;
    var o2 = e2.config.plotOptions.radialBar.hollow.background, l2 = t3.size - n2 * t3.series.length - this.margin * t3.series.length - n2 * parseInt(e2.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h2 = l2 - e2.config.plotOptions.radialBar.hollow.margin;
    e2.config.plotOptions.radialBar.hollow.image !== undefined && (o2 = this.drawHollowImage(t3, r3, l2, o2));
    var c2 = this.drawHollow({ size: h2, centerX: t3.centerX, centerY: t3.centerY, fill: o2 || "transparent" });
    if (e2.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      var d2 = e2.config.plotOptions.radialBar.hollow.dropShadow;
      s2.dropShadow(c2, d2);
    }
    var u2 = 1;
    !this.radialDataLabels.total.show && e2.globals.series.length > 1 && (u2 = 0);
    var g2 = null;
    if (this.radialDataLabels.show) {
      var p2 = e2.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
      g2 = this.renderInnerDataLabels(p2, this.radialDataLabels, { hollowSize: l2, centerX: t3.centerX, centerY: t3.centerY, opacity: u2 });
    }
    e2.config.plotOptions.radialBar.hollow.position === "back" && (r3.add(c2), g2 && r3.add(g2));
    var f2 = false;
    e2.config.plotOptions.radialBar.inverseOrder && (f2 = true);
    for (var x2 = f2 ? t3.series.length - 1 : 0;f2 ? x2 >= 0 : x2 < t3.series.length; f2 ? x2-- : x2++) {
      var b2 = i2.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: v.escapeString(e2.globals.seriesNames[x2]) });
      r3.add(b2), b2.attr({ rel: x2 + 1, "data:realIndex": x2 }), this.ctx.series.addCollapsedClassToSeries(b2, x2), t3.size = t3.size - n2 - this.margin;
      var m2 = a3.fillPath({ seriesNumber: x2, size: t3.size, value: t3.series[x2] }), y2 = this.startAngle, w2 = undefined, k2 = v.negToZero(t3.series[x2] > 100 ? 100 : t3.series[x2]) / 100, A2 = Math.round(this.totalAngle * k2) + this.startAngle, C2 = undefined;
      e2.globals.dataChanged && (w2 = this.startAngle, C2 = Math.round(this.totalAngle * v.negToZero(e2.globals.previousPaths[x2]) / 100) + w2), Math.abs(A2) + Math.abs(y2) > 360 && (A2 -= 0.01), Math.abs(C2) + Math.abs(w2) > 360 && (C2 -= 0.01);
      var S2 = A2 - y2, L2 = Array.isArray(e2.config.stroke.dashArray) ? e2.config.stroke.dashArray[x2] : e2.config.stroke.dashArray, M2 = i2.drawPath({ d: "", stroke: m2, strokeWidth: n2, fill: "none", fillOpacity: e2.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + x2, strokeDashArray: L2 });
      if (Mi.setAttrs(M2.node, { "data:angle": S2, "data:value": t3.series[x2] }), e2.config.chart.dropShadow.enabled) {
        var P2 = e2.config.chart.dropShadow;
        s2.dropShadow(M2, P2, x2);
      }
      if (s2.setSelectionFilter(M2, 0, x2), this.addListeners(M2, this.radialDataLabels), b2.add(M2), M2.attr({ index: 0, j: x2 }), this.barLabels.enabled) {
        var I2 = v.polarToCartesian(t3.centerX, t3.centerY, t3.size, y2), T2 = this.barLabels.formatter(e2.globals.seriesNames[x2], { seriesIndex: x2, w: e2 }), z2 = ["apexcharts-radialbar-label"];
        this.barLabels.onClick || z2.push("apexcharts-no-click");
        var X2 = this.barLabels.useSeriesColors ? e2.globals.colors[x2] : e2.config.chart.foreColor;
        X2 || (X2 = e2.config.chart.foreColor);
        var R2 = I2.x + this.barLabels.offsetX, E2 = I2.y + this.barLabels.offsetY, Y2 = i2.drawText({ x: R2, y: E2, text: T2, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: X2, cssClass: z2.join(" ") });
        Y2.on("click", this.onBarLabelClick), Y2.attr({ rel: x2 + 1 }), y2 !== 0 && Y2.attr({ "transform-origin": "".concat(R2, " ").concat(E2), transform: "rotate(".concat(y2, " 0 0)") }), b2.add(Y2);
      }
      var H2 = 0;
      !this.initialAnim || e2.globals.resized || e2.globals.dataChanged || (H2 = e2.config.chart.animations.speed), e2.globals.dataChanged && (H2 = e2.config.chart.animations.dynamicAnimation.speed), this.animDur = H2 / (1.2 * t3.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(M2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: A2, startAngle: y2, prevEndAngle: C2, prevStartAngle: w2, size: t3.size, i: x2, totalItems: 2, animBeginArr: this.animBeginArr, dur: H2, shouldSetPrevPaths: true });
    }
    return { g: r3, elHollow: c2, dataLabels: g2 };
  } }, { key: "drawHollow", value: function(t3) {
    var e2 = new Mi(this.ctx).drawCircle(2 * t3.size);
    return e2.attr({ class: "apexcharts-radialbar-hollow", cx: t3.centerX, cy: t3.centerY, r: t3.size, fill: t3.fill }), e2;
  } }, { key: "drawHollowImage", value: function(t3, e2, i2, a3) {
    var s2 = this.w, r3 = new ji(this.ctx), n2 = v.randomId(), o2 = s2.config.plotOptions.radialBar.hollow.image;
    if (s2.config.plotOptions.radialBar.hollow.imageClipped)
      r3.clippedImgArea({ width: i2, height: i2, image: o2, patternID: "pattern".concat(s2.globals.cuid).concat(n2) }), a3 = "url(#pattern".concat(s2.globals.cuid).concat(n2, ")");
    else {
      var l2 = s2.config.plotOptions.radialBar.hollow.imageWidth, h2 = s2.config.plotOptions.radialBar.hollow.imageHeight;
      if (l2 === undefined && h2 === undefined) {
        var c2 = s2.globals.dom.Paper.image(o2, function(e3) {
          this.move(t3.centerX - e3.width / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - e3.height / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY);
        });
        e2.add(c2);
      } else {
        var d2 = s2.globals.dom.Paper.image(o2, function(e3) {
          this.move(t3.centerX - l2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - h2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l2, h2);
        });
        e2.add(d2);
      }
    }
    return a3;
  } }, { key: "getStrokeWidth", value: function(t3) {
    var e2 = this.w;
    return t3.size * (100 - parseInt(e2.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t3.series.length + 1) - this.margin;
  } }, { key: "onBarLabelClick", value: function(t3) {
    var e2 = parseInt(t3.target.getAttribute("rel"), 10) - 1, i2 = this.barLabels.onClick, a3 = this.w;
    i2 && i2(a3.globals.seriesNames[e2], { w: a3, seriesIndex: e2 });
  } }]), r2;
}();
var Oa = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3) {
    var i2 = this.w, a3 = new Mi(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t3, this.seriesRangeStart = i2.globals.seriesRangeStart, this.seriesRangeEnd = i2.globals.seriesRangeEnd, this.barHelpers.initVariables(t3);
    for (var s2 = a3.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), r2 = 0;r2 < t3.length; r2++) {
      var n2, o2, l2, h2, c2 = undefined, d2 = undefined, g2 = i2.globals.comboCharts ? e3[r2] : r2, p2 = this.barHelpers.getGroupIndex(g2).columnGroupIndex, f2 = a3.group({ class: "apexcharts-series", seriesName: v.escapeString(i2.globals.seriesNames[g2]), rel: r2 + 1, "data:realIndex": g2 });
      this.ctx.series.addCollapsedClassToSeries(f2, g2), t3[r2].length > 0 && (this.visibleI = this.visibleI + 1);
      var x2 = 0, b2 = 0, m2 = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i2.globals.seriesYAxisReverseMap[g2][0], m2 = g2);
      var y2 = this.barHelpers.initialPositions(g2);
      d2 = y2.y, h2 = y2.zeroW, c2 = y2.x, b2 = y2.barWidth, x2 = y2.barHeight, n2 = y2.xDivision, o2 = y2.yDivision, l2 = y2.zeroH;
      for (var w2 = a3.group({ class: "apexcharts-datalabels", "data:realIndex": g2 }), k2 = a3.group({ class: "apexcharts-rangebar-goals-markers" }), A2 = 0;A2 < i2.globals.dataPoints; A2++) {
        var C2 = this.barHelpers.getStrokeWidth(r2, A2, g2), S2 = this.seriesRangeStart[r2][A2], L2 = this.seriesRangeEnd[r2][A2], M2 = null, P2 = null, I2 = null, T2 = { x: c2, y: d2, strokeWidth: C2, elSeries: f2 }, z2 = this.seriesLen;
        if (i2.config.plotOptions.bar.rangeBarGroupRows && (z2 = 1), i2.config.series[r2].data[A2] === undefined)
          break;
        if (this.isHorizontal) {
          I2 = d2 + x2 * this.visibleI;
          var X2 = (o2 - x2 * z2) / 2;
          if (i2.config.series[r2].data[A2].x) {
            var R2 = this.detectOverlappingBars({ i: r2, j: A2, barYPosition: I2, srty: X2, barHeight: x2, yDivision: o2, initPositions: y2 });
            x2 = R2.barHeight, I2 = R2.barYPosition;
          }
          b2 = (M2 = this.drawRangeBarPaths(u({ indexes: { i: r2, j: A2, realIndex: g2 }, barHeight: x2, barYPosition: I2, zeroW: h2, yDivision: o2, y1: S2, y2: L2 }, T2))).barWidth;
        } else {
          i2.globals.isXNumeric && (c2 = (i2.globals.seriesX[r2][A2] - i2.globals.minX) / this.xRatio - b2 / 2), P2 = c2 + b2 * this.visibleI;
          var E2 = (n2 - b2 * z2) / 2;
          if (i2.config.series[r2].data[A2].x) {
            var Y2 = this.detectOverlappingBars({ i: r2, j: A2, barXPosition: P2, srtx: E2, barWidth: b2, xDivision: n2, initPositions: y2 });
            b2 = Y2.barWidth, P2 = Y2.barXPosition;
          }
          x2 = (M2 = this.drawRangeColumnPaths(u({ indexes: { i: r2, j: A2, realIndex: g2, translationsIndex: m2 }, barWidth: b2, barXPosition: P2, zeroH: l2, xDivision: n2 }, T2))).barHeight;
        }
        var H2 = this.barHelpers.drawGoalLine({ barXPosition: M2.barXPosition, barYPosition: I2, goalX: M2.goalX, goalY: M2.goalY, barHeight: x2, barWidth: b2 });
        H2 && k2.add(H2), d2 = M2.y, c2 = M2.x;
        var O2 = this.barHelpers.getPathFillColor(t3, r2, A2, g2);
        this.renderSeries({ realIndex: g2, pathFill: O2.color, lineFill: O2.useRangeColor ? O2.color : i2.globals.stroke.colors[g2], j: A2, i: r2, x: c2, y: d2, y1: S2, y2: L2, pathFrom: M2.pathFrom, pathTo: M2.pathTo, strokeWidth: C2, elSeries: f2, series: t3, barHeight: x2, barWidth: b2, barXPosition: P2, barYPosition: I2, columnGroupIndex: p2, elDataLabelsWrap: w2, elGoalsMarkers: k2, visibleSeries: this.visibleI, type: "rangebar" });
      }
      s2.add(f2);
    }
    return s2;
  } }, { key: "detectOverlappingBars", value: function(t3) {
    var { i: e3, j: i2, barYPosition: a3, barXPosition: s2, srty: r2, srtx: n2, barHeight: o2, barWidth: l2, yDivision: h2, xDivision: c2, initPositions: d2 } = t3, u2 = this.w, g2 = [], p2 = u2.config.series[e3].data[i2].rangeName, f2 = u2.config.series[e3].data[i2].x, x2 = Array.isArray(f2) ? f2.join(" ") : f2, b2 = u2.globals.labels.map(function(t4) {
      return Array.isArray(t4) ? t4.join(" ") : t4;
    }).indexOf(x2), m2 = u2.globals.seriesRange[e3].findIndex(function(t4) {
      return t4.x === x2 && t4.overlaps.length > 0;
    });
    return this.isHorizontal ? (a3 = u2.config.plotOptions.bar.rangeBarGroupRows ? r2 + h2 * b2 : r2 + o2 * this.visibleI + h2 * b2, m2 > -1 && !u2.config.plotOptions.bar.rangeBarOverlap && (g2 = u2.globals.seriesRange[e3][m2].overlaps).indexOf(p2) > -1 && (a3 = (o2 = d2.barHeight / g2.length) * this.visibleI + h2 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + o2 * (this.visibleI + g2.indexOf(p2)) + h2 * b2)) : (b2 > -1 && !u2.globals.timescaleLabels.length && (s2 = u2.config.plotOptions.bar.rangeBarGroupRows ? n2 + c2 * b2 : n2 + l2 * this.visibleI + c2 * b2), m2 > -1 && !u2.config.plotOptions.bar.rangeBarOverlap && (g2 = u2.globals.seriesRange[e3][m2].overlaps).indexOf(p2) > -1 && (s2 = (l2 = d2.barWidth / g2.length) * this.visibleI + c2 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l2 * (this.visibleI + g2.indexOf(p2)) + c2 * b2)), { barYPosition: a3, barXPosition: s2, barHeight: o2, barWidth: l2 };
  } }, { key: "drawRangeColumnPaths", value: function(t3) {
    var { indexes: e3, x: i2, xDivision: a3, barWidth: s2, barXPosition: r2, zeroH: n2 } = t3, o2 = this.w, l2 = e3.i, h2 = e3.j, c2 = e3.realIndex, d2 = e3.translationsIndex, u2 = this.yRatio[d2], g2 = this.getRangeValue(c2, h2), p2 = Math.min(g2.start, g2.end), f2 = Math.max(g2.start, g2.end);
    this.series[l2][h2] === undefined || this.series[l2][h2] === null ? p2 = n2 : (p2 = n2 - p2 / u2, f2 = n2 - f2 / u2);
    var x2 = Math.abs(f2 - p2), b2 = this.barHelpers.getColumnPaths({ barXPosition: r2, barWidth: s2, y1: p2, y2: f2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: c2, i: c2, j: h2, w: o2 });
    if (o2.globals.isXNumeric) {
      var m2 = this.getBarXForNumericXAxis({ x: i2, j: h2, realIndex: c2, barWidth: s2 });
      i2 = m2.x, r2 = m2.barXPosition;
    } else
      i2 += a3;
    return { pathTo: b2.pathTo, pathFrom: b2.pathFrom, barHeight: x2, x: i2, y: g2.start < 0 && g2.end < 0 ? p2 : f2, goalY: this.barHelpers.getGoalValues("y", null, n2, l2, h2, d2), barXPosition: r2 };
  } }, { key: "preventBarOverflow", value: function(t3) {
    var e3 = this.w;
    return t3 < 0 && (t3 = 0), t3 > e3.globals.gridWidth && (t3 = e3.globals.gridWidth), t3;
  } }, { key: "drawRangeBarPaths", value: function(t3) {
    var { indexes: e3, y: i2, y1: a3, y2: s2, yDivision: r2, barHeight: n2, barYPosition: o2, zeroW: l2 } = t3, h2 = this.w, c2 = e3.realIndex, d2 = e3.j, u2 = this.preventBarOverflow(l2 + a3 / this.invertedYRatio), g2 = this.preventBarOverflow(l2 + s2 / this.invertedYRatio), p2 = this.getRangeValue(c2, d2), f2 = Math.abs(g2 - u2), x2 = this.barHelpers.getBarpaths({ barYPosition: o2, barHeight: n2, x1: u2, x2: g2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: c2, realIndex: c2, j: d2, w: h2 });
    return h2.globals.isXNumeric || (i2 += r2), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, barWidth: f2, x: p2.start < 0 && p2.end < 0 ? u2 : g2, goalX: this.barHelpers.getGoalValues("x", l2, null, c2, d2), y: i2 };
  } }, { key: "getRangeValue", value: function(t3, e3) {
    var i2 = this.w;
    return { start: i2.globals.seriesRangeStart[t3][e3], end: i2.globals.seriesRangeEnd[t3][e3] };
  } }]), a2;
}();
var Fa = function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.lineCtx = e2;
  }
  return s(t2, [{ key: "sameValueSeriesFix", value: function(t3, e2) {
    var i2 = this.w;
    if ((i2.config.fill.type === "gradient" || i2.config.fill.type[t3] === "gradient") && new Pi(this.lineCtx.ctx, i2).seriesHaveSameValues(t3)) {
      var a2 = e2[t3].slice();
      a2[a2.length - 1] = a2[a2.length - 1] + 0.000001, e2[t3] = a2;
    }
    return e2;
  } }, { key: "calculatePoints", value: function(t3) {
    var { series: e2, realIndex: i2, x: a2, y: s2, i: r2, j: n2, prevY: o2 } = t3, l2 = this.w, h2 = [], c2 = [], d2 = this.lineCtx.categoryAxisCorrection + l2.config.markers.offsetX;
    return l2.globals.isXNumeric && (d2 = (l2.globals.seriesX[i2][0] - l2.globals.minX) / this.lineCtx.xRatio + l2.config.markers.offsetX), n2 === 0 && (h2.push(d2), c2.push(v.isNumber(e2[r2][0]) ? o2 + l2.config.markers.offsetY : null)), h2.push(a2 + l2.config.markers.offsetX), c2.push(v.isNumber(e2[r2][n2 + 1]) ? s2 + l2.config.markers.offsetY : null), { x: h2, y: c2 };
  } }, { key: "checkPreviousPaths", value: function(t3) {
    for (var { pathFromLine: e2, pathFromArea: i2, realIndex: a2 } = t3, s2 = this.w, r2 = 0;r2 < s2.globals.previousPaths.length; r2++) {
      var n2 = s2.globals.previousPaths[r2];
      (n2.type === "line" || n2.type === "area") && n2.paths.length > 0 && parseInt(n2.realIndex, 10) === parseInt(a2, 10) && (n2.type === "line" ? (this.lineCtx.appendPathFrom = false, e2 = s2.globals.previousPaths[r2].paths[0].d) : n2.type === "area" && (this.lineCtx.appendPathFrom = false, i2 = s2.globals.previousPaths[r2].paths[0].d, s2.config.stroke.show && s2.globals.previousPaths[r2].paths[1] && (e2 = s2.globals.previousPaths[r2].paths[1].d)));
    }
    return { pathFromLine: e2, pathFromArea: i2 };
  } }, { key: "determineFirstPrevY", value: function(t3) {
    var e2, i2, a2, s2 = t3.i, r2 = t3.realIndex, n2 = t3.series, o2 = t3.prevY, l2 = t3.lineYPosition, h2 = t3.translationsIndex, c2 = this.w, d2 = c2.config.chart.stacked && !c2.globals.comboCharts || c2.config.chart.stacked && c2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((e2 = this.w.config.series[r2]) === null || e2 === undefined ? undefined : e2.type) === "bar" || ((i2 = this.w.config.series[r2]) === null || i2 === undefined ? undefined : i2.type) === "column");
    if (((a2 = n2[s2]) === null || a2 === undefined ? undefined : a2[0]) !== undefined)
      o2 = (l2 = d2 && s2 > 0 ? this.lineCtx.prevSeriesY[s2 - 1][0] : this.lineCtx.zeroY) - n2[s2][0] / this.lineCtx.yRatio[h2] + 2 * (this.lineCtx.isReversed ? n2[s2][0] / this.lineCtx.yRatio[h2] : 0);
    else if (d2 && s2 > 0 && n2[s2][0] === undefined) {
      for (var u2 = s2 - 1;u2 >= 0; u2--)
        if (n2[u2][0] !== null && n2[u2][0] !== undefined) {
          o2 = l2 = this.lineCtx.prevSeriesY[u2][0];
          break;
        }
    }
    return { prevY: o2, lineYPosition: l2 };
  } }]), t2;
}();
var Da = function(t2) {
  for (var e2, i2, a2, s2, r2 = function(t3) {
    for (var e3 = [], i3 = t3[0], a3 = t3[1], s3 = e3[0] = Wa(i3, a3), r3 = 1, n3 = t3.length - 1;r3 < n3; r3++)
      i3 = a3, a3 = t3[r3 + 1], e3[r3] = 0.5 * (s3 + (s3 = Wa(i3, a3)));
    return e3[r3] = s3, e3;
  }(t2), n2 = t2.length - 1, o2 = [], l2 = 0;l2 < n2; l2++)
    a2 = Wa(t2[l2], t2[l2 + 1]), Math.abs(a2) < 0.000001 ? r2[l2] = r2[l2 + 1] = 0 : (s2 = (e2 = r2[l2] / a2) * e2 + (i2 = r2[l2 + 1] / a2) * i2) > 9 && (s2 = 3 * a2 / Math.sqrt(s2), r2[l2] = s2 * e2, r2[l2 + 1] = s2 * i2);
  for (var h2 = 0;h2 <= n2; h2++)
    s2 = (t2[Math.min(n2, h2 + 1)][0] - t2[Math.max(0, h2 - 1)][0]) / (6 * (1 + r2[h2] * r2[h2])), o2.push([s2 || 0, r2[h2] * s2 || 0]);
  return o2;
};
var _a = function(t2) {
  var e2 = Da(t2), i2 = t2[1], a2 = t2[0], s2 = [], r2 = e2[1], n2 = e2[0];
  s2.push(a2, [a2[0] + n2[0], a2[1] + n2[1], i2[0] - r2[0], i2[1] - r2[1], i2[0], i2[1]]);
  for (var o2 = 2, l2 = e2.length;o2 < l2; o2++) {
    var h2 = t2[o2], c2 = e2[o2];
    s2.push([h2[0] - c2[0], h2[1] - c2[1], h2[0], h2[1]]);
  }
  return s2;
};
var Na = function(t2, e2, i2) {
  var a2 = t2.slice(e2, i2);
  if (e2) {
    if (i2 - e2 > 1 && a2[1].length < 6) {
      var s2 = a2[0].length;
      a2[1] = [2 * a2[0][s2 - 2] - a2[0][s2 - 4], 2 * a2[0][s2 - 1] - a2[0][s2 - 3]].concat(a2[1]);
    }
    a2[0] = a2[0].slice(-2);
  }
  return a2;
};
var Ba = function() {
  function t2(e2, a2, s2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.xyRatios = a2, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || s2, this.scatter = new Ui(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Fa(this), this.markers = new Vi(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }
  return s(t2, [{ key: "draw", value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w, n2 = new Mi(this.ctx), o2 = r2.globals.comboCharts ? e2 : r2.config.chart.type, l2 = n2.group({ class: "apexcharts-".concat(o2, "-series apexcharts-plot-series") }), h2 = new Pi(this.ctx, r2);
    this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t3 = h2.getLogSeries(t3), this.yRatio = h2.getLogYRatios(this.yRatio), this.prevSeriesY = [];
    for (var c2 = [], d2 = 0;d2 < t3.length; d2++) {
      t3 = this.lineHelpers.sameValueSeriesFix(d2, t3);
      var g2 = r2.globals.comboCharts ? i2[d2] : d2, p2 = this.yRatio.length > 1 ? g2 : 0;
      this._initSerieVariables(t3, d2, g2);
      var f2 = [], x2 = [], b2 = [], m2 = r2.globals.padHorizontal + this.categoryAxisCorrection;
      this.ctx.series.addCollapsedClassToSeries(this.elSeries, g2), r2.globals.isXNumeric && r2.globals.seriesX.length > 0 && (m2 = (r2.globals.seriesX[g2][0] - r2.globals.minX) / this.xRatio), b2.push(m2);
      var v2, y2 = m2, w2 = undefined, k2 = y2, A2 = this.zeroY, C2 = this.zeroY;
      A2 = this.lineHelpers.determineFirstPrevY({ i: d2, realIndex: g2, series: t3, prevY: A2, lineYPosition: 0, translationsIndex: p2 }).prevY, r2.config.stroke.curve === "monotoneCubic" && t3[d2][0] === null ? f2.push(null) : f2.push(A2), v2 = A2;
      o2 === "rangeArea" && (w2 = C2 = this.lineHelpers.determineFirstPrevY({ i: d2, realIndex: g2, series: a2, prevY: C2, lineYPosition: 0, translationsIndex: p2 }).prevY, x2.push(f2[0] !== null ? C2 : null));
      var S2 = this._calculatePathsFrom({ type: o2, series: t3, i: d2, realIndex: g2, translationsIndex: p2, prevX: k2, prevY: A2, prevY2: C2 }), L2 = [f2[0]], M2 = [x2[0]], P2 = { type: o2, series: t3, realIndex: g2, translationsIndex: p2, i: d2, x: m2, y: 1, pX: y2, pY: v2, pathsFrom: S2, linePaths: [], areaPaths: [], seriesIndex: i2, lineYPosition: 0, xArrj: b2, yArrj: f2, y2Arrj: x2, seriesRangeEnd: a2 }, I2 = this._iterateOverDataPoints(u(u({}, P2), {}, { iterations: o2 === "rangeArea" ? t3[d2].length - 1 : undefined, isRangeStart: true }));
      if (o2 === "rangeArea") {
        for (var T2 = this._calculatePathsFrom({ series: a2, i: d2, realIndex: g2, prevX: k2, prevY: C2 }), z2 = this._iterateOverDataPoints(u(u({}, P2), {}, { series: a2, xArrj: [m2], yArrj: L2, y2Arrj: M2, pY: w2, areaPaths: I2.areaPaths, pathsFrom: T2, iterations: a2[d2].length - 1, isRangeStart: false })), X2 = I2.linePaths.length / 2, R2 = 0;R2 < X2; R2++)
          I2.linePaths[R2] = z2.linePaths[R2 + X2] + I2.linePaths[R2];
        I2.linePaths.splice(X2), I2.pathFromLine = z2.pathFromLine + I2.pathFromLine;
      } else
        I2.pathFromArea += "z";
      this._handlePaths({ type: o2, realIndex: g2, i: d2, paths: I2 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), c2.push(this.elSeries);
    }
    if (((s2 = r2.config.series[0]) === null || s2 === undefined ? undefined : s2.zIndex) !== undefined && c2.sort(function(t4, e3) {
      return Number(t4.node.getAttribute("zIndex")) - Number(e3.node.getAttribute("zIndex"));
    }), r2.config.chart.stacked)
      for (var E2 = c2.length - 1;E2 >= 0; E2--)
        l2.add(c2[E2]);
    else
      for (var Y2 = 0;Y2 < c2.length; Y2++)
        l2.add(c2[Y2]);
    return l2;
  } }, { key: "_initSerieVariables", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx);
    this.xDivision = a2.globals.gridWidth / (a2.globals.dataPoints - (a2.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(a2.config.stroke.width) ? a2.config.stroke.width[i2] : a2.config.stroke.width;
    var r2 = 0;
    if (this.yRatio.length > 1 && (this.yaxisIndex = a2.globals.seriesYAxisReverseMap[i2], r2 = i2), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a2.globals.gridHeight - this.baseLineY[r2] - (this.isReversed ? a2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[r2] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a2.globals.gridHeight || a2.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = a2.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s2.group({ class: "apexcharts-series", zIndex: a2.config.series[i2].zIndex !== undefined ? a2.config.series[i2].zIndex : i2, seriesName: v.escapeString(a2.globals.seriesNames[i2]) }), this.elPointsMain = s2.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i2 }), a2.globals.hasNullValues) {
      var n2 = this.markers.plotChartMarkers({ pointsPos: { x: [0], y: [a2.globals.gridHeight + a2.globals.markers.largestSize] }, seriesIndex: e2, j: 0, pSize: 0.1, alwaysDrawMarker: true, isVirtualPoint: true });
      n2 !== null && this.elPointsMain.add(n2);
    }
    this.elDataLabelsWrap = s2.group({ class: "apexcharts-datalabels", "data:realIndex": i2 });
    var o2 = t3[e2].length === a2.globals.dataPoints;
    this.elSeries.attr({ "data:longestSeries": o2, rel: e2 + 1, "data:realIndex": i2 }), this.appendPathFrom = true;
  } }, { key: "_calculatePathsFrom", value: function(t3) {
    var e2, i2, a2, s2, r2 = t3.type, n2 = t3.series, o2 = t3.i, l2 = t3.realIndex, h2 = t3.translationsIndex, c2 = t3.prevX, d2 = t3.prevY, u2 = t3.prevY2, g2 = this.w, p2 = new Mi(this.ctx);
    if (n2[o2][0] === null) {
      for (var f2 = 0;f2 < n2[o2].length; f2++)
        if (n2[o2][f2] !== null) {
          c2 = this.xDivision * f2, d2 = this.zeroY - n2[o2][f2] / this.yRatio[h2], e2 = p2.move(c2, d2), i2 = p2.move(c2, this.areaBottomY);
          break;
        }
    } else
      e2 = p2.move(c2, d2), r2 === "rangeArea" && (e2 = p2.move(c2, u2) + p2.line(c2, d2)), i2 = p2.move(c2, this.areaBottomY) + p2.line(c2, d2);
    if (a2 = p2.move(0, this.areaBottomY) + p2.line(0, this.areaBottomY), s2 = p2.move(0, this.areaBottomY) + p2.line(0, this.areaBottomY), g2.globals.previousPaths.length > 0) {
      var x2 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a2, pathFromArea: s2, realIndex: l2 });
      a2 = x2.pathFromLine, s2 = x2.pathFromArea;
    }
    return { prevX: c2, prevY: d2, linePath: e2, areaPath: i2, pathFromLine: a2, pathFromArea: s2 };
  } }, { key: "_handlePaths", value: function(t3) {
    var { type: e2, realIndex: i2, i: a2, paths: s2 } = t3, r2 = this.w, n2 = new Mi(this.ctx), o2 = new ji(this.ctx);
    this.prevSeriesY.push(s2.yArrj), r2.globals.seriesXvalues[i2] = s2.xArrj, r2.globals.seriesYvalues[i2] = s2.yArrj;
    var l2 = r2.config.forecastDataPoints;
    if (l2.count > 0 && e2 !== "rangeArea") {
      var h2 = r2.globals.seriesXvalues[i2][r2.globals.seriesXvalues[i2].length - l2.count - 1], c2 = n2.drawRect(h2, 0, r2.globals.gridWidth, r2.globals.gridHeight, 0);
      r2.globals.dom.elForecastMask.appendChild(c2.node);
      var d2 = n2.drawRect(0, 0, h2, r2.globals.gridHeight, 0);
      r2.globals.dom.elNonForecastMask.appendChild(d2.node);
    }
    this.pointsChart || r2.globals.delayedElements.push({ el: this.elPointsMain.node, index: i2 });
    var g2 = { i: a2, realIndex: i2, animationDelay: a2, initialSpeed: r2.config.chart.animations.speed, dataChangeSpeed: r2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(e2) };
    if (e2 === "area")
      for (var p2 = o2.fillPath({ seriesNumber: i2 }), f2 = 0;f2 < s2.areaPaths.length; f2++) {
        var x2 = n2.renderPaths(u(u({}, g2), {}, { pathFrom: s2.pathFromArea, pathTo: s2.areaPaths[f2], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p2 }));
        this.elSeries.add(x2);
      }
    if (r2.config.stroke.show && !this.pointsChart) {
      var b2 = null;
      if (e2 === "line")
        b2 = o2.fillPath({ seriesNumber: i2, i: a2 });
      else if (r2.config.stroke.fill.type === "solid")
        b2 = r2.globals.stroke.colors[i2];
      else {
        var m2 = r2.config.fill;
        r2.config.fill = r2.config.stroke.fill, b2 = o2.fillPath({ seriesNumber: i2, i: a2 }), r2.config.fill = m2;
      }
      for (var v2 = 0;v2 < s2.linePaths.length; v2++) {
        var y2 = b2;
        e2 === "rangeArea" && (y2 = o2.fillPath({ seriesNumber: i2 }));
        var w2 = u(u({}, g2), {}, { pathFrom: s2.pathFromLine, pathTo: s2.linePaths[v2], stroke: b2, strokeWidth: this.strokeWidth, strokeLineCap: r2.config.stroke.lineCap, fill: e2 === "rangeArea" ? y2 : "none" }), k2 = n2.renderPaths(w2);
        if (this.elSeries.add(k2), k2.attr("fill-rule", "evenodd"), l2.count > 0 && e2 !== "rangeArea") {
          var A2 = n2.renderPaths(w2);
          A2.node.setAttribute("stroke-dasharray", l2.dashArray), l2.strokeWidth && A2.node.setAttribute("stroke-width", l2.strokeWidth), this.elSeries.add(A2), A2.attr("clip-path", "url(#forecastMask".concat(r2.globals.cuid, ")")), k2.attr("clip-path", "url(#nonForecastMask".concat(r2.globals.cuid, ")"));
        }
      }
    }
  } }, { key: "_iterateOverDataPoints", value: function(t3) {
    var e2, i2, a2 = this, s2 = t3.type, r2 = t3.series, n2 = t3.iterations, o2 = t3.realIndex, l2 = t3.translationsIndex, h2 = t3.i, c2 = t3.x, d2 = t3.y, u2 = t3.pX, g2 = t3.pY, p2 = t3.pathsFrom, f2 = t3.linePaths, x2 = t3.areaPaths, b2 = t3.seriesIndex, m2 = t3.lineYPosition, y2 = t3.xArrj, w2 = t3.yArrj, k2 = t3.y2Arrj, A2 = t3.isRangeStart, C2 = t3.seriesRangeEnd, S2 = this.w, L2 = new Mi(this.ctx), M2 = this.yRatio, P2 = p2.prevY, I2 = p2.linePath, T2 = p2.areaPath, z2 = p2.pathFromLine, X2 = p2.pathFromArea, R2 = v.isNumber(S2.globals.minYArr[o2]) ? S2.globals.minYArr[o2] : S2.globals.minY;
    n2 || (n2 = S2.globals.dataPoints > 1 ? S2.globals.dataPoints - 1 : S2.globals.dataPoints);
    var E2 = function(t4, e3) {
      return e3 - t4 / M2[l2] + 2 * (a2.isReversed ? t4 / M2[l2] : 0);
    }, Y2 = d2, H2 = S2.config.chart.stacked && !S2.globals.comboCharts || S2.config.chart.stacked && S2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((e2 = this.w.config.series[o2]) === null || e2 === undefined ? undefined : e2.type) === "bar" || ((i2 = this.w.config.series[o2]) === null || i2 === undefined ? undefined : i2.type) === "column"), O2 = S2.config.stroke.curve;
    Array.isArray(O2) && (O2 = Array.isArray(b2) ? O2[b2[h2]] : O2[h2]);
    for (var F2, D2 = 0, _2 = 0;_2 < n2 && r2[h2].length !== 0; _2++) {
      var N2 = r2[h2][_2 + 1] === undefined || r2[h2][_2 + 1] === null;
      if (S2.globals.isXNumeric) {
        var W2 = S2.globals.seriesX[o2][_2 + 1];
        S2.globals.seriesX[o2][_2 + 1] === undefined && (W2 = S2.globals.seriesX[o2][n2 - 1]), c2 = (W2 - S2.globals.minX) / this.xRatio;
      } else
        c2 += this.xDivision;
      if (H2)
        if (h2 > 0 && S2.globals.collapsedSeries.length < S2.config.series.length - 1) {
          m2 = this.prevSeriesY[function(t4) {
            for (var e3 = t4;e3 > 0; e3--) {
              if (!(S2.globals.collapsedSeriesIndices.indexOf((b2 == null ? undefined : b2[e3]) || e3) > -1))
                return e3;
              e3--;
            }
            return 0;
          }(h2 - 1)][_2 + 1];
        } else
          m2 = this.zeroY;
      else
        m2 = this.zeroY;
      N2 ? d2 = E2(R2, m2) : (d2 = E2(r2[h2][_2 + 1], m2), s2 === "rangeArea" && (Y2 = E2(C2[h2][_2 + 1], m2))), y2.push(r2[h2][_2 + 1] === null ? null : c2), !N2 || S2.config.stroke.curve !== "smooth" && S2.config.stroke.curve !== "monotoneCubic" ? (w2.push(d2), k2.push(Y2)) : (w2.push(null), k2.push(null));
      var B2 = this.lineHelpers.calculatePoints({ series: r2, x: c2, y: d2, realIndex: o2, i: h2, j: _2, prevY: P2 }), G2 = this._createPaths({ type: s2, series: r2, i: h2, realIndex: o2, j: _2, x: c2, y: d2, y2: Y2, xArrj: y2, yArrj: w2, y2Arrj: k2, pX: u2, pY: g2, pathState: D2, segmentStartX: F2, linePath: I2, areaPath: T2, linePaths: f2, areaPaths: x2, curve: O2, isRangeStart: A2 });
      x2 = G2.areaPaths, f2 = G2.linePaths, u2 = G2.pX, g2 = G2.pY, D2 = G2.pathState, F2 = G2.segmentStartX, T2 = G2.areaPath, I2 = G2.linePath, !this.appendPathFrom || S2.globals.hasNullValues || O2 === "monotoneCubic" && s2 === "rangeArea" || (z2 += L2.line(c2, this.areaBottomY), X2 += L2.line(c2, this.areaBottomY)), this.handleNullDataPoints(r2, B2, h2, _2, o2), this._handleMarkersAndLabels({ type: s2, pointsPos: B2, i: h2, j: _2, realIndex: o2, isRangeStart: A2 });
    }
    return { yArrj: w2, xArrj: y2, pathFromArea: X2, areaPaths: x2, pathFromLine: z2, linePaths: f2, linePath: I2, areaPath: T2 };
  } }, { key: "_handleMarkersAndLabels", value: function(t3) {
    var { type: e2, pointsPos: i2, isRangeStart: a2, i: s2, j: r2, realIndex: n2 } = t3, o2 = this.w, l2 = new qi(this.ctx);
    if (this.pointsChart)
      this.scatter.draw(this.elSeries, r2, { realIndex: n2, pointsPos: i2, zRatio: this.zRatio, elParent: this.elPointsMain });
    else {
      o2.globals.series[s2].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
      var h2 = this.markers.plotChartMarkers({ pointsPos: i2, seriesIndex: n2, j: r2 + 1 });
      h2 !== null && this.elPointsMain.add(h2);
    }
    var c2 = l2.drawDataLabel({ type: e2, isRangeStart: a2, pos: i2, i: n2, j: r2 + 1 });
    c2 !== null && this.elDataLabelsWrap.add(c2);
  } }, { key: "_createPaths", value: function(t3) {
    var { type: e2, series: i2, i: a2 } = t3;
    t3.realIndex;
    var s2, r2 = t3.j, n2 = t3.x, o2 = t3.y, l2 = t3.xArrj, h2 = t3.yArrj, c2 = t3.y2, d2 = t3.y2Arrj, u2 = t3.pX, g2 = t3.pY, p2 = t3.pathState, f2 = t3.segmentStartX, x2 = t3.linePath, b2 = t3.areaPath, m2 = t3.linePaths, v2 = t3.areaPaths, y2 = t3.curve, w2 = t3.isRangeStart, k2 = new Mi(this.ctx), A2 = this.areaBottomY, C2 = e2 === "rangeArea", S2 = e2 === "rangeArea" && w2;
    switch (y2) {
      case "monotoneCubic":
        var L2 = w2 ? h2 : d2;
        switch (p2) {
          case 0:
            if (L2[r2 + 1] === null)
              break;
            p2 = 1;
          case 1:
            if (!(C2 ? l2.length === i2[a2].length : r2 === i2[a2].length - 2))
              break;
          case 2:
            var M2 = w2 ? l2 : l2.slice().reverse(), P2 = w2 ? L2 : L2.slice().reverse(), I2 = (s2 = P2, M2.map(function(t4, e3) {
              return [t4, s2[e3]];
            }).filter(function(t4) {
              return t4[1] !== null;
            })), T2 = I2.length > 1 ? _a(I2) : I2, z2 = [];
            C2 && (S2 ? v2 = I2 : z2 = v2.reverse());
            var X2 = 0, R2 = 0;
            if (function(t4, e3) {
              for (var i3 = function(t5) {
                var e4 = [], i4 = 0;
                return t5.forEach(function(t6) {
                  t6 !== null ? i4++ : i4 > 0 && (e4.push(i4), i4 = 0);
                }), i4 > 0 && e4.push(i4), e4;
              }(t4), a3 = [], s3 = 0, r3 = 0;s3 < i3.length; r3 += i3[s3++])
                a3[s3] = Na(e3, r3, r3 + i3[s3]);
              return a3;
            }(P2, T2).forEach(function(t4) {
              X2++;
              var e3 = function(t5) {
                for (var e4 = "", i4 = 0;i4 < t5.length; i4++) {
                  var a4 = t5[i4], s3 = a4.length;
                  s3 > 4 ? (e4 += "C".concat(a4[0], ", ").concat(a4[1]), e4 += ", ".concat(a4[2], ", ").concat(a4[3]), e4 += ", ".concat(a4[4], ", ").concat(a4[5])) : s3 > 2 && (e4 += "S".concat(a4[0], ", ").concat(a4[1]), e4 += ", ".concat(a4[2], ", ").concat(a4[3]));
                }
                return e4;
              }(t4), i3 = R2, a3 = (R2 += t4.length) - 1;
              S2 ? x2 = k2.move(I2[i3][0], I2[i3][1]) + e3 : C2 ? x2 = k2.move(z2[i3][0], z2[i3][1]) + k2.line(I2[i3][0], I2[i3][1]) + e3 + k2.line(z2[a3][0], z2[a3][1]) : (x2 = k2.move(I2[i3][0], I2[i3][1]) + e3, b2 = x2 + k2.line(I2[a3][0], A2) + k2.line(I2[i3][0], A2) + "z", v2.push(b2)), m2.push(x2);
            }), C2 && X2 > 1 && !S2) {
              var E2 = m2.slice(X2).reverse();
              m2.splice(X2), E2.forEach(function(t4) {
                return m2.push(t4);
              });
            }
            p2 = 0;
        }
        break;
      case "smooth":
        var Y2 = 0.35 * (n2 - u2);
        if (i2[a2][r2] === null)
          p2 = 0;
        else
          switch (p2) {
            case 0:
              if (f2 = u2, x2 = S2 ? k2.move(u2, d2[r2]) + k2.line(u2, g2) : k2.move(u2, g2), b2 = k2.move(u2, g2), i2[a2][r2 + 1] === null || i2[a2][r2 + 1] === undefined) {
                m2.push(x2), v2.push(b2);
                break;
              }
              if (p2 = 1, r2 < i2[a2].length - 2) {
                var H2 = k2.curve(u2 + Y2, g2, n2 - Y2, o2, n2, o2);
                x2 += H2, b2 += H2;
                break;
              }
            case 1:
              if (i2[a2][r2 + 1] === null)
                x2 += S2 ? k2.line(u2, c2) : k2.move(u2, g2), b2 += k2.line(u2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1;
              else {
                var O2 = k2.curve(u2 + Y2, g2, n2 - Y2, o2, n2, o2);
                x2 += O2, b2 += O2, r2 >= i2[a2].length - 2 && (S2 && (x2 += k2.curve(n2, o2, n2, o2, n2, c2) + k2.move(n2, c2)), b2 += k2.curve(n2, o2, n2, o2, n2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1);
              }
          }
        u2 = n2, g2 = o2;
        break;
      default:
        var F2 = function(t4, e3, i3) {
          var a3 = [];
          switch (t4) {
            case "stepline":
              a3 = k2.line(e3, null, "H") + k2.line(null, i3, "V");
              break;
            case "linestep":
              a3 = k2.line(null, i3, "V") + k2.line(e3, null, "H");
              break;
            case "straight":
              a3 = k2.line(e3, i3);
          }
          return a3;
        };
        if (i2[a2][r2] === null)
          p2 = 0;
        else
          switch (p2) {
            case 0:
              if (f2 = u2, x2 = S2 ? k2.move(u2, d2[r2]) + k2.line(u2, g2) : k2.move(u2, g2), b2 = k2.move(u2, g2), i2[a2][r2 + 1] === null || i2[a2][r2 + 1] === undefined) {
                m2.push(x2), v2.push(b2);
                break;
              }
              if (p2 = 1, r2 < i2[a2].length - 2) {
                var D2 = F2(y2, n2, o2);
                x2 += D2, b2 += D2;
                break;
              }
            case 1:
              if (i2[a2][r2 + 1] === null)
                x2 += S2 ? k2.line(u2, c2) : k2.move(u2, g2), b2 += k2.line(u2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1;
              else {
                var _2 = F2(y2, n2, o2);
                x2 += _2, b2 += _2, r2 >= i2[a2].length - 2 && (S2 && (x2 += k2.line(n2, c2)), b2 += k2.line(n2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1);
              }
          }
        u2 = n2, g2 = o2;
    }
    return { linePaths: m2, areaPaths: v2, pX: u2, pY: g2, pathState: p2, segmentStartX: f2, linePath: x2, areaPath: b2 };
  } }, { key: "handleNullDataPoints", value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w;
    if (t3[i2][a2] === null && r2.config.markers.showNullDataPoints || t3[i2].length === 1) {
      var n2 = this.strokeWidth - r2.config.markers.strokeWidth / 2;
      n2 > 0 || (n2 = 0);
      var o2 = this.markers.plotChartMarkers({ pointsPos: e2, seriesIndex: s2, j: a2 + 1, pSize: n2, alwaysDrawMarker: true });
      o2 !== null && this.elPointsMain.add(o2);
    }
  } }]), t2;
}();
window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
  function t2(e3, i3, a3, s3) {
    this.xoffset = e3, this.yoffset = i3, this.height = s3, this.width = a3, this.shortestEdge = function() {
      return Math.min(this.height, this.width);
    }, this.getCoordinates = function(t3) {
      var e4, i4 = [], a4 = this.xoffset, s4 = this.yoffset, n3 = r2(t3) / this.height, o2 = r2(t3) / this.width;
      if (this.width >= this.height)
        for (e4 = 0;e4 < t3.length; e4++)
          i4.push([a4, s4, a4 + n3, s4 + t3[e4] / n3]), s4 += t3[e4] / n3;
      else
        for (e4 = 0;e4 < t3.length; e4++)
          i4.push([a4, s4, a4 + t3[e4] / o2, s4 + o2]), a4 += t3[e4] / o2;
      return i4;
    }, this.cutArea = function(e4) {
      var i4;
      if (this.width >= this.height) {
        var a4 = e4 / this.height, s4 = this.width - a4;
        i4 = new t2(this.xoffset + a4, this.yoffset, s4, this.height);
      } else {
        var r3 = e4 / this.width, n3 = this.height - r3;
        i4 = new t2(this.xoffset, this.yoffset + r3, this.width, n3);
      }
      return i4;
    };
  }
  function e2(e3, a3, s3, n3, o2) {
    n3 = n3 === undefined ? 0 : n3, o2 = o2 === undefined ? 0 : o2;
    var l2 = i2(function(t3, e4) {
      var i3, a4 = [], s4 = e4 / r2(t3);
      for (i3 = 0;i3 < t3.length; i3++)
        a4[i3] = t3[i3] * s4;
      return a4;
    }(e3, a3 * s3), [], new t2(n3, o2, a3, s3), []);
    return function(t3) {
      var e4, i3, a4 = [];
      for (e4 = 0;e4 < t3.length; e4++)
        for (i3 = 0;i3 < t3[e4].length; i3++)
          a4.push(t3[e4][i3]);
      return a4;
    }(l2);
  }
  function i2(t3, e3, s3, n3) {
    var o2, l2, h2;
    if (t3.length !== 0)
      return o2 = s3.shortestEdge(), function(t4, e4, i3) {
        var s4;
        if (t4.length === 0)
          return true;
        (s4 = t4.slice()).push(e4);
        var r3 = a2(t4, i3), n4 = a2(s4, i3);
        return r3 >= n4;
      }(e3, l2 = t3[0], o2) ? (e3.push(l2), i2(t3.slice(1), e3, s3, n3)) : (h2 = s3.cutArea(r2(e3), n3), n3.push(s3.getCoordinates(e3)), i2(t3, [], h2, n3)), n3;
    n3.push(s3.getCoordinates(e3));
  }
  function a2(t3, e3) {
    var i3 = Math.min.apply(Math, t3), a3 = Math.max.apply(Math, t3), s3 = r2(t3);
    return Math.max(Math.pow(e3, 2) * a3 / Math.pow(s3, 2), Math.pow(s3, 2) / (Math.pow(e3, 2) * i3));
  }
  function s2(t3) {
    return t3 && t3.constructor === Array;
  }
  function r2(t3) {
    var e3, i3 = 0;
    for (e3 = 0;e3 < t3.length; e3++)
      i3 += t3[e3];
    return i3;
  }
  function n2(t3) {
    var e3, i3 = 0;
    if (s2(t3[0]))
      for (e3 = 0;e3 < t3.length; e3++)
        i3 += n2(t3[e3]);
    else
      i3 = r2(t3);
    return i3;
  }
  return function t(i3, a3, r3, o2, l2) {
    o2 = o2 === undefined ? 0 : o2, l2 = l2 === undefined ? 0 : l2;
    var h2, c2, d2 = [], u2 = [];
    if (s2(i3[0])) {
      for (c2 = 0;c2 < i3.length; c2++)
        d2[c2] = n2(i3[c2]);
      for (h2 = e2(d2, a3, r3, o2, l2), c2 = 0;c2 < i3.length; c2++)
        u2.push(t(i3[c2], h2[c2][2] - h2[c2][0], h2[c2][3] - h2[c2][1], h2[c2][0], h2[c2][1]));
    } else
      u2 = e2(i3, a3, r3, o2, l2);
    return u2;
  };
}();
var Ga = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new za(e2), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = new ji(this.ctx), r2 = a2.group({ class: "apexcharts-treemap" });
    if (i2.globals.noData)
      return r2;
    var n2 = [];
    return t3.forEach(function(t4) {
      var e3 = t4.map(function(t5) {
        return Math.abs(t5);
      });
      n2.push(e3);
    }), this.negRange = this.helpers.checkColorRange(), i2.config.series.forEach(function(t4, i3) {
      t4.data.forEach(function(t5) {
        Array.isArray(e2.labels[i3]) || (e2.labels[i3] = []), e2.labels[i3].push(t5.x);
      });
    }), window.TreemapSquared.generate(n2, i2.globals.gridWidth, i2.globals.gridHeight).forEach(function(n3, o2) {
      var l2 = a2.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: v.escapeString(i2.globals.seriesNames[o2]), rel: o2 + 1, "data:realIndex": o2 });
      if (i2.config.chart.dropShadow.enabled) {
        var h2 = i2.config.chart.dropShadow;
        new Li(e2.ctx).dropShadow(r2, h2, o2);
      }
      var c2 = a2.group({ class: "apexcharts-data-labels" }), d2 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 };
      n3.forEach(function(r3, n4) {
        var h3 = r3[0], c3 = r3[1], u3 = r3[2], g3 = r3[3];
        d2.xMin = Math.min(d2.xMin, h3), d2.yMin = Math.min(d2.yMin, c3), d2.xMax = Math.max(d2.xMax, u3), d2.yMax = Math.max(d2.yMax, g3);
        var p3 = e2.helpers.getShadeColor(i2.config.chart.type, o2, n4, e2.negRange), f3 = p3.color, x3 = s2.fillPath({ color: f3, seriesNumber: o2, dataPointIndex: n4 }), b3 = a2.drawRect(h3, c3, u3 - h3, g3 - c3, i2.config.plotOptions.treemap.borderRadius, "#fff", 1, e2.strokeWidth, i2.config.plotOptions.treemap.useFillColorAsStroke ? f3 : i2.globals.stroke.colors[o2]);
        b3.attr({ cx: h3, cy: c3, index: o2, i: o2, j: n4, width: u3 - h3, height: g3 - c3, fill: x3 }), b3.node.classList.add("apexcharts-treemap-rect"), e2.helpers.addListeners(b3);
        var m3 = { x: h3 + (u3 - h3) / 2, y: c3 + (g3 - c3) / 2, width: 0, height: 0 }, v2 = { x: h3, y: c3, width: u3 - h3, height: g3 - c3 };
        if (i2.config.chart.animations.enabled && !i2.globals.dataChanged) {
          var y3 = 1;
          i2.globals.resized || (y3 = i2.config.chart.animations.speed), e2.animateTreemap(b3, m3, v2, y3);
        }
        if (i2.globals.dataChanged) {
          var w3 = 1;
          e2.dynamicAnim.enabled && i2.globals.shouldAnimate && (w3 = e2.dynamicAnim.speed, i2.globals.previousPaths[o2] && i2.globals.previousPaths[o2][n4] && i2.globals.previousPaths[o2][n4].rect && (m3 = i2.globals.previousPaths[o2][n4].rect), e2.animateTreemap(b3, m3, v2, w3));
        }
        var k3 = e2.getFontSize(r3), A3 = i2.config.dataLabels.formatter(e2.labels[o2][n4], { value: i2.globals.series[o2][n4], seriesIndex: o2, dataPointIndex: n4, w: i2 });
        i2.config.plotOptions.treemap.dataLabels.format === "truncate" && (k3 = parseInt(i2.config.dataLabels.style.fontSize, 10), A3 = e2.truncateLabels(A3, k3, h3, c3, u3, g3));
        var C3 = null;
        i2.globals.series[o2][n4] && (C3 = e2.helpers.calculateDataLabels({ text: A3, x: (h3 + u3) / 2, y: (c3 + g3) / 2 + e2.strokeWidth / 2 + k3 / 3, i: o2, j: n4, colorProps: p3, fontSize: k3, series: t3 })), i2.config.dataLabels.enabled && C3 && e2.rotateToFitLabel(C3, k3, A3, h3, c3, u3, g3), l2.add(b3), C3 !== null && l2.add(C3);
      });
      var u2 = i2.config.plotOptions.treemap.seriesTitle;
      if (i2.config.series.length > 1 && u2 && u2.show) {
        var g2 = i2.config.series[o2].name || "";
        if (g2 && d2.xMin < 1 / 0 && d2.yMin < 1 / 0) {
          var { offsetX: p2, offsetY: f2, borderColor: x2, borderWidth: b2, borderRadius: m2, style: y2 } = u2, w2 = y2.color || i2.config.chart.foreColor, k2 = { left: y2.padding.left, right: y2.padding.right, top: y2.padding.top, bottom: y2.padding.bottom }, A2 = a2.getTextRects(g2, y2.fontSize, y2.fontFamily), C2 = A2.width + k2.left + k2.right, S2 = A2.height + k2.top + k2.bottom, L2 = d2.xMin + (p2 || 0), M2 = d2.yMin + (f2 || 0), P2 = a2.drawRect(L2, M2, C2, S2, m2, y2.background, 1, b2, x2), I2 = a2.drawText({ x: L2 + k2.left, y: M2 + k2.top + 0.75 * A2.height, text: g2, fontSize: y2.fontSize, fontFamily: y2.fontFamily, fontWeight: y2.fontWeight, foreColor: w2, cssClass: y2.cssClass || "" });
          l2.add(P2), l2.add(I2);
        }
      }
      l2.add(c2), r2.add(l2);
    }), r2;
  } }, { key: "getFontSize", value: function(t3) {
    var e2 = this.w;
    var i2 = function t(e3) {
      var i3, a2 = 0;
      if (Array.isArray(e3[0]))
        for (i3 = 0;i3 < e3.length; i3++)
          a2 += t(e3[i3]);
      else
        for (i3 = 0;i3 < e3.length; i3++)
          a2 += e3[i3].length;
      return a2;
    }(this.labels) / function t(e3) {
      var i3, a2 = 0;
      if (Array.isArray(e3[0]))
        for (i3 = 0;i3 < e3.length; i3++)
          a2 += t(e3[i3]);
      else
        for (i3 = 0;i3 < e3.length; i3++)
          a2 += 1;
      return a2;
    }(this.labels);
    return function(t4, a2) {
      var s2 = t4 * a2, r2 = Math.pow(s2, 0.5);
      return Math.min(r2 / i2, parseInt(e2.config.dataLabels.style.fontSize, 10));
    }(t3[2] - t3[0], t3[3] - t3[1]);
  } }, { key: "rotateToFitLabel", value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = new Mi(this.ctx), l2 = o2.getTextRects(i2, e2);
    if (l2.width + this.w.config.stroke.width + 5 > r2 - a2 && l2.width <= n2 - s2) {
      var h2 = o2.rotateAroundCenter(t3.node);
      t3.node.setAttribute("transform", "rotate(-90 ".concat(h2.x, " ").concat(h2.y, ") translate(").concat(l2.height / 3, ")"));
    }
  } }, { key: "truncateLabels", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = new Mi(this.ctx), o2 = n2.getTextRects(t3, e2).width + this.w.config.stroke.width + 5 > s2 - i2 && r2 - a2 > s2 - i2 ? r2 - a2 : s2 - i2, l2 = n2.getTextBasedOnMaxWidth({ text: t3, maxWidth: o2, fontSize: e2 });
    return t3.length !== l2.length && o2 / e2 < 5 ? "" : l2;
  } }, { key: "animateTreemap", value: function(t3, e2, i2, a2) {
    var s2 = new y(this.ctx);
    s2.animateRect(t3, e2, i2, a2, function() {
      s2.animationCompleted(t3);
    });
  } }]), t2;
}();
var ja = 86400;
var Va = 10 / ja;
var Ua = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }
  return s(t2, [{ key: "calculateTimeScaleTicks", value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    if (a2.globals.allSeriesCollapsed)
      return a2.globals.labels = [], a2.globals.timescaleLabels = [], [];
    var s2 = new zi(this.ctx), r2 = (e2 - t3) / 86400000;
    this.determineInterval(r2), a2.globals.disableZoomIn = false, a2.globals.disableZoomOut = false, r2 < Va ? a2.globals.disableZoomIn = true : r2 > 50000 && (a2.globals.disableZoomOut = true);
    var n2 = s2.getTimeUnitsfromTimestamp(t3, e2, this.utc), o2 = a2.globals.gridWidth / r2, l2 = o2 / 24, h2 = l2 / 60, c2 = h2 / 60, d2 = Math.floor(24 * r2), g2 = Math.floor(1440 * r2), p2 = Math.floor(r2 * ja), f2 = Math.floor(r2), x2 = Math.floor(r2 / 30), b2 = Math.floor(r2 / 365), m2 = { minMillisecond: n2.minMillisecond, minSecond: n2.minSecond, minMinute: n2.minMinute, minHour: n2.minHour, minDate: n2.minDate, minMonth: n2.minMonth, minYear: n2.minYear }, v2 = { firstVal: m2, currentMillisecond: m2.minMillisecond, currentSecond: m2.minSecond, currentMinute: m2.minMinute, currentHour: m2.minHour, currentMonthDate: m2.minDate, currentDate: m2.minDate, currentMonth: m2.minMonth, currentYear: m2.minYear, daysWidthOnXAxis: o2, hoursWidthOnXAxis: l2, minutesWidthOnXAxis: h2, secondsWidthOnXAxis: c2, numberOfSeconds: p2, numberOfMinutes: g2, numberOfHours: d2, numberOfDays: f2, numberOfMonths: x2, numberOfYears: b2 };
    switch (this.tickInterval) {
      case "years":
        this.generateYearScale(v2);
        break;
      case "months":
      case "half_year":
        this.generateMonthScale(v2);
        break;
      case "months_days":
      case "months_fortnight":
      case "days":
      case "week_days":
        this.generateDayScale(v2);
        break;
      case "hours":
        this.generateHourScale(v2);
        break;
      case "minutes_fives":
      case "minutes":
        this.generateMinuteScale(v2);
        break;
      case "seconds_tens":
      case "seconds_fives":
      case "seconds":
        this.generateSecondScale(v2);
    }
    var y2 = this.timeScaleArray.map(function(t4) {
      var e3 = { position: t4.position, unit: t4.unit, year: t4.year, day: t4.day ? t4.day : 1, hour: t4.hour ? t4.hour : 0, month: t4.month + 1 };
      return t4.unit === "month" ? u(u({}, e3), {}, { day: 1, value: t4.value + 1 }) : t4.unit === "day" || t4.unit === "hour" ? u(u({}, e3), {}, { value: t4.value }) : t4.unit === "minute" ? u(u({}, e3), {}, { value: t4.value, minute: t4.value }) : t4.unit === "second" ? u(u({}, e3), {}, { value: t4.value, minute: t4.minute, second: t4.second }) : t4;
    });
    return y2.filter(function(t4) {
      var e3 = 1, s3 = Math.ceil(a2.globals.gridWidth / 120), r3 = t4.value;
      a2.config.xaxis.tickAmount !== undefined && (s3 = a2.config.xaxis.tickAmount), y2.length > s3 && (e3 = Math.floor(y2.length / s3));
      var n3 = false, o3 = false;
      switch (i2.tickInterval) {
        case "years":
          t4.unit === "year" && (n3 = true);
          break;
        case "half_year":
          e3 = 7, t4.unit === "year" && (n3 = true);
          break;
        case "months":
          e3 = 1, t4.unit === "year" && (n3 = true);
          break;
        case "months_fortnight":
          e3 = 15, t4.unit !== "year" && t4.unit !== "month" || (n3 = true), r3 === 30 && (o3 = true);
          break;
        case "months_days":
          e3 = 10, t4.unit === "month" && (n3 = true), r3 === 30 && (o3 = true);
          break;
        case "week_days":
          e3 = 8, t4.unit === "month" && (n3 = true);
          break;
        case "days":
          e3 = 1, t4.unit === "month" && (n3 = true);
          break;
        case "hours":
          t4.unit === "day" && (n3 = true);
          break;
        case "minutes_fives":
        case "seconds_fives":
          r3 % 5 != 0 && (o3 = true);
          break;
        case "seconds_tens":
          r3 % 10 != 0 && (o3 = true);
      }
      if (i2.tickInterval === "hours" || i2.tickInterval === "minutes_fives" || i2.tickInterval === "seconds_tens" || i2.tickInterval === "seconds_fives") {
        if (!o3)
          return true;
      } else if ((r3 % e3 == 0 || n3) && !o3)
        return true;
    });
  } }, { key: "recalcDimensionsBasedOnFormat", value: function(t3, e2) {
    var i2 = this.w, a2 = this.formatDates(t3), s2 = this.removeOverlappingTS(a2);
    i2.globals.timescaleLabels = s2.slice(), new pa(this.ctx).plotCoords();
  } }, { key: "determineInterval", value: function(t3) {
    var e2 = 24 * t3, i2 = 60 * e2;
    switch (true) {
      case t3 / 365 > 5:
        this.tickInterval = "years";
        break;
      case t3 > 800:
        this.tickInterval = "half_year";
        break;
      case t3 > 180:
        this.tickInterval = "months";
        break;
      case t3 > 90:
        this.tickInterval = "months_fortnight";
        break;
      case t3 > 60:
        this.tickInterval = "months_days";
        break;
      case t3 > 30:
        this.tickInterval = "week_days";
        break;
      case t3 > 2:
        this.tickInterval = "days";
        break;
      case e2 > 2.4:
        this.tickInterval = "hours";
        break;
      case i2 > 15:
        this.tickInterval = "minutes_fives";
        break;
      case i2 > 5:
        this.tickInterval = "minutes";
        break;
      case i2 > 1:
        this.tickInterval = "seconds_tens";
        break;
      case 60 * i2 > 20:
        this.tickInterval = "seconds_fives";
        break;
      default:
        this.tickInterval = "seconds";
    }
  } }, { key: "generateYearScale", value: function(t3) {
    var { firstVal: e2, currentMonth: i2, currentYear: a2, daysWidthOnXAxis: s2, numberOfYears: r2 } = t3, n2 = e2.minYear, o2 = 0, l2 = new zi(this.ctx), h2 = "year";
    if (e2.minDate > 1 || e2.minMonth > 0) {
      var c2 = l2.determineRemainingDaysOfYear(e2.minYear, e2.minMonth, e2.minDate);
      o2 = (l2.determineDaysOfYear(e2.minYear) - c2 + 1) * s2, n2 = e2.minYear + 1, this.timeScaleArray.push({ position: o2, value: n2, unit: h2, year: n2, month: v.monthMod(i2 + 1) });
    } else
      e2.minDate === 1 && e2.minMonth === 0 && this.timeScaleArray.push({ position: o2, value: n2, unit: h2, year: a2, month: v.monthMod(i2 + 1) });
    for (var d2 = n2, u2 = o2, g2 = 0;g2 < r2; g2++)
      d2++, u2 = l2.determineDaysOfYear(d2 - 1) * s2 + u2, this.timeScaleArray.push({ position: u2, value: d2, unit: h2, year: d2, month: 1 });
  } }, { key: "generateMonthScale", value: function(t3) {
    var { firstVal: e2, currentMonthDate: i2, currentMonth: a2, currentYear: s2, daysWidthOnXAxis: r2, numberOfMonths: n2 } = t3, o2 = a2, l2 = 0, h2 = new zi(this.ctx), c2 = "month", d2 = 0;
    if (e2.minDate > 1) {
      l2 = (h2.determineDaysOfMonths(a2 + 1, e2.minYear) - i2 + 1) * r2, o2 = v.monthMod(a2 + 1);
      var u2 = s2 + d2, g2 = v.monthMod(o2), p2 = o2;
      o2 === 0 && (c2 = "year", p2 = u2, g2 = 1, u2 += d2 += 1), this.timeScaleArray.push({ position: l2, value: p2, unit: c2, year: u2, month: g2 });
    } else
      this.timeScaleArray.push({ position: l2, value: o2, unit: c2, year: s2, month: v.monthMod(a2) });
    for (var f2 = o2 + 1, x2 = l2, b2 = 0, m2 = 1;b2 < n2; b2++, m2++) {
      (f2 = v.monthMod(f2)) === 0 ? (c2 = "year", d2 += 1) : c2 = "month";
      var y2 = this._getYear(s2, f2, d2);
      x2 = h2.determineDaysOfMonths(f2, y2) * r2 + x2;
      var w2 = f2 === 0 ? y2 : f2;
      this.timeScaleArray.push({ position: x2, value: w2, unit: c2, year: y2, month: f2 === 0 ? 1 : f2 }), f2++;
    }
  } }, { key: "generateDayScale", value: function(t3) {
    var { firstVal: e2, currentMonth: i2, currentYear: a2, hoursWidthOnXAxis: s2, numberOfDays: r2 } = t3, n2 = new zi(this.ctx), o2 = "day", l2 = e2.minDate + 1, h2 = l2, c2 = function(t4, e3, i3) {
      return t4 > n2.determineDaysOfMonths(e3 + 1, i3) ? (h2 = 1, o2 = "month", u2 = e3 += 1, e3) : e3;
    }, d2 = (24 - e2.minHour) * s2, u2 = l2, g2 = c2(h2, i2, a2);
    e2.minHour === 0 && e2.minDate === 1 ? (d2 = 0, u2 = v.monthMod(e2.minMonth), o2 = "month", h2 = e2.minDate) : e2.minDate !== 1 && e2.minHour === 0 && e2.minMinute === 0 && (d2 = 0, l2 = e2.minDate, u2 = l2, g2 = c2(h2 = l2, i2, a2), u2 !== 1 && (o2 = "day")), this.timeScaleArray.push({ position: d2, value: u2, unit: o2, year: this._getYear(a2, g2, 0), month: v.monthMod(g2), day: h2 });
    for (var p2 = d2, f2 = 0;f2 < r2; f2++) {
      o2 = "day", g2 = c2(h2 += 1, g2, this._getYear(a2, g2, 0));
      var x2 = this._getYear(a2, g2, 0);
      p2 = 24 * s2 + p2;
      var b2 = h2 === 1 ? v.monthMod(g2) : h2;
      this.timeScaleArray.push({ position: p2, value: b2, unit: o2, year: x2, month: v.monthMod(g2), day: b2 });
    }
  } }, { key: "generateHourScale", value: function(t3) {
    var { firstVal: e2, currentDate: i2, currentMonth: a2, currentYear: s2, minutesWidthOnXAxis: r2, numberOfHours: n2 } = t3, o2 = new zi(this.ctx), l2 = "hour", h2 = function(t4, e3) {
      return t4 > o2.determineDaysOfMonths(e3 + 1, s2) && (f2 = 1, e3 += 1), { month: e3, date: f2 };
    }, c2 = function(t4, e3) {
      return t4 > o2.determineDaysOfMonths(e3 + 1, s2) ? e3 += 1 : e3;
    }, d2 = 60 - (e2.minMinute + e2.minSecond / 60), u2 = d2 * r2, g2 = e2.minHour + 1, p2 = g2;
    d2 === 60 && (u2 = 0, p2 = g2 = e2.minHour);
    var f2 = i2;
    p2 >= 24 && (p2 = 0, l2 = "day", g2 = f2 += 1);
    var x2 = h2(f2, a2).month;
    x2 = c2(f2, x2), g2 > 31 && (g2 = f2 = 1), this.timeScaleArray.push({ position: u2, value: g2, unit: l2, day: f2, hour: p2, year: s2, month: v.monthMod(x2) }), p2++;
    for (var b2 = u2, m2 = 0;m2 < n2; m2++) {
      if (l2 = "hour", p2 >= 24)
        p2 = 0, l2 = "day", x2 = h2(f2 += 1, x2).month, x2 = c2(f2, x2);
      var y2 = this._getYear(s2, x2, 0);
      b2 = 60 * r2 + b2;
      var w2 = p2 === 0 ? f2 : p2;
      this.timeScaleArray.push({ position: b2, value: w2, unit: l2, hour: p2, day: f2, year: y2, month: v.monthMod(x2) }), p2++;
    }
  } }, { key: "generateMinuteScale", value: function(t3) {
    for (var { currentMillisecond: e2, currentSecond: i2, currentMinute: a2, currentHour: s2, currentDate: r2, currentMonth: n2, currentYear: o2, minutesWidthOnXAxis: l2, secondsWidthOnXAxis: h2, numberOfMinutes: c2 } = t3, d2 = a2 + 1, u2 = r2, g2 = n2, p2 = o2, f2 = s2, x2 = (60 - i2 - e2 / 1000) * h2, b2 = 0;b2 < c2; b2++)
      d2 >= 60 && (d2 = 0, (f2 += 1) === 24 && (f2 = 0)), this.timeScaleArray.push({ position: x2, value: d2, unit: "minute", hour: f2, minute: d2, day: u2, year: this._getYear(p2, g2, 0), month: v.monthMod(g2) }), x2 += l2, d2++;
  } }, { key: "generateSecondScale", value: function(t3) {
    for (var { currentMillisecond: e2, currentSecond: i2, currentMinute: a2, currentHour: s2, currentDate: r2, currentMonth: n2, currentYear: o2, secondsWidthOnXAxis: l2, numberOfSeconds: h2 } = t3, c2 = i2 + 1, d2 = a2, u2 = r2, g2 = n2, p2 = o2, f2 = s2, x2 = (1000 - e2) / 1000 * l2, b2 = 0;b2 < h2; b2++)
      c2 >= 60 && (c2 = 0, ++d2 >= 60 && (d2 = 0, ++f2 === 24 && (f2 = 0))), this.timeScaleArray.push({ position: x2, value: c2, unit: "second", hour: f2, minute: d2, second: c2, day: u2, year: this._getYear(p2, g2, 0), month: v.monthMod(g2) }), x2 += l2, c2++;
  } }, { key: "createRawDateString", value: function(t3, e2) {
    var i2 = t3.year;
    return t3.month === 0 && (t3.month = 1), i2 += "-" + ("0" + t3.month.toString()).slice(-2), t3.unit === "day" ? i2 += t3.unit === "day" ? "-" + ("0" + e2).slice(-2) : "-01" : i2 += "-" + ("0" + (t3.day ? t3.day : "1")).slice(-2), t3.unit === "hour" ? i2 += t3.unit === "hour" ? "T" + ("0" + e2).slice(-2) : "T00" : i2 += "T" + ("0" + (t3.hour ? t3.hour : "0")).slice(-2), t3.unit === "minute" ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":" + (t3.minute ? ("0" + t3.minute).slice(-2) : "00"), t3.unit === "second" ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":00", this.utc && (i2 += ".000Z"), i2;
  } }, { key: "formatDates", value: function(t3) {
    var e2 = this, i2 = this.w;
    return t3.map(function(t4) {
      var a2 = t4.value.toString(), s2 = new zi(e2.ctx), r2 = e2.createRawDateString(t4, a2), n2 = s2.getDate(s2.parseDate(r2));
      if (e2.utc || (n2 = s2.getDate(s2.parseDateWithTimezone(r2))), i2.config.xaxis.labels.format === undefined) {
        var o2 = "dd MMM", l2 = i2.config.xaxis.labels.datetimeFormatter;
        t4.unit === "year" && (o2 = l2.year), t4.unit === "month" && (o2 = l2.month), t4.unit === "day" && (o2 = l2.day), t4.unit === "hour" && (o2 = l2.hour), t4.unit === "minute" && (o2 = l2.minute), t4.unit === "second" && (o2 = l2.second), a2 = s2.formatDate(n2, o2);
      } else
        a2 = s2.formatDate(n2, i2.config.xaxis.labels.format);
      return { dateString: r2, position: t4.position, value: a2, unit: t4.unit, year: t4.year, month: t4.month };
    });
  } }, { key: "removeOverlappingTS", value: function(t3) {
    var e2, i2 = this, a2 = new Mi(this.ctx), s2 = false;
    t3.length > 0 && t3[0].value && t3.every(function(e3) {
      return e3.value.length === t3[0].value.length;
    }) && (s2 = true, e2 = a2.getTextRects(t3[0].value).width);
    var r2 = 0, n2 = t3.map(function(n3, o2) {
      if (o2 > 0 && i2.w.config.xaxis.labels.hideOverlappingLabels) {
        var l2 = s2 ? e2 : a2.getTextRects(t3[r2].value).width, h2 = t3[r2].position;
        return n3.position > h2 + l2 + 10 ? (r2 = o2, n3) : null;
      }
      return n3;
    });
    return n2 = n2.filter(function(t4) {
      return t4 !== null;
    });
  } }, { key: "_getYear", value: function(t3, e2, i2) {
    return t3 + Math.floor(e2 / 12) + i2;
  } }]), t2;
}();
var qa = function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = a2, this.w = a2.w, this.el = e2;
  }
  return s(t2, [{ key: "setupElements", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = i2.chart.type;
    e2.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].includes(a2), e2.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].includes(a2), e2.isBarHorizontal = ["bar", "rangeBar", "boxPlot"].includes(a2) && i2.plotOptions.bar.horizontal, e2.chartClass = ".apexcharts".concat(e2.chartID), e2.dom.baseEl = this.el, e2.dom.elWrap = document.createElement("div"), Mi.setAttrs(e2.dom.elWrap, { id: e2.chartClass.substring(1), class: "apexcharts-canvas ".concat(e2.chartClass.substring(1)) }), this.el.appendChild(e2.dom.elWrap), e2.dom.Paper = window.SVG().addTo(e2.dom.elWrap), e2.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(i2.chart.offsetX, ", ").concat(i2.chart.offsetY, ")") }), e2.dom.Paper.node.style.background = i2.theme.mode !== "dark" || i2.chart.background ? i2.theme.mode !== "light" || i2.chart.background ? i2.chart.background : "#fff" : "#424242", this.setSVGDimensions(), e2.dom.elLegendForeign = document.createElementNS(e2.SVGNS, "foreignObject"), Mi.setAttrs(e2.dom.elLegendForeign, { x: 0, y: 0, width: e2.svgWidth, height: e2.svgHeight }), e2.dom.elLegendWrap = document.createElement("div"), e2.dom.elLegendWrap.classList.add("apexcharts-legend"), e2.dom.elWrap.appendChild(e2.dom.elLegendWrap), e2.dom.Paper.node.appendChild(e2.dom.elLegendForeign), e2.dom.elGraphical = e2.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), e2.dom.elDefs = e2.dom.Paper.defs(), e2.dom.Paper.add(e2.dom.elGraphical), e2.dom.elGraphical.add(e2.dom.elDefs);
  } }, { key: "plotChartType", value: function(t3, e2) {
    var i2 = this.w, a2 = this.ctx, s2 = i2.config, r2 = i2.globals, n2 = { line: { series: [], i: [] }, area: { series: [], i: [] }, scatter: { series: [], i: [] }, bubble: { series: [], i: [] }, bar: { series: [], i: [] }, candlestick: { series: [], i: [] }, boxPlot: { series: [], i: [] }, rangeBar: { series: [], i: [] }, rangeArea: { series: [], seriesRangeEnd: [], i: [] } }, o2 = s2.chart.type || "line", l2 = null, h2 = 0;
    r2.series.forEach(function(e3, a3) {
      var s3 = t3[a3].type === "column" ? "bar" : t3[a3].type || (o2 === "column" ? "bar" : o2);
      n2[s3] ? (s3 === "rangeArea" ? (n2[s3].series.push(r2.seriesRangeStart[a3]), n2[s3].seriesRangeEnd.push(r2.seriesRangeEnd[a3])) : n2[s3].series.push(e3), n2[s3].i.push(a3), s3 === "bar" && (i2.globals.columnSeries = n2.bar)) : ["heatmap", "treemap", "pie", "donut", "polarArea", "radialBar", "radar"].includes(s3) ? l2 = s3 : console.warn("You have specified an unrecognized series type (".concat(s3, ").")), o2 !== s3 && s3 !== "scatter" && h2++;
    }), h2 > 0 && (l2 && console.warn("Chart or series type ".concat(l2, " cannot appear with other chart or series types.")), n2.bar.series.length > 0 && s2.plotOptions.bar.horizontal && (h2 -= n2.bar.series.length, n2.bar = { series: [], i: [] }, i2.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), r2.comboCharts || (r2.comboCharts = h2 > 0);
    var c2 = new Ba(a2, e2), d2 = new Ta(a2, e2);
    a2.pie = new Ea(a2);
    var u2 = new Ha(a2);
    a2.rangeBar = new Oa(a2, e2);
    var g2 = new Ya(a2), p2 = [];
    if (r2.comboCharts) {
      var x2, b2, m2 = new Pi(a2);
      if (n2.area.series.length > 0)
        (x2 = p2).push.apply(x2, f(m2.drawSeriesByGroup(n2.area, r2.areaGroups, "area", c2)));
      if (n2.bar.series.length > 0)
        if (s2.chart.stacked) {
          var v2 = new Ia(a2, e2);
          p2.push(v2.draw(n2.bar.series, n2.bar.i));
        } else
          a2.bar = new Pa(a2, e2), p2.push(a2.bar.draw(n2.bar.series, n2.bar.i));
      if (n2.rangeArea.series.length > 0 && p2.push(c2.draw(n2.rangeArea.series, "rangeArea", n2.rangeArea.i, n2.rangeArea.seriesRangeEnd)), n2.line.series.length > 0)
        (b2 = p2).push.apply(b2, f(m2.drawSeriesByGroup(n2.line, r2.lineGroups, "line", c2)));
      if (n2.candlestick.series.length > 0 && p2.push(d2.draw(n2.candlestick.series, "candlestick", n2.candlestick.i)), n2.boxPlot.series.length > 0 && p2.push(d2.draw(n2.boxPlot.series, "boxPlot", n2.boxPlot.i)), n2.rangeBar.series.length > 0 && p2.push(a2.rangeBar.draw(n2.rangeBar.series, n2.rangeBar.i)), n2.scatter.series.length > 0) {
        var y2 = new Ba(a2, e2, true);
        p2.push(y2.draw(n2.scatter.series, "scatter", n2.scatter.i));
      }
      if (n2.bubble.series.length > 0) {
        var w2 = new Ba(a2, e2, true);
        p2.push(w2.draw(n2.bubble.series, "bubble", n2.bubble.i));
      }
    } else
      switch (s2.chart.type) {
        case "line":
          p2 = c2.draw(r2.series, "line");
          break;
        case "area":
          p2 = c2.draw(r2.series, "area");
          break;
        case "bar":
          if (s2.chart.stacked)
            p2 = new Ia(a2, e2).draw(r2.series);
          else
            a2.bar = new Pa(a2, e2), p2 = a2.bar.draw(r2.series);
          break;
        case "candlestick":
          p2 = new Ta(a2, e2).draw(r2.series, "candlestick");
          break;
        case "boxPlot":
          p2 = new Ta(a2, e2).draw(r2.series, s2.chart.type);
          break;
        case "rangeBar":
          p2 = a2.rangeBar.draw(r2.series);
          break;
        case "rangeArea":
          p2 = c2.draw(r2.seriesRangeStart, "rangeArea", undefined, r2.seriesRangeEnd);
          break;
        case "heatmap":
          p2 = new Xa(a2, e2).draw(r2.series);
          break;
        case "treemap":
          p2 = new Ga(a2, e2).draw(r2.series);
          break;
        case "pie":
        case "donut":
        case "polarArea":
          p2 = a2.pie.draw(r2.series);
          break;
        case "radialBar":
          p2 = u2.draw(r2.series);
          break;
        case "radar":
          p2 = g2.draw(r2.series);
          break;
        default:
          p2 = c2.draw(r2.series);
      }
    return p2;
  } }, { key: "setSVGDimensions", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config;
    i2.chart.width = i2.chart.width || "100%", i2.chart.height = i2.chart.height || "auto", e2.svgWidth = i2.chart.width, e2.svgHeight = i2.chart.height;
    var a2 = v.getDimensions(this.el), s2 = i2.chart.width.toString().split(/[0-9]+/g).pop();
    s2 === "%" ? v.isNumber(a2[0]) && (a2[0].width === 0 && (a2 = v.getDimensions(this.el.parentNode)), e2.svgWidth = a2[0] * parseInt(i2.chart.width, 10) / 100) : s2 !== "px" && s2 !== "" || (e2.svgWidth = parseInt(i2.chart.width, 10));
    var r2 = String(i2.chart.height).toString().split(/[0-9]+/g).pop();
    if (e2.svgHeight !== "auto" && e2.svgHeight !== "")
      if (r2 === "%") {
        var n2 = v.getDimensions(this.el.parentNode);
        e2.svgHeight = n2[1] * parseInt(i2.chart.height, 10) / 100;
      } else
        e2.svgHeight = parseInt(i2.chart.height, 10);
    else
      e2.svgHeight = e2.axisCharts ? e2.svgWidth / 1.61 : e2.svgWidth / 1.2;
    if (e2.svgWidth = Math.max(e2.svgWidth, 0), e2.svgHeight = Math.max(e2.svgHeight, 0), Mi.setAttrs(e2.dom.Paper.node, { width: e2.svgWidth, height: e2.svgHeight }), r2 !== "%") {
      var o2 = i2.chart.sparkline.enabled ? 0 : e2.axisCharts ? i2.chart.parentHeightOffset : 0;
      e2.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(e2.svgHeight + o2, "px");
    }
    e2.dom.elWrap.style.width = "".concat(e2.svgWidth, "px"), e2.dom.elWrap.style.height = "".concat(e2.svgHeight, "px");
  } }, { key: "shiftGraphPosition", value: function() {
    var t3 = this.w.globals, e2 = t3.translateY, i2 = t3.translateX;
    Mi.setAttrs(t3.dom.elGraphical.node, { transform: "translate(".concat(i2, ", ").concat(e2, ")") });
  } }, { key: "resizeNonAxisCharts", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = 0, a2 = t3.config.chart.sparkline.enabled ? 1 : 15;
    a2 += t3.config.grid.padding.bottom, ["top", "bottom"].includes(t3.config.legend.position) && t3.config.legend.show && !t3.config.legend.floating && (i2 = new xa(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
    var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r2 = 2.05 * t3.globals.radialSize;
    if (s2 && !t3.config.chart.sparkline.enabled && t3.config.plotOptions.radialBar.startAngle !== 0) {
      var n2 = v.getBoundingClientRect(s2);
      r2 = n2.bottom;
      var o2 = n2.bottom - n2.top;
      r2 = Math.max(2.05 * t3.globals.radialSize, o2);
    }
    var l2 = Math.ceil(r2 + e2.translateY + i2 + a2);
    e2.dom.elLegendForeign && e2.dom.elLegendForeign.setAttribute("height", l2), t3.config.chart.height && String(t3.config.chart.height).includes("%") || (e2.dom.elWrap.style.height = "".concat(l2, "px"), Mi.setAttrs(e2.dom.Paper.node, { height: l2 }), e2.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(l2, "px"));
  } }, { key: "coreCalculations", value: function() {
    new ea(this.ctx).init();
  } }, { key: "resetGlobals", value: function() {
    var t3 = this, e2 = function() {
      return t3.w.config.series.map(function() {
        return [];
      });
    }, i2 = new Bi, a2 = this.w.globals;
    i2.initGlobalVars(a2), a2.seriesXvalues = e2(), a2.seriesYvalues = e2();
  } }, { key: "isMultipleY", value: function() {
    return !!(Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) && (this.w.globals.isMultipleYAxis = true, true);
  } }, { key: "xySettings", value: function() {
    var t3 = this.w, e2 = null;
    if (t3.globals.axisCharts) {
      if (t3.config.xaxis.crosshairs.position === "back" && new na(this.ctx).drawXCrosshairs(), t3.config.yaxis[0].crosshairs.position === "back" && new na(this.ctx).drawYCrosshairs(), t3.config.xaxis.type === "datetime" && t3.config.xaxis.labels.formatter === undefined) {
        this.ctx.timeScale = new Ua(this.ctx);
        var i2 = [];
        isFinite(t3.globals.minX) && isFinite(t3.globals.maxX) && !t3.globals.isBarHorizontal ? i2 = this.ctx.timeScale.calculateTimeScaleTicks(t3.globals.minX, t3.globals.maxX) : t3.globals.isBarHorizontal && (i2 = this.ctx.timeScale.calculateTimeScaleTicks(t3.globals.minY, t3.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i2);
      }
      e2 = new Pi(this.ctx).getCalculatedRatios();
    }
    return e2;
  } }, { key: "updateSourceChart", value: function(t3) {
    this.ctx.w.globals.selection = undefined, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t3.w.globals.minX, max: t3.w.globals.maxX } } } }, false, false);
  } }, { key: "setupBrushHandler", value: function() {
    var t3 = this, e2 = this.ctx, i2 = this.w;
    if (i2.config.chart.brush.enabled && typeof i2.config.chart.events.selection != "function") {
      var a2 = Array.isArray(i2.config.chart.brush.targets) ? i2.config.chart.brush.targets : [i2.config.chart.brush.target];
      a2.forEach(function(i3) {
        var a3 = e2.constructor.getChartByID(i3);
        a3.w.globals.brushSource = t3.ctx, typeof a3.w.config.chart.events.zoomed != "function" && (a3.w.config.chart.events.zoomed = function() {
          return t3.updateSourceChart(a3);
        }), typeof a3.w.config.chart.events.scrolled != "function" && (a3.w.config.chart.events.scrolled = function() {
          return t3.updateSourceChart(a3);
        });
      }), i2.config.chart.events.selection = function(t4, i3) {
        a2.forEach(function(t5) {
          e2.constructor.getChartByID(t5).ctx.updateHelpers._updateOptions({ xaxis: { min: i3.xaxis.min, max: i3.xaxis.max } }, false, false, false, false);
        });
      };
    }
  } }]), t2;
}();
var Za = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "_updateOptions", value: function(t3) {
    var e2 = this, i2 = arguments.length > 1 && arguments[1] !== undefined && arguments[1], a2 = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2], s2 = !(arguments.length > 3 && arguments[3] !== undefined) || arguments[3], r2 = arguments.length > 4 && arguments[4] !== undefined && arguments[4];
    return new Promise(function(n2) {
      var o2 = [e2.ctx];
      s2 && (o2 = e2.ctx.getSyncedCharts()), e2.ctx.w.globals.isExecCalled && (o2 = [e2.ctx], e2.ctx.w.globals.isExecCalled = false), o2.forEach(function(s3, l2) {
        var h2 = s3.w;
        if (h2.globals.shouldAnimate = a2, i2 || (h2.globals.resized = true, h2.globals.dataChanged = true, a2 && s3.series.getPreviousPaths()), t3 && b(t3) === "object" && (s3.config = new Wi(t3), t3 = Pi.extendArrayProps(s3.config, t3, h2), s3.w.globals.chartID !== e2.ctx.w.globals.chartID && delete t3.series, h2.config = v.extend(h2.config, t3), r2 && (h2.globals.lastXAxis = t3.xaxis ? v.clone(t3.xaxis) : [], h2.globals.lastYAxis = t3.yaxis ? v.clone(t3.yaxis) : [], h2.globals.initialConfig = v.extend({}, h2.config), h2.globals.initialSeries = v.clone(h2.config.series), t3.series))) {
          for (var c2 = 0;c2 < h2.globals.collapsedSeriesIndices.length; c2++) {
            var d2 = h2.config.series[h2.globals.collapsedSeriesIndices[c2]];
            h2.globals.collapsedSeries[c2].data = h2.globals.axisCharts ? d2.data.slice() : d2;
          }
          for (var u2 = 0;u2 < h2.globals.ancillaryCollapsedSeriesIndices.length; u2++) {
            var g2 = h2.config.series[h2.globals.ancillaryCollapsedSeriesIndices[u2]];
            h2.globals.ancillaryCollapsedSeries[u2].data = h2.globals.axisCharts ? g2.data.slice() : g2;
          }
          s3.series.emptyCollapsedSeries(h2.config.series);
        }
        return s3.update(t3).then(function() {
          l2 === o2.length - 1 && n2(s3);
        });
      });
    });
  } }, { key: "_updateSeries", value: function(t3, e2) {
    var i2 = this, a2 = arguments.length > 2 && arguments[2] !== undefined && arguments[2];
    return new Promise(function(s2) {
      var r2, n2 = i2.w;
      return n2.globals.shouldAnimate = e2, n2.globals.dataChanged = true, e2 && i2.ctx.series.getPreviousPaths(), n2.globals.axisCharts ? ((r2 = t3.map(function(t4, e3) {
        return i2._extendSeries(t4, e3);
      })).length === 0 && (r2 = [{ data: [] }]), n2.config.series = r2) : n2.config.series = t3.slice(), a2 && (n2.globals.initialConfig.series = v.clone(n2.config.series), n2.globals.initialSeries = v.clone(n2.config.series)), i2.ctx.update().then(function() {
        s2(i2.ctx);
      });
    });
  } }, { key: "_extendSeries", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.series[e2];
    return u(u({}, i2.config.series[e2]), {}, { name: t3.name ? t3.name : a2 == null ? undefined : a2.name, color: t3.color ? t3.color : a2 == null ? undefined : a2.color, type: t3.type ? t3.type : a2 == null ? undefined : a2.type, group: t3.group ? t3.group : a2 == null ? undefined : a2.group, hidden: t3.hidden !== undefined ? t3.hidden : a2 == null ? undefined : a2.hidden, data: t3.data ? t3.data : a2 == null ? undefined : a2.data, zIndex: t3.zIndex !== undefined ? t3.zIndex : e2 });
  } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
    var i2 = this.w, a2 = null, s2 = ".apexcharts-series[data\\:realIndex='".concat(t3, "']");
    return i2.globals.axisCharts ? a2 = i2.globals.dom.Paper.findOne("".concat(s2, " path[j='").concat(e2, "'], ").concat(s2, " circle[j='").concat(e2, "'], ").concat(s2, " rect[j='").concat(e2, "']")) : e2 === undefined && (a2 = i2.globals.dom.Paper.findOne("".concat(s2, " path[j='").concat(t3, "']")), i2.config.chart.type !== "pie" && i2.config.chart.type !== "polarArea" && i2.config.chart.type !== "donut" || this.ctx.pie.pieClicked(t3)), a2 ? (new Mi(this.ctx).pathMouseDown(a2, null), a2.node ? a2.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
  } }, { key: "forceXAxisUpdate", value: function(t3) {
    var e2 = this.w;
    if (["min", "max"].forEach(function(i3) {
      t3.xaxis[i3] !== undefined && (e2.config.xaxis[i3] = t3.xaxis[i3], e2.globals.lastXAxis[i3] = t3.xaxis[i3]);
    }), t3.xaxis.categories && t3.xaxis.categories.length && (e2.config.xaxis.categories = t3.xaxis.categories), e2.config.xaxis.convertedCatToNumeric) {
      var i2 = new Ni(t3);
      t3 = i2.convertCatToNumericXaxis(t3, this.ctx);
    }
    return t3;
  } }, { key: "forceYAxisUpdate", value: function(t3) {
    return t3.chart && t3.chart.stacked && t3.chart.stackType === "100%" && (Array.isArray(t3.yaxis) ? t3.yaxis.forEach(function(e2, i2) {
      t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
    }) : (t3.yaxis.min = 0, t3.yaxis.max = 100)), t3;
  } }, { key: "revertDefaultAxisMinMax", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.globals.lastXAxis, s2 = i2.globals.lastYAxis;
    t3 && t3.xaxis && (a2 = t3.xaxis), t3 && t3.yaxis && (s2 = t3.yaxis), i2.config.xaxis.min = a2.min, i2.config.xaxis.max = a2.max;
    var r2 = function(t4) {
      s2[t4] !== undefined && (i2.config.yaxis[t4].min = s2[t4].min, i2.config.yaxis[t4].max = s2[t4].max);
    };
    i2.config.yaxis.map(function(t4, a3) {
      i2.globals.zoomed || s2[a3] !== undefined ? r2(a3) : e2.ctx.opts.yaxis[a3] !== undefined && (t4.min = e2.ctx.opts.yaxis[a3].min, t4.max = e2.ctx.opts.yaxis[a3].max);
    });
  } }]), t2;
}();
(function() {
  function t2() {
    for (var t3 = arguments.length > 0 && arguments[0] !== h2 ? arguments[0] : [], s3 = arguments.length > 1 ? arguments[1] : h2, r2 = arguments.length > 2 ? arguments[2] : h2, n2 = arguments.length > 3 ? arguments[3] : h2, o2 = arguments.length > 4 ? arguments[4] : h2, l2 = arguments.length > 5 ? arguments[5] : h2, h2 = arguments.length > 6 ? arguments[6] : h2, c2 = t3.slice(s3, r2 || h2), d2 = n2.slice(o2, l2 || h2), u2 = 0, g2 = { pos: [0, 0], start: [0, 0] }, p2 = { pos: [0, 0], start: [0, 0] };; ) {
      if (c2[u2] = e2.call(g2, c2[u2]), d2[u2] = e2.call(p2, d2[u2]), c2[u2][0] != d2[u2][0] || c2[u2][0] == "M" || c2[u2][0] == "A" && (c2[u2][4] != d2[u2][4] || c2[u2][5] != d2[u2][5]) ? (Array.prototype.splice.apply(c2, [u2, 1].concat(a2.call(g2, c2[u2]))), Array.prototype.splice.apply(d2, [u2, 1].concat(a2.call(p2, d2[u2])))) : (c2[u2] = i2.call(g2, c2[u2]), d2[u2] = i2.call(p2, d2[u2])), ++u2 == c2.length && u2 == d2.length)
        break;
      u2 == c2.length && c2.push(["C", g2.pos[0], g2.pos[1], g2.pos[0], g2.pos[1], g2.pos[0], g2.pos[1]]), u2 == d2.length && d2.push(["C", p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1]]);
    }
    return { start: c2, dest: d2 };
  }
  function e2(t3) {
    switch (t3[0]) {
      case "z":
      case "Z":
        t3[0] = "L", t3[1] = this.start[0], t3[2] = this.start[1];
        break;
      case "H":
        t3[0] = "L", t3[2] = this.pos[1];
        break;
      case "V":
        t3[0] = "L", t3[2] = t3[1], t3[1] = this.pos[0];
        break;
      case "T":
        t3[0] = "Q", t3[3] = t3[1], t3[4] = t3[2], t3[1] = this.reflection[1], t3[2] = this.reflection[0];
        break;
      case "S":
        t3[0] = "C", t3[6] = t3[4], t3[5] = t3[3], t3[4] = t3[2], t3[3] = t3[1], t3[2] = this.reflection[1], t3[1] = this.reflection[0];
    }
    return t3;
  }
  function i2(t3) {
    var e3 = t3.length;
    return this.pos = [t3[e3 - 2], t3[e3 - 1]], "SCQT".indexOf(t3[0]) != -1 && (this.reflection = [2 * this.pos[0] - t3[e3 - 4], 2 * this.pos[1] - t3[e3 - 3]]), t3;
  }
  function a2(t3) {
    var e3 = [t3];
    switch (t3[0]) {
      case "M":
        return this.pos = this.start = [t3[1], t3[2]], e3;
      case "L":
        t3[5] = t3[3] = t3[1], t3[6] = t3[4] = t3[2], t3[1] = this.pos[0], t3[2] = this.pos[1];
        break;
      case "Q":
        t3[6] = t3[4], t3[5] = t3[3], t3[4] = 1 * t3[4] / 3 + 2 * t3[2] / 3, t3[3] = 1 * t3[3] / 3 + 2 * t3[1] / 3, t3[2] = 1 * this.pos[1] / 3 + 2 * t3[2] / 3, t3[1] = 1 * this.pos[0] / 3 + 2 * t3[1] / 3;
        break;
      case "A":
        e3 = function(t4, e4) {
          var i3, a3, s3, r2, n2, o2, l2, h2, c2, d2, u2, g2, p2, f2, x2, b2, m2, v2, y2, w2, k2, A2, C2, S2, L2, M2, P2 = Math.abs(e4[1]), I2 = Math.abs(e4[2]), T2 = e4[3] % 360, z2 = e4[4], X2 = e4[5], R2 = e4[6], E2 = e4[7], Y2 = new bt(t4), H2 = new bt(R2, E2), O2 = [];
          if (P2 === 0 || I2 === 0 || Y2.x === H2.x && Y2.y === H2.y)
            return [["C", Y2.x, Y2.y, H2.x, H2.y, H2.x, H2.y]];
          i3 = new bt((Y2.x - H2.x) / 2, (Y2.y - H2.y) / 2).transform(new vt().rotate(T2)), a3 = i3.x * i3.x / (P2 * P2) + i3.y * i3.y / (I2 * I2), a3 > 1 && (P2 *= a3 = Math.sqrt(a3), I2 *= a3);
          s3 = new vt().rotate(T2).scale(1 / P2, 1 / I2).rotate(-T2), Y2 = Y2.transform(s3), H2 = H2.transform(s3), r2 = [H2.x - Y2.x, H2.y - Y2.y], o2 = r2[0] * r2[0] + r2[1] * r2[1], n2 = Math.sqrt(o2), r2[0] /= n2, r2[1] /= n2, l2 = o2 < 4 ? Math.sqrt(1 - o2 / 4) : 0, z2 === X2 && (l2 *= -1);
          h2 = new bt((H2.x + Y2.x) / 2 + l2 * -r2[1], (H2.y + Y2.y) / 2 + l2 * r2[0]), c2 = new bt(Y2.x - h2.x, Y2.y - h2.y), d2 = new bt(H2.x - h2.x, H2.y - h2.y), u2 = Math.acos(c2.x / Math.sqrt(c2.x * c2.x + c2.y * c2.y)), c2.y < 0 && (u2 *= -1);
          g2 = Math.acos(d2.x / Math.sqrt(d2.x * d2.x + d2.y * d2.y)), d2.y < 0 && (g2 *= -1);
          X2 && u2 > g2 && (g2 += 2 * Math.PI);
          !X2 && u2 < g2 && (g2 -= 2 * Math.PI);
          for (f2 = Math.ceil(2 * Math.abs(u2 - g2) / Math.PI), b2 = [], m2 = u2, p2 = (g2 - u2) / f2, x2 = 4 * Math.tan(p2 / 4) / 3, k2 = 0;k2 <= f2; k2++)
            y2 = Math.cos(m2), v2 = Math.sin(m2), w2 = new bt(h2.x + y2, h2.y + v2), b2[k2] = [new bt(w2.x + x2 * v2, w2.y - x2 * y2), w2, new bt(w2.x - x2 * v2, w2.y + x2 * y2)], m2 += p2;
          for (b2[0][0] = b2[0][1].clone(), b2[b2.length - 1][2] = b2[b2.length - 1][1].clone(), s3 = new vt().rotate(T2).scale(P2, I2).rotate(-T2), k2 = 0, A2 = b2.length;k2 < A2; k2++)
            b2[k2][0] = b2[k2][0].transform(s3), b2[k2][1] = b2[k2][1].transform(s3), b2[k2][2] = b2[k2][2].transform(s3);
          for (k2 = 1, A2 = b2.length;k2 < A2; k2++)
            C2 = (w2 = b2[k2 - 1][2]).x, S2 = w2.y, L2 = (w2 = b2[k2][0]).x, M2 = w2.y, R2 = (w2 = b2[k2][1]).x, E2 = w2.y, O2.push(["C", C2, S2, L2, M2, R2, E2]);
          return O2;
        }(this.pos, t3), t3 = e3[0];
    }
    return t3[0] = "C", this.pos = [t3[5], t3[6]], this.reflection = [2 * t3[5] - t3[3], 2 * t3[6] - t3[4]], e3;
  }
  function s2() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [], e3 = arguments.length > 1 ? arguments[1] : undefined;
    if (e3 === false)
      return false;
    for (var i3 = e3, a3 = t3.length;i3 < a3; ++i3)
      if (t3[i3][0] == "M")
        return i3;
    return false;
  }
  Q(Ee, { morph: function(e3, i3, a3, r2, n2) {
    for (var o2 = this.parse(e3), l2 = this.parse(i3), h2 = 0, c2 = 0, d2 = false, u2 = false;h2 !== false || c2 !== false; ) {
      var g2;
      d2 = s2(o2, h2 !== false && h2 + 1), u2 = s2(l2, c2 !== false && c2 + 1), h2 === false && (h2 = (g2 = new Ee(p2.start).bbox()).height == 0 || g2.width == 0 ? o2.push(o2[0]) - 1 : o2.push(["M", g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1), c2 === false && (c2 = (g2 = new Ee(p2.dest).bbox()).height == 0 || g2.width == 0 ? l2.push(l2[0]) - 1 : l2.push(["M", g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1);
      var p2 = t2(o2, h2, d2, l2, c2, u2);
      o2 = o2.slice(0, h2).concat(p2.start, d2 === false ? [] : o2.slice(d2)), l2 = l2.slice(0, c2).concat(p2.dest, u2 === false ? [] : l2.slice(u2)), h2 = d2 !== false && h2 + p2.start.length, c2 = u2 !== false && c2 + p2.dest.length;
    }
    this._array = o2, this.destination = new Ee, this.destination._array = l2;
    var f2 = this.fromArray(o2.map(function(t3, e4) {
      var i4 = l2[e4].map(function(i5, s3) {
        return s3 === 0 ? i5 : r2.step(t3[s3], l2[e4][s3], a3, n2[e4], n2);
      });
      return i4;
    }));
    return f2;
  } });
})();
var $a = (t2) => (t2.changedTouches && (t2 = t2.changedTouches[0]), { x: t2.clientX, y: t2.clientY });

class Ja {
  constructor(t2) {
    t2.remember("_draggable", this), this.el = t2, this.drag = this.drag.bind(this), this.startDrag = this.startDrag.bind(this), this.endDrag = this.endDrag.bind(this);
  }
  init(t2) {
    t2 ? (this.el.on("mousedown.drag", this.startDrag), this.el.on("touchstart.drag", this.startDrag, { passive: false })) : (this.el.off("mousedown.drag"), this.el.off("touchstart.drag"));
  }
  startDrag(t2) {
    const e2 = !t2.type.indexOf("mouse");
    if (e2 && t2.which !== 1 && t2.buttons !== 0)
      return;
    if (this.el.dispatch("beforedrag", { event: t2, handler: this }).defaultPrevented)
      return;
    t2.preventDefault(), t2.stopPropagation(), this.init(false), this.box = this.el.bbox(), this.lastClick = this.el.point($a(t2));
    const i2 = (e2 ? "mouseup" : "touchend") + ".drag";
    zt(window, (e2 ? "mousemove" : "touchmove") + ".drag", this.drag, this, { passive: false }), zt(window, i2, this.endDrag, this, { passive: false }), this.el.fire("dragstart", { event: t2, handler: this, box: this.box });
  }
  drag(t2) {
    const { box: e2, lastClick: i2 } = this, a2 = this.el.point($a(t2)), s2 = a2.x - i2.x, r2 = a2.y - i2.y;
    if (!s2 && !r2)
      return e2;
    const n2 = e2.x + s2, o2 = e2.y + r2;
    this.box = new kt(n2, o2, e2.w, e2.h), this.lastClick = a2, this.el.dispatch("dragmove", { event: t2, handler: this, box: this.box }).defaultPrevented || this.move(n2, o2);
  }
  move(t2, e2) {
    this.el.type === "svg" ? gi.prototype.move.call(this.el, t2, e2) : this.el.move(t2, e2);
  }
  endDrag(t2) {
    this.drag(t2), this.el.fire("dragend", { event: t2, handler: this, box: this.box }), Xt(window, "mousemove.drag"), Xt(window, "touchmove.drag"), Xt(window, "mouseup.drag"), Xt(window, "touchend.drag"), this.init(true);
  }
}
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias SchÃ¤fer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
Q(Gt, { draggable(t2 = true) {
  return (this.remember("_draggable") || new Ja(this)).init(t2), this;
} });
var ts = class {
  constructor(t2) {
    this.el = t2, t2.remember("_selectHandler", this), this.selection = new gi, this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.createRot = t2.createRot || this.createRotFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.updateRot = t2.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2)
      return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((t2, e2, i2) => {
      const a2 = this.order[e2];
      this.createHandle.call(this, this.selection, t2, e2, i2, a2), this.selection.get(e2 + 1).addClass("svg_select_handle svg_select_handle_" + a2).on("mousedown.selection touchstart.selection", Qa(a2, this.el, this.handlePoints, e2));
    });
  }
  createHandleFn(t2) {
    t2.polyline();
  }
  updateHandleFn(t2, e2, i2, a2) {
    const s2 = a2.at(i2 - 1), r2 = a2[(i2 + 1) % a2.length], n2 = e2, o2 = [n2[0] - s2[0], n2[1] - s2[1]], l2 = [n2[0] - r2[0], n2[1] - r2[1]], h2 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), c2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), d2 = [o2[0] / h2, o2[1] / h2], u2 = [l2[0] / c2, l2[1] / c2], g2 = [n2[0] - 10 * d2[0], n2[1] - 10 * d2[1]], p2 = [n2[0] - 10 * u2[0], n2[1] - 10 * u2[1]];
    t2.plot([g2, n2, p2]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((t2, e2, i2) => {
      const a2 = this.order[e2];
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2, a2);
    });
  }
  createRotFn(t2) {
    t2.line(), t2.circle(5);
  }
  getPoint(t2) {
    return this.handlePoints[this.order.indexOf(t2)];
  }
  getPointHandle(t2) {
    return this.selection.get(this.order.indexOf(t2) + 1);
  }
  updateRotFn(t2, e2) {
    const i2 = this.getPoint("t");
    t2.get(0).plot(i2[0], i2[1], e2[0], e2[1]), t2.get(1).center(e2[0], e2[1]);
  }
  createRotationHandle() {
    const t2 = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Qa("rot", this.el, this.handlePoints));
    this.createRot.call(this, t2);
  }
  updateRotationHandle() {
    const t2 = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(t2, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const t2 = this.el.bbox(), e2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(t2).map((t3) => Ka(t3, e2)), this.rotationPoint = Ka(this.getRotationPoint(t2), e2);
  }
  getHandlePoints({ x: t2, x2: e2, y: i2, y2: a2, cx: s2, cy: r2 } = this.el.bbox()) {
    return [[t2, i2], [s2, i2], [e2, i2], [e2, r2], [e2, a2], [s2, a2], [t2, a2], [t2, r2]];
  }
  getRotationPoint({ y: t2, cx: e2 } = this.el.bbox()) {
    return [e2, t2 - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
};
var es = (t2) => function(e2 = true, i2 = {}) {
  typeof e2 == "object" && (i2 = e2, e2 = true);
  let a2 = this.remember("_" + t2.name);
  return a2 || (e2.prototype instanceof ts ? (a2 = new e2(this), e2 = true) : a2 = new t2(this), this.remember("_" + t2.name, a2)), a2.active(e2, i2), this;
};
/*!
* @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
* @version 2.0.4
* https://github.com/svgdotjs/svg.resize.js
*
* @copyright [object Object]
* @license MIT
*
* BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
*/
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias SchÃ¤fer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
Q(Gt, { select: es(ts) }), Q([Ge, je, xe], { pointSelect: es(class {
  constructor(t2) {
    this.el = t2, t2.remember("_pointSelectHandler", this), this.selection = new gi, this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2)
      return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((t2, e2, i2) => {
      this.createHandle.call(this, this.selection, t2, e2, i2), this.selection.get(e2 + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Qa("point", this.el, this.points, e2));
    });
  }
  createHandleFn(t2) {
    t2.circle(5);
  }
  updateHandleFn(t2, e2) {
    t2.center(e2[0], e2[1]);
  }
  updatePointHandles() {
    this.points.forEach((t2, e2, i2) => {
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2);
    });
  }
  updatePoints() {
    const t2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e2) => Ka(e2, t2));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });

class ss {
  constructor(t2) {
    this.el = t2, t2.remember("_selectHandler", this), this.selection = new gi, this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.createRot = t2.createRot || this.createRotFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.updateRot = t2.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2)
      return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((t2, e2, i2) => {
      const a2 = this.order[e2];
      this.createHandle.call(this, this.selection, t2, e2, i2, a2), this.selection.get(e2 + 1).addClass("svg_select_handle svg_select_handle_" + a2).on("mousedown.selection touchstart.selection", is(a2, this.el, this.handlePoints, e2));
    });
  }
  createHandleFn(t2) {
    t2.polyline();
  }
  updateHandleFn(t2, e2, i2, a2) {
    const s2 = a2.at(i2 - 1), r2 = a2[(i2 + 1) % a2.length], n2 = e2, o2 = [n2[0] - s2[0], n2[1] - s2[1]], l2 = [n2[0] - r2[0], n2[1] - r2[1]], h2 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), c2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), d2 = [o2[0] / h2, o2[1] / h2], u2 = [l2[0] / c2, l2[1] / c2], g2 = [n2[0] - 10 * d2[0], n2[1] - 10 * d2[1]], p2 = [n2[0] - 10 * u2[0], n2[1] - 10 * u2[1]];
    t2.plot([g2, n2, p2]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((t2, e2, i2) => {
      const a2 = this.order[e2];
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2, a2);
    });
  }
  createRotFn(t2) {
    t2.line(), t2.circle(5);
  }
  getPoint(t2) {
    return this.handlePoints[this.order.indexOf(t2)];
  }
  getPointHandle(t2) {
    return this.selection.get(this.order.indexOf(t2) + 1);
  }
  updateRotFn(t2, e2) {
    const i2 = this.getPoint("t");
    t2.get(0).plot(i2[0], i2[1], e2[0], e2[1]), t2.get(1).center(e2[0], e2[1]);
  }
  createRotationHandle() {
    const t2 = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", is("rot", this.el, this.handlePoints));
    this.createRot.call(this, t2);
  }
  updateRotationHandle() {
    const t2 = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(t2, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const t2 = this.el.bbox(), e2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(t2).map((t3) => as(t3, e2)), this.rotationPoint = as(this.getRotationPoint(t2), e2);
  }
  getHandlePoints({ x: t2, x2: e2, y: i2, y2: a2, cx: s2, cy: r2 } = this.el.bbox()) {
    return [[t2, i2], [s2, i2], [e2, i2], [e2, r2], [e2, a2], [s2, a2], [t2, a2], [t2, r2]];
  }
  getRotationPoint({ y: t2, cx: e2 } = this.el.bbox()) {
    return [e2, t2 - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
}
var rs = (t2) => function(e2 = true, i2 = {}) {
  typeof e2 == "object" && (i2 = e2, e2 = true);
  let a2 = this.remember("_" + t2.name);
  return a2 || (e2.prototype instanceof ss ? (a2 = new e2(this), e2 = true) : a2 = new t2(this), this.remember("_" + t2.name, a2)), a2.active(e2, i2), this;
};
Q(Gt, { select: rs(ss) }), Q([Ge, je, xe], { pointSelect: rs(class {
  constructor(t2) {
    this.el = t2, t2.remember("_pointSelectHandler", this), this.selection = new gi, this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2)
      return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((t2, e2, i2) => {
      this.createHandle.call(this, this.selection, t2, e2, i2), this.selection.get(e2 + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", is("point", this.el, this.points, e2));
    });
  }
  createHandleFn(t2) {
    t2.circle(5);
  }
  updateHandleFn(t2, e2) {
    t2.center(e2[0], e2[1]);
  }
  updatePointHandles() {
    this.points.forEach((t2, e2, i2) => {
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2);
    });
  }
  updatePoints() {
    const t2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e2) => as(e2, t2));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
var ns = (t2) => (t2.changedTouches && (t2 = t2.changedTouches[0]), { x: t2.clientX, y: t2.clientY });
var os = (t2) => {
  let e2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
  for (let r2 = 0;r2 < t2.length; r2++) {
    const n2 = t2[r2];
    e2 = Math.min(e2, n2[0]), i2 = Math.min(i2, n2[1]), a2 = Math.max(a2, n2[0]), s2 = Math.max(s2, n2[1]);
  }
  return new kt(e2, i2, a2 - e2, s2 - i2);
};

class ls {
  constructor(t2) {
    this.el = t2, t2.remember("_ResizeHandler", this), this.lastCoordinates = null, this.eventType = "", this.lastEvent = null, this.handleResize = this.handleResize.bind(this), this.resize = this.resize.bind(this), this.endResize = this.endResize.bind(this), this.rotate = this.rotate.bind(this), this.movePoint = this.movePoint.bind(this);
  }
  active(t2, e2) {
    this.preserveAspectRatio = e2.preserveAspectRatio ?? false, this.aroundCenter = e2.aroundCenter ?? false, this.grid = e2.grid ?? 0, this.degree = e2.degree ?? 0, this.el.off(".resize"), t2 && (this.el.on(["lt.resize", "rt.resize", "rb.resize", "lb.resize", "t.resize", "r.resize", "b.resize", "l.resize", "rot.resize", "point.resize"], this.handleResize), this.lastEvent && (this.eventType === "rot" ? this.rotate(this.lastEvent) : this.eventType === "point" ? this.movePoint(this.lastEvent) : this.resize(this.lastEvent)));
  }
  handleResize(t2) {
    this.eventType = t2.type;
    const { event: e2, index: i2, points: a2 } = t2.detail, s2 = !e2.type.indexOf("mouse");
    if (s2 && (e2.which || e2.buttons) !== 1)
      return;
    if (this.el.dispatch("beforeresize", { event: t2, handler: this }).defaultPrevented)
      return;
    this.box = this.el.bbox(), this.startPoint = this.el.point(ns(e2)), this.index = i2, this.points = a2.slice();
    const r2 = (s2 ? "mousemove" : "touchmove") + ".resize", n2 = (s2 ? "mouseup" : "touchcancel.resize touchend") + ".resize";
    t2.type === "point" ? zt(window, r2, this.movePoint) : t2.type === "rot" ? zt(window, r2, this.rotate) : zt(window, r2, this.resize), zt(window, n2, this.endResize);
  }
  resize(t2) {
    this.lastEvent = t2;
    const e2 = this.snapToGrid(this.el.point(ns(t2)));
    let i2 = e2.x - this.startPoint.x, a2 = e2.y - this.startPoint.y;
    this.preserveAspectRatio && this.aroundCenter && (i2 *= 2, a2 *= 2);
    const s2 = this.box.x + i2, r2 = this.box.y + a2, n2 = this.box.x2 + i2, o2 = this.box.y2 + a2;
    let l2 = new kt(this.box);
    if (this.eventType.includes("l") && (l2.x = Math.min(s2, this.box.x2), l2.x2 = Math.max(s2, this.box.x2)), this.eventType.includes("r") && (l2.x = Math.min(n2, this.box.x), l2.x2 = Math.max(n2, this.box.x)), this.eventType.includes("t") && (l2.y = Math.min(r2, this.box.y2), l2.y2 = Math.max(r2, this.box.y2)), this.eventType.includes("b") && (l2.y = Math.min(o2, this.box.y), l2.y2 = Math.max(o2, this.box.y)), l2.width = l2.x2 - l2.x, l2.height = l2.y2 - l2.y, this.preserveAspectRatio) {
      const t3 = l2.width / this.box.width, e3 = l2.height / this.box.height, i3 = ["lt", "t", "rt", "r", "rb", "b", "lb", "l"], a3 = (i3.indexOf(this.eventType) + 4) % i3.length, s3 = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[a3];
      let r3 = this.eventType.includes("t") || this.eventType.includes("b") ? e3 : t3;
      r3 = this.eventType.length === 2 ? Math.max(t3, e3) : r3, l2 = function(t4, e4, i4) {
        const a4 = [[t4.x, t4.y], [t4.x + t4.width, t4.y], [t4.x + t4.width, t4.y + t4.height], [t4.x, t4.y + t4.height]].map(([t5, a5]) => {
          const s4 = t5 - e4[0], r4 = (a5 - e4[1]) * i4;
          return [s4 * i4 + e4[0], r4 + e4[1]];
        });
        return os(a4);
      }(this.box, s3, r3);
    }
    this.el.dispatch("resize", { box: new kt(l2), angle: 0, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.size(l2.width, l2.height).move(l2.x, l2.y);
  }
  movePoint(t2) {
    this.lastEvent = t2;
    const { x: e2, y: i2 } = this.snapToGrid(this.el.point(ns(t2))), a2 = this.el.array().slice();
    a2[this.index] = [e2, i2], this.el.dispatch("resize", { box: os(a2), angle: 0, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.plot(a2);
  }
  rotate(t2) {
    this.lastEvent = t2;
    const e2 = this.startPoint, i2 = this.el.point(ns(t2)), { cx: a2, cy: s2 } = this.box, r2 = e2.x - a2, n2 = e2.y - s2, o2 = i2.x - a2, l2 = i2.y - s2, h2 = Math.sqrt(r2 * r2 + n2 * n2) * Math.sqrt(o2 * o2 + l2 * l2);
    if (h2 === 0)
      return;
    let c2 = Math.acos((r2 * o2 + n2 * l2) / h2) / Math.PI * 180;
    if (!c2)
      return;
    i2.x < e2.x && (c2 = -c2);
    const d2 = new vt(this.el), { x: u2, y: g2 } = new bt(a2, s2).transformO(d2), { rotate: p2 } = d2.decompose(), f2 = this.snapToAngle(p2 + c2) - p2;
    this.el.dispatch("resize", { box: this.box, angle: f2, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.transform(d2.rotateO(f2, u2, g2));
  }
  endResize(t2) {
    this.eventType !== "rot" && this.eventType !== "point" && this.resize(t2), this.lastEvent = null, this.eventType = "", Xt(window, "mousemove.resize touchmove.resize"), Xt(window, "mouseup.resize touchend.resize");
  }
  snapToGrid(t2) {
    return this.grid && (t2.x = Math.round(t2.x / this.grid) * this.grid, t2.y = Math.round(t2.y / this.grid) * this.grid), t2;
  }
  snapToAngle(t2) {
    return this.degree && (t2 = Math.round(t2 / this.degree) * this.degree), t2;
  }
}
Q(Gt, { resize: function(t2 = true, e2 = {}) {
  typeof t2 == "object" && (e2 = t2, t2 = true);
  let i2 = this.remember("_ResizeHandler");
  return i2 || (t2.prototype instanceof ls ? (i2 = new t2(this), t2 = true) : i2 = new ls(this), this.remember("_resizeHandler", i2)), i2.active(t2, e2), this;
} }), window.SVG === undefined && (window.SVG = yi), window.Apex === undefined && (window.Apex = {});
var hs = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "initModules", value: function() {
    this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "highlightSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new y(this.ctx), this.ctx.axes = new ra(this.ctx), this.ctx.core = new qa(this.ctx.el, this.ctx), this.ctx.config = new Wi({}), this.ctx.data = new $i(this.ctx), this.ctx.grid = new Ki(this.ctx), this.ctx.graphics = new Mi(this.ctx), this.ctx.coreUtils = new Pi(this.ctx), this.ctx.crosshairs = new na(this.ctx), this.ctx.events = new aa(this.ctx), this.ctx.exports = new Ji(this.ctx), this.ctx.fill = new ji(this.ctx), this.ctx.localization = new sa(this.ctx), this.ctx.options = new Oi, this.ctx.responsive = new oa(this.ctx), this.ctx.series = new Zi(this.ctx), this.ctx.theme = new la(this.ctx), this.ctx.formatters = new Xi(this.ctx), this.ctx.titleSubtitle = new ha(this.ctx), this.ctx.legend = new xa(this.ctx), this.ctx.toolbar = new ba(this.ctx), this.ctx.tooltip = new Sa(this.ctx), this.ctx.dimensions = new pa(this.ctx), this.ctx.updateHelpers = new Za(this.ctx), this.ctx.zoomPanSelection = new ma(this.ctx), this.ctx.w.globals.tooltip = new Sa(this.ctx);
  } }]), t2;
}();
var cs = function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "clear", value: function(t3) {
    var e2 = t3.isUpdating;
    this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e2 });
  } }, { key: "killSVG", value: function(t3) {
    t3.each(function() {
      this.removeClass("*"), this.off();
    }, true), t3.clear();
  } }, { key: "clearDomElements", value: function(t3) {
    var e2 = this, i2 = t3.isUpdating, a2 = this.w.globals.dom.Paper.node;
    a2.parentNode && a2.parentNode.parentNode && !i2 && (a2.parentNode.parentNode.style.minHeight = "unset");
    var s2 = this.w.globals.dom.baseEl;
    s2 && this.ctx.eventList.forEach(function(t4) {
      s2.removeEventListener(t4, e2.ctx.events.documentEvent);
    });
    var r2 = this.w.globals.dom;
    if (this.ctx.el !== null)
      for (;this.ctx.el.firstChild; )
        this.ctx.el.removeChild(this.ctx.el.firstChild);
    this.killSVG(r2.Paper), r2.Paper.remove(), r2.elWrap = null, r2.elGraphical = null, r2.elLegendWrap = null, r2.elLegendForeign = null, r2.baseEl = null, r2.elGridRect = null, r2.elGridRectMask = null, r2.elGridRectBarMask = null, r2.elGridRectMarkerMask = null, r2.elForecastMask = null, r2.elNonForecastMask = null, r2.elDefs = null;
  } }]), t2;
}();
var ds = new WeakMap;
var us = function() {
  function t2(e2, a2) {
    i(this, t2), this.opts = a2, this.ctx = this, this.w = new Gi(a2).init(), this.el = e2, this.w.globals.cuid = v.randomId(), this.w.globals.chartID = this.w.config.chart.id ? v.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new hs(this).initModules(), this.create = v.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }
  return s(t2, [{ key: "render", value: function() {
    var t3 = this;
    return new Promise(function(e2, i2) {
      if (v.elementExists(t3.el)) {
        Apex._chartInstances === undefined && (Apex._chartInstances = []), t3.w.config.chart.id && Apex._chartInstances.push({ id: t3.w.globals.chartID, group: t3.w.config.chart.group, chart: t3 }), t3.setLocale(t3.w.config.chart.defaultLocale);
        var a2 = t3.w.config.chart.events.beforeMount;
        typeof a2 == "function" && a2(t3, t3.w), t3.events.fireEvent("beforeMount", [t3, t3.w]), window.addEventListener("resize", t3.windowResizeHandler), function(t4, e3) {
          var i3 = false;
          if (t4.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            var a3 = t4.getBoundingClientRect();
            t4.style.display !== "none" && a3.width !== 0 || (i3 = true);
          }
          var s3 = new ResizeObserver(function(a4) {
            i3 && e3.call(t4, a4), i3 = true;
          });
          t4.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t4.children).forEach(function(t5) {
            return s3.observe(t5);
          }) : s3.observe(t4), ds.set(e3, s3);
        }(t3.el.parentNode, t3.parentResizeHandler);
        var s2 = t3.el.getRootNode && t3.el.getRootNode(), r2 = v.is("ShadowRoot", s2), n2 = t3.el.ownerDocument, o2 = r2 ? s2.getElementById("apexcharts-css") : n2.getElementById("apexcharts-css");
        if (!o2) {
          var l2;
          (o2 = document.createElement("style")).id = "apexcharts-css", o2.textContent = '@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  direction: ltr !important;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  display: inline-block;\n  position: relative;\n  width: 16px;\n  height: 16px;\n  font-size: 16px;\n  line-height: 16px;\n  margin-right: 4px;\n  text-align: center;\n  vertical-align: middle;\n  color: inherit;\n}\n\n.apexcharts-tooltip-marker::before {\n  content: "";\n  display: inline-block;\n  width: 100%;\n  text-align: center;\n  color: currentcolor;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  font-size: 26px;\n  font-family: Arial, Helvetica, sans-serif;\n  line-height: 14px;\n  font-weight: 900;\n}\n\n.apexcharts-tooltip-marker[shape="circle"]::before {\n  content: "\\25CF";\n}\n\n.apexcharts-tooltip-marker[shape="square"]::before,\n.apexcharts-tooltip-marker[shape="rect"]::before {\n  content: "\\25A0";\n  transform: translate(-1px, -2px);\n}\n\n.apexcharts-tooltip-marker[shape="line"]::before {\n  content: "\\2500";\n}\n\n.apexcharts-tooltip-marker[shape="diamond"]::before {\n  content: "\\25C6";\n  font-size: 28px;\n}\n\n.apexcharts-tooltip-marker[shape="triangle"]::before {\n  content: "\\25B2";\n  font-size: 22px;\n}\n\n.apexcharts-tooltip-marker[shape="cross"]::before {\n  content: "\\2715";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="plus"]::before {\n  content: "\\2715";\n  transform: rotate(45deg) translate(-1px, -1px);\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="star"]::before {\n  content: "\\2605";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="sparkle"]::before {\n  content: "\\2726";\n  font-size: 20px;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_shape {\n  stroke-width: 1;\n  stroke-dasharray: 10 10;\n  stroke: black;\n  stroke-opacity: 0.1;\n  pointer-events: none;\n  fill: none;\n}\n\n.svg_select_handle {\n  stroke-width: 3;\n  stroke: black;\n  fill: none;\n}\n\n.svg_select_handle_r {\n  cursor: e-resize;\n}\n\n.svg_select_handle_l {\n  cursor: w-resize;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect,\n.no-pointer-events {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.apexcharts-radar-series .apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}';
          var h2 = ((l2 = t3.opts.chart) === null || l2 === undefined ? undefined : l2.nonce) || t3.w.config.chart.nonce;
          h2 && o2.setAttribute("nonce", h2), r2 ? s2.prepend(o2) : n2.head.appendChild(o2);
        }
        var c2 = t3.create(t3.w.config.series, {});
        if (!c2)
          return e2(t3);
        t3.mount(c2).then(function() {
          typeof t3.w.config.chart.events.mounted == "function" && t3.w.config.chart.events.mounted(t3, t3.w), t3.events.fireEvent("mounted", [t3, t3.w]), e2(c2);
        }).catch(function(t4) {
          i2(t4);
        });
      } else
        i2(new Error("Element not found"));
    });
  } }, { key: "create", value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    new hs(this).initModules();
    var s2 = this.w.globals;
    if (s2.noData = false, s2.animationEnded = false, !v.elementExists(this.el))
      return s2.animationEnded = true, this.destroy(), null;
    (this.responsive.checkResponsiveConfig(e2), a2.config.xaxis.convertedCatToNumeric) && new Ni(a2.config).convertCatToNumericXaxis(a2.config, this.ctx);
    if (this.core.setupElements(), a2.config.chart.type === "treemap" && (a2.config.grid.show = false, a2.config.yaxis[0].show = false), s2.svgWidth === 0)
      return s2.animationEnded = true, null;
    var r2 = t3;
    t3.forEach(function(t4, e3) {
      t4.hidden && (r2 = i2.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: e3 }));
    });
    var n2 = Pi.checkComboSeries(r2, a2.config.chart.type);
    s2.comboCharts = n2.comboCharts, s2.comboBarCount = n2.comboBarCount;
    var o2 = r2.every(function(t4) {
      return t4.data && t4.data.length === 0;
    });
    (r2.length === 0 || o2 && s2.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(r2), this.theme.init(), new Vi(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), s2.noData && s2.collapsedSeries.length !== s2.series.length && !a2.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), s2.axisCharts && (this.core.coreCalculations(), a2.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = a2.globals.minX, this.ctx.toolbar.maxX = a2.globals.maxX), this.formatters.heatmapLabelFormatters(), new Pi(this).getLargestMarkerSize(), this.dimensions.plotCoords();
    var l2 = this.core.xySettings();
    this.grid.createGridMask();
    var h2 = this.core.plotChartType(r2, l2), c2 = new qi(this);
    return c2.bringForward(), a2.config.dataLabels.background.enabled && c2.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: h2, xyRatios: l2, dimensions: { plot: { left: a2.globals.translateX, top: a2.globals.translateY, width: a2.globals.gridWidth, height: a2.globals.gridHeight } } };
  } }, { key: "mount", value: function() {
    var t3 = this, e2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null, i2 = this, a2 = i2.w;
    return new Promise(function(s2, r2) {
      if (i2.el === null)
        return r2(new Error("Not enough data to display or target element not found"));
      (e2 === null || a2.globals.allSeriesCollapsed) && i2.series.handleNoData(), i2.grid = new Ki(i2);
      var n2, o2, l2 = i2.grid.drawGrid();
      (i2.annotations = new Fi(i2), i2.annotations.drawImageAnnos(), i2.annotations.drawTextAnnos(), a2.config.grid.position === "back") && (l2 && a2.globals.dom.elGraphical.add(l2.el), l2 != null && (n2 = l2.elGridBorders) !== null && n2 !== undefined && n2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
      if (Array.isArray(e2.elGraph))
        for (var h2 = 0;h2 < e2.elGraph.length; h2++)
          a2.globals.dom.elGraphical.add(e2.elGraph[h2]);
      else
        a2.globals.dom.elGraphical.add(e2.elGraph);
      a2.config.grid.position === "front" && (l2 && a2.globals.dom.elGraphical.add(l2.el), l2 != null && (o2 = l2.elGridBorders) !== null && o2 !== undefined && o2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
      a2.config.xaxis.crosshairs.position === "front" && i2.crosshairs.drawXCrosshairs(), a2.config.yaxis[0].crosshairs.position === "front" && i2.crosshairs.drawYCrosshairs(), a2.config.chart.type !== "treemap" && i2.axes.drawAxis(a2.config.chart.type, l2);
      var c2 = new Qi(t3.ctx, l2), d2 = new ia(t3.ctx, l2);
      if (l2 !== null && (c2.xAxisLabelCorrections(l2.xAxisTickWidth), d2.setYAxisTextAlignments(), a2.config.yaxis.map(function(t4, e3) {
        a2.globals.ignoreYAxisIndexes.indexOf(e3) === -1 && d2.yAxisTitleRotate(e3, t4.opposite);
      })), i2.annotations.drawAxesAnnotations(), !a2.globals.noData) {
        if (a2.config.tooltip.enabled && !a2.globals.noData && i2.w.globals.tooltip.drawTooltip(e2.xyRatios), a2.globals.axisCharts && (a2.globals.isXNumeric || a2.config.xaxis.convertedCatToNumeric || a2.globals.isRangeBar))
          (a2.config.chart.zoom.enabled || a2.config.chart.selection && a2.config.chart.selection.enabled || a2.config.chart.pan && a2.config.chart.pan.enabled) && i2.zoomPanSelection.init({ xyRatios: e2.xyRatios });
        else {
          var u2 = a2.config.chart.toolbar.tools;
          ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(t4) {
            u2[t4] = false;
          });
        }
        a2.config.chart.toolbar.show && !a2.globals.allSeriesCollapsed && i2.toolbar.createToolbar();
      }
      a2.globals.memory.methodsToExec.length > 0 && a2.globals.memory.methodsToExec.forEach(function(t4) {
        t4.method(t4.params, false, t4.context);
      }), a2.globals.axisCharts || a2.globals.noData || i2.core.resizeNonAxisCharts(), s2(i2);
    });
  } }, { key: "destroy", value: function() {
    window.removeEventListener("resize", this.windowResizeHandler), function(t4, e2) {
      var i2 = ds.get(e2);
      i2 && (i2.disconnect(), ds.delete(e2));
    }(this.el.parentNode, this.parentResizeHandler);
    var t3 = this.w.config.chart.id;
    t3 && Apex._chartInstances.forEach(function(e2, i2) {
      e2.id === v.escapeString(t3) && Apex._chartInstances.splice(i2, 1);
    }), new cs(this.ctx).clear({ isUpdating: false });
  } }, { key: "updateOptions", value: function(t3) {
    var e2 = this, i2 = arguments.length > 1 && arguments[1] !== undefined && arguments[1], a2 = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2], s2 = !(arguments.length > 3 && arguments[3] !== undefined) || arguments[3], r2 = !(arguments.length > 4 && arguments[4] !== undefined) || arguments[4], n2 = this.w;
    return n2.globals.selection = undefined, t3.series && (this.series.resetSeries(false, true, false), t3.series.length && t3.series[0].data && (t3.series = t3.series.map(function(t4, i3) {
      return e2.updateHelpers._extendSeries(t4, i3);
    })), this.updateHelpers.revertDefaultAxisMinMax()), t3.xaxis && (t3 = this.updateHelpers.forceXAxisUpdate(t3)), t3.yaxis && (t3 = this.updateHelpers.forceYAxisUpdate(t3)), n2.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t3.theme && (t3 = this.theme.updateThemeOptions(t3)), this.updateHelpers._updateOptions(t3, i2, a2, s2, r2);
  } }, { key: "updateSeries", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [], e2 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1], i2 = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2];
    return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t3, e2, i2);
  } }, { key: "appendSeries", value: function(t3) {
    var e2 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1], i2 = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2], a2 = this.w.config.series.slice();
    return a2.push(t3), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a2, e2, i2);
  } }, { key: "appendData", value: function(t3) {
    var e2 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1], i2 = this;
    i2.w.globals.dataChanged = true, i2.series.getPreviousPaths();
    for (var a2 = i2.w.config.series.slice(), s2 = 0;s2 < a2.length; s2++)
      if (t3[s2] !== null && t3[s2] !== undefined)
        for (var r2 = 0;r2 < t3[s2].data.length; r2++)
          a2[s2].data.push(t3[s2].data[r2]);
    return i2.w.config.series = a2, e2 && (i2.w.globals.initialSeries = v.clone(i2.w.config.series)), this.update();
  } }, { key: "update", value: function(t3) {
    var e2 = this;
    return new Promise(function(i2, a2) {
      new cs(e2.ctx).clear({ isUpdating: true });
      var s2 = e2.create(e2.w.config.series, t3);
      if (!s2)
        return i2(e2);
      e2.mount(s2).then(function() {
        typeof e2.w.config.chart.events.updated == "function" && e2.w.config.chart.events.updated(e2, e2.w), e2.events.fireEvent("updated", [e2, e2.w]), e2.w.globals.isDirty = true, i2(e2);
      }).catch(function(t4) {
        a2(t4);
      });
    });
  } }, { key: "getSyncedCharts", value: function() {
    var t3 = this.getGroupedCharts(), e2 = [this];
    return t3.length && (e2 = [], t3.forEach(function(t4) {
      e2.push(t4);
    })), e2;
  } }, { key: "getGroupedCharts", value: function() {
    var t3 = this;
    return Apex._chartInstances.filter(function(t4) {
      if (t4.group)
        return true;
    }).map(function(e2) {
      return t3.w.config.chart.group === e2.group ? e2.chart : t3;
    });
  } }, { key: "toggleSeries", value: function(t3) {
    return this.series.toggleSeries(t3);
  } }, { key: "highlightSeriesOnLegendHover", value: function(t3, e2) {
    return this.series.toggleSeriesOnHover(t3, e2);
  } }, { key: "showSeries", value: function(t3) {
    this.series.showSeries(t3);
  } }, { key: "hideSeries", value: function(t3) {
    this.series.hideSeries(t3);
  } }, { key: "highlightSeries", value: function(t3) {
    this.series.highlightSeries(t3);
  } }, { key: "isSeriesHidden", value: function(t3) {
    this.series.isSeriesHidden(t3);
  } }, { key: "resetSeries", value: function() {
    var t3 = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0], e2 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1];
    this.series.resetSeries(t3, e2);
  } }, { key: "addEventListener", value: function(t3, e2) {
    this.events.addEventListener(t3, e2);
  } }, { key: "removeEventListener", value: function(t3, e2) {
    this.events.removeEventListener(t3, e2);
  } }, { key: "addXaxisAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1], i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined, a2 = this;
    i2 && (a2 = i2), a2.annotations.addXaxisAnnotationExternal(t3, e2, a2);
  } }, { key: "addYaxisAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1], i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined, a2 = this;
    i2 && (a2 = i2), a2.annotations.addYaxisAnnotationExternal(t3, e2, a2);
  } }, { key: "addPointAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1], i2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined, a2 = this;
    i2 && (a2 = i2), a2.annotations.addPointAnnotationExternal(t3, e2, a2);
  } }, { key: "clearAnnotations", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined, e2 = this;
    t3 && (e2 = t3), e2.annotations.clearAnnotations(e2);
  } }, { key: "removeAnnotation", value: function(t3) {
    var e2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined, i2 = this;
    e2 && (i2 = e2), i2.annotations.removeAnnotation(i2, t3);
  } }, { key: "getChartArea", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
  } }, { key: "getSeriesTotalXRange", value: function(t3, e2) {
    return this.coreUtils.getSeriesTotalsXRange(t3, e2);
  } }, { key: "getHighestValueInSeries", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return new ea(this.ctx).getMinYMaxY(t3).highestY;
  } }, { key: "getLowestValueInSeries", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return new ea(this.ctx).getMinYMaxY(t3).lowestY;
  } }, { key: "getSeriesTotal", value: function() {
    return this.w.globals.seriesTotals;
  } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
    return this.updateHelpers.toggleDataPointSelection(t3, e2);
  } }, { key: "zoomX", value: function(t3, e2) {
    this.ctx.toolbar.zoomUpdateOptions(t3, e2);
  } }, { key: "setLocale", value: function(t3) {
    this.localization.setCurrentLocaleValues(t3);
  } }, { key: "dataURI", value: function(t3) {
    return new Ji(this.ctx).dataURI(t3);
  } }, { key: "getSvgString", value: function(t3) {
    return new Ji(this.ctx).getSvgString(t3);
  } }, { key: "exportToCSV", value: function() {
    var t3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new Ji(this.ctx).exportToCSV(t3);
  } }, { key: "paper", value: function() {
    return this.w.globals.dom.Paper;
  } }, { key: "_parentResizeCallback", value: function() {
    this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
  } }, { key: "_windowResize", value: function() {
    var t3 = this;
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
      t3.w.globals.resized = true, t3.w.globals.dataChanged = false, t3.ctx.update();
    }, 150);
  } }, { key: "_windowResizeHandler", value: function() {
    var t3 = this.w.config.chart.redrawOnWindowResize;
    typeof t3 == "function" && (t3 = t3()), t3 && this._windowResize();
  } }], [{ key: "getChartByID", value: function(t3) {
    var e2 = v.escapeString(t3);
    if (Apex._chartInstances) {
      var i2 = Apex._chartInstances.filter(function(t4) {
        return t4.id === e2;
      })[0];
      return i2 && i2.chart;
    }
  } }, { key: "initOnLoad", value: function() {
    for (var e2 = document.querySelectorAll("[data-apexcharts]"), i2 = 0;i2 < e2.length; i2++) {
      new t2(e2[i2], JSON.parse(e2[i2].getAttribute("data-options"))).render();
    }
  } }, { key: "exec", value: function(t3, e2) {
    var i2 = this.getChartByID(t3);
    if (i2) {
      i2.w.globals.isExecCalled = true;
      var a2 = null;
      if (i2.publicMethods.indexOf(e2) !== -1) {
        for (var s2 = arguments.length, r2 = new Array(s2 > 2 ? s2 - 2 : 0), n2 = 2;n2 < s2; n2++)
          r2[n2 - 2] = arguments[n2];
        a2 = i2[e2].apply(i2, r2);
      }
      return a2;
    }
  } }, { key: "merge", value: function(t3, e2) {
    return v.extend(t3, e2);
  } }]), t2;
}();

// app/javascript/controllers/charts_controller.js
class charts_controller_default extends Controller {
  static targets = ["chart", "time", "temperature", "concentration"];
  connect() {
    console.log(this.generateChartData());
    this.renderChart();
  }
  renderChart() {
    const options = {
      chart: {
        type: "line",
        height: 400,
        width: "100%",
        zoom: {
          enabled: true
        },
        scrollablePlotArea: {
          enabled: true,
          scrollHorizontal: true
        }
      },
      series: [
        {
          name: "Temperatura",
          data: JSON.parse(this.concentrationTarget.value)
        }
      ],
      xaxis: {
        categories: this.generateChartData(),
        type: "datetime",
        tickAmount: 24,
        labels: {
          format: "HH:mm",
          rotate: -45
        },
        title: {
          text: "Hor\xE1rio"
        }
      },
      yaxis: {
        title: {
          text: "Quantidade"
        }
      }
    };
    new us(this.chartTarget, options).render();
  }
  generateChartData() {
    let data = [];
    data = JSON.parse(this.timeTarget.value).map((item) => {
      let hour = parseInt(item.split(":")[0]);
      let minute = parseInt(item.split(":")[1]);
      let second = parseInt(item.split(":")[2]);
      let newHour = new Date;
      let time = newHour.setHours(hour, minute, second, 0);
      return time;
    });
    return data;
  }
}

// node_modules/@stimulus-components/auto-submit/dist/stimulus-auto-submit.mjs
var debounce2 = function(callback, delay) {
  let timeout;
  return (...args) => {
    clearTimeout(timeout), timeout = setTimeout(() => {
      callback.apply(this, args);
    }, delay);
  };
};
var _AutoSubmit = class _AutoSubmit2 extends Controller {
  initialize() {
    this.submit = this.submit.bind(this);
  }
  connect() {
    this.delayValue > 0 && (this.submit = debounce2(this.submit, this.delayValue));
  }
  submit() {
    this.element.requestSubmit();
  }
};
_AutoSubmit.values = {
  delay: {
    type: Number,
    default: 150
  }
};
var AutoSubmit = _AutoSubmit;

// app/javascript/controllers/index.js
application.register("chart", charts_controller_default);
application.register("auto-submit", AutoSubmit);

// node_modules/@popperjs/core/lib/index.js
var exports_lib = {};
__export(exports_lib, {
  write: () => {
    {
      return write;
    }
  },
  viewport: () => {
    {
      return viewport;
    }
  },
  variationPlacements: () => {
    {
      return variationPlacements;
    }
  },
  top: () => {
    {
      return top;
    }
  },
  start: () => {
    {
      return start2;
    }
  },
  right: () => {
    {
      return right;
    }
  },
  reference: () => {
    {
      return reference;
    }
  },
  read: () => {
    {
      return read;
    }
  },
  preventOverflow: () => {
    {
      return preventOverflow_default;
    }
  },
  popperOffsets: () => {
    {
      return popperOffsets_default;
    }
  },
  popperGenerator: () => {
    {
      return popperGenerator;
    }
  },
  popper: () => {
    {
      return popper;
    }
  },
  placements: () => {
    {
      return placements;
    }
  },
  offset: () => {
    {
      return offset_default;
    }
  },
  modifierPhases: () => {
    {
      return modifierPhases;
    }
  },
  main: () => {
    {
      return main;
    }
  },
  left: () => {
    {
      return left;
    }
  },
  hide: () => {
    {
      return hide_default;
    }
  },
  flip: () => {
    {
      return flip_default;
    }
  },
  eventListeners: () => {
    {
      return eventListeners_default;
    }
  },
  end: () => {
    {
      return end;
    }
  },
  detectOverflow: () => {
    {
      return detectOverflow;
    }
  },
  createPopperLite: () => {
    {
      return createPopper3;
    }
  },
  createPopperBase: () => {
    {
      return createPopper;
    }
  },
  createPopper: () => {
    {
      return createPopper5;
    }
  },
  computeStyles: () => {
    {
      return computeStyles_default;
    }
  },
  clippingParents: () => {
    {
      return clippingParents;
    }
  },
  bottom: () => {
    {
      return bottom;
    }
  },
  beforeWrite: () => {
    {
      return beforeWrite;
    }
  },
  beforeRead: () => {
    {
      return beforeRead;
    }
  },
  beforeMain: () => {
    {
      return beforeMain;
    }
  },
  basePlacements: () => {
    {
      return basePlacements;
    }
  },
  auto: () => {
    {
      return auto;
    }
  },
  arrow: () => {
    {
      return arrow_default;
    }
  },
  applyStyles: () => {
    {
      return applyStyles_default;
    }
  },
  afterWrite: () => {
    {
      return afterWrite;
    }
  },
  afterRead: () => {
    {
      return afterRead;
    }
  },
  afterMain: () => {
    {
      return afterMain;
    }
  }
});

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start2 = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start2, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start2, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
var isElement = function(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
};
var isHTMLElement = function(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
};
var isShadowRoot = function(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
};

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
var applyStyles = function(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
};
var effect = function(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
};
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === undefined) {
    includeScale = false;
  }
  if (isFixedStrategy === undefined) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
var getTrueOffsetParent = function(element) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
};
var getContainingBlock = function(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
};
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var arrow = function(_ref) {
  var _state$modifiersData$;
  var { state, name, options } = _ref;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
};
var effect2 = function(_ref2) {
  var { state, options } = _ref2;
  var _options$element = options.element, arrowElement = _options$element === undefined ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
};
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var roundOffsetsByDPR = function(_ref, win) {
  var { x: x2, y: y2 } = _ref;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
};
function mapToStyles(_ref2) {
  var _Object$assign2;
  var { popper: popper2, popperRect, placement, variation, offsets, position, gpuAcceleration, adaptive, roundOffsets, isFixed } = _ref2;
  var _offsets$x = offsets.x, x2 = _offsets$x === undefined ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === undefined ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
var computeStyles = function(_ref5) {
  var { state, options } = _ref5;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === undefined ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === undefined ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === undefined ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
};
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var effect3 = function(_ref) {
  var { state, instance, options } = _ref;
  var _options$scroll = options.scroll, scroll = _options$scroll === undefined ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === undefined ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
};
var passive = {
  passive: true
};
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? undefined : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === undefined) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? undefined : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
var getInnerBoundingClientRect = function(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
};
var getClientRectFromMixedType = function(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
};
var getClippingParents = function(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
};
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var { reference: reference2, element, placement } = _ref;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start2:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === undefined) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === undefined ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === undefined ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === undefined ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === undefined ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === undefined ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === undefined ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === undefined ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === undefined) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === undefined ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
var getExpandedFallbackPlacements = function(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
};
var flip = function(_ref) {
  var { state, options, name } = _ref;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === undefined ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === undefined ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === undefined ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map;
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0;i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start2;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i3) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i3).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i2 = numberOfChecks;_i2 > 0; _i2--) {
      var _ret = _loop(_i2);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
};
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
var getSideOffsets = function(overflow, rect, preventedOffsets) {
  if (preventedOffsets === undefined) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
};
var isAnySideFullyClipped = function(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
};
var hide = function(_ref) {
  var { state, name } = _ref;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
};
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
    placement
  })) : offset, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
var offset = function(_ref2) {
  var { state, options, name } = _ref2;
  var _options$offset = options.offset, offset2 = _options$offset === undefined ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
};
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
var popperOffsets = function(_ref) {
  var { state, name } = _ref;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
};
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
var preventOverflow = function(_ref) {
  var { state, options, name } = _ref;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === undefined ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === undefined ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === undefined ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === undefined ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? undefined : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? undefined : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
};
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
var isElementScaled = function(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
};
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === undefined) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
var order = function(modifiers) {
  var map = new Map;
  var visited = new Set;
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
};
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce3(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = undefined;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var areValidElements = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
};
function popperGenerator(generatorOptions) {
  if (generatorOptions === undefined) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === undefined ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === undefined ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference2, popper2, options) {
    if (options === undefined) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0;index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === undefined ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce3(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var { name, options: _ref$options } = _ref, options2 = _ref$options === undefined ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper3 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper5 = popperGenerator({
  defaultModifiers: defaultModifiers2
});
// node_modules/bootstrap/dist/js/bootstrap.esm.js
var makeEventUid = function(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
};
var getElementEvents = function(element) {
  const uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
};
var bootstrapHandler = function(element, fn2) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });
    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn2);
    }
    return fn2.apply(element, [event]);
  };
};
var bootstrapDelegationHandler = function(element, selector, fn2) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);
    for (let {
      target
    } = event;target && target !== this; target = target.parentNode) {
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue;
        }
        hydrateObj(event, {
          delegateTarget: target
        });
        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn2);
        }
        return fn2.apply(target, [event]);
      }
    }
  };
};
var findHandler = function(events, callable, delegationSelector = null) {
  return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
};
var normalizeParameters = function(originalTypeEvent, handler, delegationFunction) {
  const isDelegated = typeof handler === "string";
  const callable = isDelegated ? delegationFunction : handler || delegationFunction;
  let typeEvent = getTypeEvent(originalTypeEvent);
  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }
  return [isDelegated, callable, typeEvent];
};
var addHandler = function(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== "string" || !element) {
    return;
  }
  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
  if (originalTypeEvent in customEvents) {
    const wrapFunction = (fn3) => {
      return function(event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn3.call(this, event);
        }
      };
    };
    callable = wrapFunction(callable);
  }
  const events = getElementEvents(element);
  const handlers = events[typeEvent] || (events[typeEvent] = {});
  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }
  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
  const fn2 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn2.delegationSelector = isDelegated ? handler : null;
  fn2.callable = callable;
  fn2.oneOff = oneOff;
  fn2.uidEvent = uid;
  handlers[uid] = fn2;
  element.addEventListener(typeEvent, fn2, isDelegated);
};
var removeHandler = function(element, events, typeEvent, handler, delegationSelector) {
  const fn2 = findHandler(events[typeEvent], handler, delegationSelector);
  if (!fn2) {
    return;
  }
  element.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
  delete events[typeEvent][fn2.uidEvent];
};
var removeNamespacedHandlers = function(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};
  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
    }
  }
};
var getTypeEvent = function(event) {
  event = event.replace(stripNameRegex, "");
  return customEvents[event] || event;
};
var hydrateObj = function(obj, meta = {}) {
  for (const [key, value] of Object.entries(meta)) {
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,
        get() {
          return value;
        }
      });
    }
  }
  return obj;
};
var normalizeData = function(value) {
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  if (value === Number(value).toString()) {
    return Number(value);
  }
  if (value === "" || value === "null") {
    return null;
  }
  if (typeof value !== "string") {
    return value;
  }
  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
};
var normalizeDataKey = function(key) {
  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
};
var sanitizeHtml = function(unsafeHtml, allowList, sanitizeFunction) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFunction && typeof sanitizeFunction === "function") {
    return sanitizeFunction(unsafeHtml);
  }
  const domParser = new window.DOMParser;
  const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
  const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
  for (const element of elements) {
    const elementName = element.nodeName.toLowerCase();
    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }
    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
    for (const attribute of attributeList) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    }
  }
  return createdDocument.body.innerHTML;
};
/*!
  * Bootstrap v5.3.3 (https://getbootstrap.com/)
  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
var elementMap = new Map;
var Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, new Map);
    }
    const instanceMap = elementMap.get(element);
    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }
    instanceMap.set(key, instance);
  },
  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }
    return null;
  },
  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }
    const instanceMap = elementMap.get(element);
    instanceMap.delete(key);
    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }
};
var MAX_UID = 1e6;
var MILLISECONDS_MULTIPLIER = 1000;
var TRANSITION_END = "transitionend";
var parseSelector = (selector) => {
  if (selector && window.CSS && window.CSS.escape) {
    selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
  }
  return selector;
};
var toType = (object) => {
  if (object === null || object === undefined) {
    return `${object}`;
  }
  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
var getUID = (prefix) => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
var getTransitionDurationFromElement = (element) => {
  if (!element) {
    return 0;
  }
  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
var triggerTransitionEnd = (element) => {
  element.dispatchEvent(new Event(TRANSITION_END));
};
var isElement2 = (object) => {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (typeof object.jquery !== "undefined") {
    object = object[0];
  }
  return typeof object.nodeType !== "undefined";
};
var getElement = (object) => {
  if (isElement2(object)) {
    return object.jquery ? object[0] : object;
  }
  if (typeof object === "string" && object.length > 0) {
    return document.querySelector(parseSelector(object));
  }
  return null;
};
var isVisible = (element) => {
  if (!isElement2(element) || element.getClientRects().length === 0) {
    return false;
  }
  const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
  const closedDetails = element.closest("details:not([open])");
  if (!closedDetails) {
    return elementIsVisible;
  }
  if (closedDetails !== element) {
    const summary = element.closest("summary");
    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }
    if (summary === null) {
      return false;
    }
  }
  return elementIsVisible;
};
var isDisabled = (element) => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element.classList.contains("disabled")) {
    return true;
  }
  if (typeof element.disabled !== "undefined") {
    return element.disabled;
  }
  return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
};
var findShadowRoot = (element) => {
  if (!document.documentElement.attachShadow) {
    return null;
  }
  if (typeof element.getRootNode === "function") {
    const root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }
  if (element instanceof ShadowRoot) {
    return element;
  }
  if (!element.parentNode) {
    return null;
  }
  return findShadowRoot(element.parentNode);
};
var noop = () => {
};
var reflow = (element) => {
  element.offsetHeight;
};
var getjQuery = () => {
  if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
    return window.jQuery;
  }
  return null;
};
var DOMContentLoadedCallbacks = [];
var onDOMContentLoaded = (callback) => {
  if (document.readyState === "loading") {
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener("DOMContentLoaded", () => {
        for (const callback2 of DOMContentLoadedCallbacks) {
          callback2();
        }
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
var isRTL = () => document.documentElement.dir === "rtl";
var defineJQueryPlugin = (plugin) => {
  onDOMContentLoaded(() => {
    const $2 = getjQuery();
    if ($2) {
      const name = plugin.NAME;
      const JQUERY_NO_CONFLICT = $2.fn[name];
      $2.fn[name] = plugin.jQueryInterface;
      $2.fn[name].Constructor = plugin;
      $2.fn[name].noConflict = () => {
        $2.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};
var execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
  return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
};
var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;
  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
  const listLength = list.length;
  let index = list.indexOf(activeElement);
  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
  }
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list[Math.max(0, Math.min(index, listLength - 1))];
};
var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
var stripNameRegex = /\..*/;
var stripUidRegex = /::\d+$/;
var eventRegistry = {};
var uidEvent = 1;
var customEvents = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
};
var nativeEvents = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
var EventHandler = {
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },
  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },
  off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getElementEvents(element);
    const storeElementEvent = events[typeEvent] || {};
    const isNamespace = originalTypeEvent.startsWith(".");
    if (typeof callable !== "undefined") {
      if (!Object.keys(storeElementEvent).length) {
        return;
      }
      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
      return;
    }
    if (isNamespace) {
      for (const elementEvent of Object.keys(events)) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      }
    }
    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
      const handlerKey = keyHandlers.replace(stripUidRegex, "");
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },
  trigger(element, event, args) {
    if (typeof event !== "string" || !element) {
      return null;
    }
    const $2 = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    let jQueryEvent = null;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    if (inNamespace && $2) {
      jQueryEvent = $2.Event(event, args);
      $2(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    const evt = hydrateObj(new Event(event, {
      bubbles,
      cancelable: true
    }), args);
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
var Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },
  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },
  getDataAttributes(element) {
    if (!element) {
      return {};
    }
    const attributes = {};
    const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
    for (const key of bsKeys) {
      let pureKey = key.replace(/^bs/, "");
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    }
    return attributes;
  },
  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  }
};

class Config2 {
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(config2) {
    config2 = this._mergeConfigObj(config2);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  _configAfterMerge(config2) {
    return config2;
  }
  _mergeConfigObj(config2, element) {
    const jsonConfig = isElement2(element) ? Manipulator.getDataAttribute(element, "config") : {};
    return {
      ...this.constructor.Default,
      ...typeof jsonConfig === "object" ? jsonConfig : {},
      ...isElement2(element) ? Manipulator.getDataAttributes(element) : {},
      ...typeof config2 === "object" ? config2 : {}
    };
  }
  _typeCheckConfig(config2, configTypes = this.constructor.DefaultType) {
    for (const [property, expectedTypes] of Object.entries(configTypes)) {
      const value = config2[property];
      const valueType = isElement2(value) ? "element" : toType(value);
      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    }
  }
}
var VERSION = "5.3.3";

class BaseComponent extends Config2 {
  constructor(element, config2) {
    super();
    element = getElement(element);
    if (!element) {
      return;
    }
    this._element = element;
    this._config = this._getConfig(config2);
    Data.set(this._element, this.constructor.DATA_KEY, this);
  }
  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);
    for (const propertyName of Object.getOwnPropertyNames(this)) {
      this[propertyName] = null;
    }
  }
  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }
  _getConfig(config2) {
    config2 = this._mergeConfigObj(config2, this._element);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }
  static getOrCreateInstance(element, config2 = {}) {
    return this.getInstance(element) || new this(element, typeof config2 === "object" ? config2 : null);
  }
  static get VERSION() {
    return VERSION;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(name) {
    return `${name}${this.EVENT_KEY}`;
  }
}
var getSelector = (element) => {
  let selector = element.getAttribute("data-bs-target");
  if (!selector || selector === "#") {
    let hrefAttribute = element.getAttribute("href");
    if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
      return null;
    }
    if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
      hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
    }
    selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
  }
  return selector ? selector.split(",").map((sel) => parseSelector(sel)).join(",") : null;
};
var SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },
  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },
  children(element, selector) {
    return [].concat(...element.children).filter((child) => child.matches(selector));
  },
  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode.closest(selector);
    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }
    return parents;
  },
  prev(element, selector) {
    let previous = element.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  next(element, selector) {
    let next = element.nextElementSibling;
    while (next) {
      if (next.matches(selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren(element) {
    const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
    return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
  },
  getSelectorFromElement(element) {
    const selector = getSelector(element);
    if (selector) {
      return SelectorEngine.findOne(selector) ? selector : null;
    }
    return null;
  },
  getElementFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.findOne(selector) : null;
  },
  getMultipleElementsFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.find(selector) : [];
  }
};
var enableDismissTrigger = (component, method = "hide") => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
    const instance = component.getOrCreateInstance(target);
    instance[method]();
  });
};
var NAME$f = "alert";
var DATA_KEY$a = "bs.alert";
var EVENT_KEY$b = `.${DATA_KEY$a}`;
var EVENT_CLOSE = `close${EVENT_KEY$b}`;
var EVENT_CLOSED = `closed${EVENT_KEY$b}`;
var CLASS_NAME_FADE$5 = "fade";
var CLASS_NAME_SHOW$8 = "show";

class Alert extends BaseComponent {
  static get NAME() {
    return NAME$f;
  }
  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
    if (closeEvent.defaultPrevented) {
      return;
    }
    this._element.classList.remove(CLASS_NAME_SHOW$8);
    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  }
  _destroyElement() {
    this._element.remove();
    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Alert.getOrCreateInstance(this);
      if (typeof config2 !== "string") {
        return;
      }
      if (data[config2] === undefined || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2](this);
    });
  }
}
enableDismissTrigger(Alert, "close");
defineJQueryPlugin(Alert);
var NAME$e = "button";
var DATA_KEY$9 = "bs.button";
var EVENT_KEY$a = `.${DATA_KEY$9}`;
var DATA_API_KEY$6 = ".data-api";
var CLASS_NAME_ACTIVE$3 = "active";
var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
var EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;

class Button extends BaseComponent {
  static get NAME() {
    return NAME$e;
  }
  toggle() {
    this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Button.getOrCreateInstance(this);
      if (config2 === "toggle") {
        data[config2]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data = Button.getOrCreateInstance(button);
  data.toggle();
});
defineJQueryPlugin(Button);
var NAME$d = "swipe";
var EVENT_KEY$9 = ".bs.swipe";
var EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
var EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
var EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
var POINTER_TYPE_TOUCH = "touch";
var POINTER_TYPE_PEN = "pen";
var CLASS_NAME_POINTER_EVENT = "pointer-event";
var SWIPE_THRESHOLD = 40;
var Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
var DefaultType$c = {
  endCallback: "(function|null)",
  leftCallback: "(function|null)",
  rightCallback: "(function|null)"
};

class Swipe extends Config2 {
  constructor(element, config2) {
    super();
    this._element = element;
    if (!element || !Swipe.isSupported()) {
      return;
    }
    this._config = this._getConfig(config2);
    this._deltaX = 0;
    this._supportPointerEvents = Boolean(window.PointerEvent);
    this._initEvents();
  }
  static get Default() {
    return Default$c;
  }
  static get DefaultType() {
    return DefaultType$c;
  }
  static get NAME() {
    return NAME$d;
  }
  dispose() {
    EventHandler.off(this._element, EVENT_KEY$9);
  }
  _start(event) {
    if (!this._supportPointerEvents) {
      this._deltaX = event.touches[0].clientX;
      return;
    }
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX;
    }
  }
  _end(event) {
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX - this._deltaX;
    }
    this._handleSwipe();
    execute(this._config.endCallback);
  }
  _move(event) {
    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const absDeltaX = Math.abs(this._deltaX);
    if (absDeltaX <= SWIPE_THRESHOLD) {
      return;
    }
    const direction = absDeltaX / this._deltaX;
    this._deltaX = 0;
    if (!direction) {
      return;
    }
    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    if (this._supportPointerEvents) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
    }
  }
  _eventIsPointerPenTouch(event) {
    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
  }
  static isSupported() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
}
var NAME$c = "carousel";
var DATA_KEY$8 = "bs.carousel";
var EVENT_KEY$8 = `.${DATA_KEY$8}`;
var DATA_API_KEY$5 = ".data-api";
var ARROW_LEFT_KEY$1 = "ArrowLeft";
var ARROW_RIGHT_KEY$1 = "ArrowRight";
var TOUCHEVENT_COMPAT_WAIT = 500;
var ORDER_NEXT = "next";
var ORDER_PREV = "prev";
var DIRECTION_LEFT = "left";
var DIRECTION_RIGHT = "right";
var EVENT_SLIDE = `slide${EVENT_KEY$8}`;
var EVENT_SLID = `slid${EVENT_KEY$8}`;
var EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
var EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
var EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
var EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
var EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
var EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
var CLASS_NAME_CAROUSEL = "carousel";
var CLASS_NAME_ACTIVE$2 = "active";
var CLASS_NAME_SLIDE = "slide";
var CLASS_NAME_END = "carousel-item-end";
var CLASS_NAME_START = "carousel-item-start";
var CLASS_NAME_NEXT = "carousel-item-next";
var CLASS_NAME_PREV = "carousel-item-prev";
var SELECTOR_ACTIVE = ".active";
var SELECTOR_ITEM = ".carousel-item";
var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
var SELECTOR_ITEM_IMG = ".carousel-item img";
var SELECTOR_INDICATORS = ".carousel-indicators";
var SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
var KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
var Default$b = {
  interval: 5000,
  keyboard: true,
  pause: "hover",
  ride: false,
  touch: true,
  wrap: true
};
var DefaultType$b = {
  interval: "(number|boolean)",
  keyboard: "boolean",
  pause: "(string|boolean)",
  ride: "(boolean|string)",
  touch: "boolean",
  wrap: "boolean"
};

class Carousel extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._interval = null;
    this._activeElement = null;
    this._isSliding = false;
    this.touchTimeout = null;
    this._swipeHelper = null;
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    this._addEventListeners();
    if (this._config.ride === CLASS_NAME_CAROUSEL) {
      this.cycle();
    }
  }
  static get Default() {
    return Default$b;
  }
  static get DefaultType() {
    return DefaultType$b;
  }
  static get NAME() {
    return NAME$c;
  }
  next() {
    this._slide(ORDER_NEXT);
  }
  nextWhenVisible() {
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }
  prev() {
    this._slide(ORDER_PREV);
  }
  pause() {
    if (this._isSliding) {
      triggerTransitionEnd(this._element);
    }
    this._clearInterval();
  }
  cycle() {
    this._clearInterval();
    this._updateInterval();
    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (!this._config.ride) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
      return;
    }
    this.cycle();
  }
  to(index) {
    const items = this._getItems();
    if (index > items.length - 1 || index < 0) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }
    const activeIndex = this._getItemIndex(this._getActive());
    if (activeIndex === index) {
      return;
    }
    const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    this._slide(order2, items[index]);
  }
  dispose() {
    if (this._swipeHelper) {
      this._swipeHelper.dispose();
    }
    super.dispose();
  }
  _configAfterMerge(config2) {
    config2.defaultInterval = config2.interval;
    return config2;
  }
  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
    }
    if (this._config.pause === "hover") {
      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
    }
    if (this._config.touch && Swipe.isSupported()) {
      this._addTouchEventListeners();
    }
  }
  _addTouchEventListeners() {
    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
      EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
    }
    const endCallBack = () => {
      if (this._config.pause !== "hover") {
        return;
      }
      this.pause();
      if (this.touchTimeout) {
        clearTimeout(this.touchTimeout);
      }
      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
    };
    const swipeConfig = {
      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
      endCallback: endCallBack
    };
    this._swipeHelper = new Swipe(this._element, swipeConfig);
  }
  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }
    const direction = KEY_TO_DIRECTION[event.key];
    if (direction) {
      event.preventDefault();
      this._slide(this._directionToOrder(direction));
    }
  }
  _getItemIndex(element) {
    return this._getItems().indexOf(element);
  }
  _setActiveIndicatorElement(index) {
    if (!this._indicatorsElement) {
      return;
    }
    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
    activeIndicator.removeAttribute("aria-current");
    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
    if (newActiveIndicator) {
      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
      newActiveIndicator.setAttribute("aria-current", "true");
    }
  }
  _updateInterval() {
    const element = this._activeElement || this._getActive();
    if (!element) {
      return;
    }
    const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
    this._config.interval = elementInterval || this._config.defaultInterval;
  }
  _slide(order2, element = null) {
    if (this._isSliding) {
      return;
    }
    const activeElement = this._getActive();
    const isNext = order2 === ORDER_NEXT;
    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
    if (nextElement === activeElement) {
      return;
    }
    const nextElementIndex = this._getItemIndex(nextElement);
    const triggerEvent = (eventName) => {
      return EventHandler.trigger(this._element, eventName, {
        relatedTarget: nextElement,
        direction: this._orderToDirection(order2),
        from: this._getItemIndex(activeElement),
        to: nextElementIndex
      });
    };
    const slideEvent = triggerEvent(EVENT_SLIDE);
    if (slideEvent.defaultPrevented) {
      return;
    }
    if (!activeElement || !nextElement) {
      return;
    }
    const isCycling = Boolean(this._interval);
    this.pause();
    this._isSliding = true;
    this._setActiveIndicatorElement(nextElementIndex);
    this._activeElement = nextElement;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
    nextElement.classList.add(orderClassName);
    reflow(nextElement);
    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);
    const completeCallBack = () => {
      nextElement.classList.remove(directionalClassName, orderClassName);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
      this._isSliding = false;
      triggerEvent(EVENT_SLID);
    };
    this._queueCallback(completeCallBack, activeElement, this._isAnimated());
    if (isCycling) {
      this.cycle();
    }
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_SLIDE);
  }
  _getActive() {
    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
  }
  _getItems() {
    return SelectorEngine.find(SELECTOR_ITEM, this._element);
  }
  _clearInterval() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }
  _directionToOrder(direction) {
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }
    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }
  _orderToDirection(order2) {
    if (isRTL()) {
      return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Carousel.getOrCreateInstance(this, config2);
      if (typeof config2 === "number") {
        data.to(config2);
        return;
      }
      if (typeof config2 === "string") {
        if (data[config2] === undefined || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }
  event.preventDefault();
  const carousel = Carousel.getOrCreateInstance(target);
  const slideIndex = this.getAttribute("data-bs-slide-to");
  if (slideIndex) {
    carousel.to(slideIndex);
    carousel._maybeEnableCycle();
    return;
  }
  if (Manipulator.getDataAttribute(this, "slide") === "next") {
    carousel.next();
    carousel._maybeEnableCycle();
    return;
  }
  carousel.prev();
  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
  for (const carousel of carousels) {
    Carousel.getOrCreateInstance(carousel);
  }
});
defineJQueryPlugin(Carousel);
var NAME$b = "collapse";
var DATA_KEY$7 = "bs.collapse";
var EVENT_KEY$7 = `.${DATA_KEY$7}`;
var DATA_API_KEY$4 = ".data-api";
var EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
var EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
var EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
var EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
var EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
var CLASS_NAME_SHOW$7 = "show";
var CLASS_NAME_COLLAPSE = "collapse";
var CLASS_NAME_COLLAPSING = "collapsing";
var CLASS_NAME_COLLAPSED = "collapsed";
var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
var WIDTH = "width";
var HEIGHT = "height";
var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
var Default$a = {
  parent: null,
  toggle: true
};
var DefaultType$a = {
  parent: "(null|element)",
  toggle: "boolean"
};

class Collapse extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._isTransitioning = false;
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    for (const elem of toggleList) {
      const selector = SelectorEngine.getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
      if (selector !== null && filterElement.length) {
        this._triggerArray.push(elem);
      }
    }
    this._initializeChildren();
    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }
    if (this._config.toggle) {
      this.toggle();
    }
  }
  static get Default() {
    return Default$a;
  }
  static get DefaultType() {
    return DefaultType$a;
  }
  static get NAME() {
    return NAME$b;
  }
  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }
  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }
    let activeChildren = [];
    if (this._config.parent) {
      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => Collapse.getOrCreateInstance(element, {
        toggle: false
      }));
    }
    if (activeChildren.length && activeChildren[0]._isTransitioning) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    for (const activeInstance of activeChildren) {
      activeInstance.hide();
    }
    const dimension = this._getDimension();
    this._element.classList.remove(CLASS_NAME_COLLAPSE);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.style[dimension] = 0;
    this._addAriaAndCollapsedClass(this._triggerArray, true);
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      this._element.style[dimension] = "";
      EventHandler.trigger(this._element, EVENT_SHOWN$6);
    };
    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    this._queueCallback(complete, this._element, true);
    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    const dimension = this._getDimension();
    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    for (const trigger of this._triggerArray) {
      const element = SelectorEngine.getElementFromSelector(trigger);
      if (element && !this._isShown(element)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE);
      EventHandler.trigger(this._element, EVENT_HIDDEN$6);
    };
    this._element.style[dimension] = "";
    this._queueCallback(complete, this._element, true);
  }
  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  }
  _configAfterMerge(config2) {
    config2.toggle = Boolean(config2.toggle);
    config2.parent = getElement(config2.parent);
    return config2;
  }
  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }
  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }
    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
    for (const element of children) {
      const selected = SelectorEngine.getElementFromSelector(element);
      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    }
  }
  _getFirstLevelChildren(selector) {
    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
    return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
  }
  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }
    for (const element of triggerArray) {
      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
      element.setAttribute("aria-expanded", isOpen);
    }
  }
  static jQueryInterface(config2) {
    const _config = {};
    if (typeof config2 === "string" && /show|hide/.test(config2)) {
      _config.toggle = false;
    }
    return this.each(function() {
      const data = Collapse.getOrCreateInstance(this, _config);
      if (typeof config2 === "string") {
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
  if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
    event.preventDefault();
  }
  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  }
});
defineJQueryPlugin(Collapse);
var NAME$a = "dropdown";
var DATA_KEY$6 = "bs.dropdown";
var EVENT_KEY$6 = `.${DATA_KEY$6}`;
var DATA_API_KEY$3 = ".data-api";
var ESCAPE_KEY$2 = "Escape";
var TAB_KEY$1 = "Tab";
var ARROW_UP_KEY$1 = "ArrowUp";
var ARROW_DOWN_KEY$1 = "ArrowDown";
var RIGHT_MOUSE_BUTTON = 2;
var EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
var EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
var EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
var EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
var EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
var CLASS_NAME_SHOW$6 = "show";
var CLASS_NAME_DROPUP = "dropup";
var CLASS_NAME_DROPEND = "dropend";
var CLASS_NAME_DROPSTART = "dropstart";
var CLASS_NAME_DROPUP_CENTER = "dropup-center";
var CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
var SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
var SELECTOR_MENU = ".dropdown-menu";
var SELECTOR_NAVBAR = ".navbar";
var SELECTOR_NAVBAR_NAV = ".navbar-nav";
var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
var PLACEMENT_TOPCENTER = "top";
var PLACEMENT_BOTTOMCENTER = "bottom";
var Default$9 = {
  autoClose: true,
  boundary: "clippingParents",
  display: "dynamic",
  offset: [0, 2],
  popperConfig: null,
  reference: "toggle"
};
var DefaultType$9 = {
  autoClose: "(boolean|string)",
  boundary: "(string|element)",
  display: "string",
  offset: "(array|string|function)",
  popperConfig: "(null|object|function)",
  reference: "(string|element|object)"
};

class Dropdown extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._popper = null;
    this._parent = this._element.parentNode;
    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
    this._inNavbar = this._detectNavbar();
  }
  static get Default() {
    return Default$9;
  }
  static get DefaultType() {
    return DefaultType$9;
  }
  static get NAME() {
    return NAME$a;
  }
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (isDisabled(this._element) || this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._createPopper();
    if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop);
      }
    }
    this._element.focus();
    this._element.setAttribute("aria-expanded", true);
    this._menu.classList.add(CLASS_NAME_SHOW$6);
    this._element.classList.add(CLASS_NAME_SHOW$6);
    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
  }
  hide() {
    if (isDisabled(this._element) || !this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    this._completeHide(relatedTarget);
  }
  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }
    super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar();
    if (this._popper) {
      this._popper.update();
    }
  }
  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
    if (hideEvent.defaultPrevented) {
      return;
    }
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop);
      }
    }
    if (this._popper) {
      this._popper.destroy();
    }
    this._menu.classList.remove(CLASS_NAME_SHOW$6);
    this._element.classList.remove(CLASS_NAME_SHOW$6);
    this._element.setAttribute("aria-expanded", "false");
    Manipulator.removeDataAttribute(this._menu, "popper");
    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
  }
  _getConfig(config2) {
    config2 = super._getConfig(config2);
    if (typeof config2.reference === "object" && !isElement2(config2.reference) && typeof config2.reference.getBoundingClientRect !== "function") {
      throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }
    return config2;
  }
  _createPopper() {
    if (typeof exports_lib === "undefined") {
      throw new TypeError("Bootstrap\'s dropdowns require Popper (https://popper.js.org)");
    }
    let referenceElement = this._element;
    if (this._config.reference === "parent") {
      referenceElement = this._parent;
    } else if (isElement2(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === "object") {
      referenceElement = this._config.reference;
    }
    const popperConfig = this._getPopperConfig();
    this._popper = createPopper5(referenceElement, this._menu, popperConfig);
  }
  _isShown() {
    return this._menu.classList.contains(CLASS_NAME_SHOW$6);
  }
  _getPlacement() {
    const parentDropdown = this._parent;
    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
      return PLACEMENT_TOPCENTER;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
      return PLACEMENT_BOTTOMCENTER;
    }
    const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }
    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }
  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }
  _getOffset() {
    const {
      offset: offset3
    } = this._config;
    if (typeof offset3 === "string") {
      return offset3.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset3 === "function") {
      return (popperData) => offset3(popperData, this._element);
    }
    return offset3;
  }
  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }]
    };
    if (this._inNavbar || this._config.display === "static") {
      Manipulator.setDataAttribute(this._menu, "popper", "static");
      defaultBsPopperConfig.modifiers = [{
        name: "applyStyles",
        enabled: false
      }];
    }
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
    if (!items.length) {
      return;
    }
    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Dropdown.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
  static clearMenus(event) {
    if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
      return;
    }
    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
    for (const toggle of openToggles) {
      const context = Dropdown.getInstance(toggle);
      if (!context || context._config.autoClose === false) {
        continue;
      }
      const composedPath = event.composedPath();
      const isMenuTarget = composedPath.includes(context._menu);
      if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
        continue;
      }
      if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
        continue;
      }
      const relatedTarget = {
        relatedTarget: context._element
      };
      if (event.type === "click") {
        relatedTarget.clickEvent = event;
      }
      context._completeHide(relatedTarget);
    }
  }
  static dataApiKeydownHandler(event) {
    const isInput = /input|textarea/i.test(event.target.tagName);
    const isEscapeEvent = event.key === ESCAPE_KEY$2;
    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
    if (!isUpOrDownEvent && !isEscapeEvent) {
      return;
    }
    if (isInput && !isEscapeEvent) {
      return;
    }
    event.preventDefault();
    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
    const instance = Dropdown.getOrCreateInstance(getToggleButton);
    if (isUpOrDownEvent) {
      event.stopPropagation();
      instance.show();
      instance._selectMenuItem(event);
      return;
    }
    if (instance._isShown()) {
      event.stopPropagation();
      instance.hide();
      getToggleButton.focus();
    }
  }
}
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});
defineJQueryPlugin(Dropdown);
var NAME$9 = "backdrop";
var CLASS_NAME_FADE$4 = "fade";
var CLASS_NAME_SHOW$5 = "show";
var EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
var Default$8 = {
  className: "modal-backdrop",
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  rootElement: "body"
};
var DefaultType$8 = {
  className: "string",
  clickCallback: "(function|null)",
  isAnimated: "boolean",
  isVisible: "boolean",
  rootElement: "(element|string)"
};

class Backdrop extends Config2 {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
    this._isAppended = false;
    this._element = null;
  }
  static get Default() {
    return Default$8;
  }
  static get DefaultType() {
    return DefaultType$8;
  }
  static get NAME() {
    return NAME$9;
  }
  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._append();
    const element = this._getElement();
    if (this._config.isAnimated) {
      reflow(element);
    }
    element.classList.add(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      execute(callback);
    });
  }
  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._getElement().classList.remove(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }
  dispose() {
    if (!this._isAppended) {
      return;
    }
    EventHandler.off(this._element, EVENT_MOUSEDOWN);
    this._element.remove();
    this._isAppended = false;
  }
  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement("div");
      backdrop.className = this._config.className;
      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }
      this._element = backdrop;
    }
    return this._element;
  }
  _configAfterMerge(config2) {
    config2.rootElement = getElement(config2.rootElement);
    return config2;
  }
  _append() {
    if (this._isAppended) {
      return;
    }
    const element = this._getElement();
    this._config.rootElement.append(element);
    EventHandler.on(element, EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }
  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }
}
var NAME$8 = "focustrap";
var DATA_KEY$5 = "bs.focustrap";
var EVENT_KEY$5 = `.${DATA_KEY$5}`;
var EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
var TAB_KEY = "Tab";
var TAB_NAV_FORWARD = "forward";
var TAB_NAV_BACKWARD = "backward";
var Default$7 = {
  autofocus: true,
  trapElement: null
};
var DefaultType$7 = {
  autofocus: "boolean",
  trapElement: "element"
};

class FocusTrap extends Config2 {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }
  static get Default() {
    return Default$7;
  }
  static get DefaultType() {
    return DefaultType$7;
  }
  static get NAME() {
    return NAME$8;
  }
  activate() {
    if (this._isActive) {
      return;
    }
    if (this._config.autofocus) {
      this._config.trapElement.focus();
    }
    EventHandler.off(document, EVENT_KEY$5);
    EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
    this._isActive = true;
  }
  deactivate() {
    if (!this._isActive) {
      return;
    }
    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$5);
  }
  _handleFocusin(event) {
    const {
      trapElement
    } = this._config;
    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
      return;
    }
    const elements = SelectorEngine.focusableChildren(trapElement);
    if (elements.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements[elements.length - 1].focus();
    } else {
      elements[0].focus();
    }
  }
  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }
    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }
}
var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
var SELECTOR_STICKY_CONTENT = ".sticky-top";
var PROPERTY_PADDING = "padding-right";
var PROPERTY_MARGIN = "margin-right";

class ScrollBarHelper {
  constructor() {
    this._element = document.body;
  }
  getWidth() {
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  hide() {
    const width = this.getWidth();
    this._disableOverFlow();
    this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow");
    this._resetElementAttributes(this._element, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow");
    this._element.style.overflow = "hidden";
  }
  _setElementAttributes(selector, styleProperty, callback) {
    const scrollbarWidth = this.getWidth();
    const manipulationCallBack = (element) => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }
      this._saveInitialAttribute(element, styleProperty);
      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _saveInitialAttribute(element, styleProperty) {
    const actualValue = element.style.getPropertyValue(styleProperty);
    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
  }
  _resetElementAttributes(selector, styleProperty) {
    const manipulationCallBack = (element) => {
      const value = Manipulator.getDataAttribute(element, styleProperty);
      if (value === null) {
        element.style.removeProperty(styleProperty);
        return;
      }
      Manipulator.removeDataAttribute(element, styleProperty);
      element.style.setProperty(styleProperty, value);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _applyManipulationCallback(selector, callBack) {
    if (isElement2(selector)) {
      callBack(selector);
      return;
    }
    for (const sel of SelectorEngine.find(selector, this._element)) {
      callBack(sel);
    }
  }
}
var NAME$7 = "modal";
var DATA_KEY$4 = "bs.modal";
var EVENT_KEY$4 = `.${DATA_KEY$4}`;
var DATA_API_KEY$2 = ".data-api";
var ESCAPE_KEY$1 = "Escape";
var EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
var EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
var EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
var EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
var EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
var EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
var EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
var EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
var CLASS_NAME_OPEN = "modal-open";
var CLASS_NAME_FADE$3 = "fade";
var CLASS_NAME_SHOW$4 = "show";
var CLASS_NAME_STATIC = "modal-static";
var OPEN_SELECTOR$1 = ".modal.show";
var SELECTOR_DIALOG = ".modal-dialog";
var SELECTOR_MODAL_BODY = ".modal-body";
var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
var Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
var DefaultType$6 = {
  backdrop: "(boolean|string)",
  focus: "boolean",
  keyboard: "boolean"
};

class Modal extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper;
    this._addEventListeners();
  }
  static get Default() {
    return Default$6;
  }
  static get DefaultType() {
    return DefaultType$6;
  }
  static get NAME() {
    return NAME$7;
  }
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._isTransitioning = true;
    this._scrollBar.hide();
    document.body.classList.add(CLASS_NAME_OPEN);
    this._adjustDialog();
    this._backdrop.show(() => this._showElement(relatedTarget));
  }
  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._isShown = false;
    this._isTransitioning = true;
    this._focustrap.deactivate();
    this._element.classList.remove(CLASS_NAME_SHOW$4);
    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
  }
  dispose() {
    EventHandler.off(window, EVENT_KEY$4);
    EventHandler.off(this._dialog, EVENT_KEY$4);
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _showElement(relatedTarget) {
    if (!document.body.contains(this._element)) {
      document.body.append(this._element);
    }
    this._element.style.display = "block";
    this._element.removeAttribute("aria-hidden");
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.scrollTop = 0;
    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
    if (modalBody) {
      modalBody.scrollTop = 0;
    }
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW$4);
    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }
      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$4, {
        relatedTarget
      });
    };
    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
      if (event.key !== ESCAPE_KEY$1) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      this._triggerBackdropTransition();
    });
    EventHandler.on(window, EVENT_RESIZE$1, () => {
      if (this._isShown && !this._isTransitioning) {
        this._adjustDialog();
      }
    });
    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
      EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
        if (this._element !== event.target || this._element !== event2.target) {
          return;
        }
        if (this._config.backdrop === "static") {
          this._triggerBackdropTransition();
          return;
        }
        if (this._config.backdrop) {
          this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = "none";
    this._element.setAttribute("aria-hidden", true);
    this._element.removeAttribute("aria-modal");
    this._element.removeAttribute("role");
    this._isTransitioning = false;
    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);
      this._resetAdjustments();
      this._scrollBar.reset();
      EventHandler.trigger(this._element, EVENT_HIDDEN$4);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }
  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const initialOverflowY = this._element.style.overflowY;
    if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
      return;
    }
    if (!isModalOverflowing) {
      this._element.style.overflowY = "hidden";
    }
    this._element.classList.add(CLASS_NAME_STATIC);
    this._queueCallback(() => {
      this._element.classList.remove(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.style.overflowY = initialOverflowY;
      }, this._dialog);
    }, this._dialog);
    this._element.focus();
  }
  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const scrollbarWidth = this._scrollBar.getWidth();
    const isBodyOverflowing = scrollbarWidth > 0;
    if (isBodyOverflowing && !isModalOverflowing) {
      const property = isRTL() ? "paddingLeft" : "paddingRight";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
    if (!isBodyOverflowing && isModalOverflowing) {
      const property = isRTL() ? "paddingRight" : "paddingLeft";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "";
    this._element.style.paddingRight = "";
  }
  static jQueryInterface(config2, relatedTarget) {
    return this.each(function() {
      const data = Modal.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2](relatedTarget);
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
    if (showEvent.defaultPrevented) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$4, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }
  const data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});
enableDismissTrigger(Modal);
defineJQueryPlugin(Modal);
var NAME$6 = "offcanvas";
var DATA_KEY$3 = "bs.offcanvas";
var EVENT_KEY$3 = `.${DATA_KEY$3}`;
var DATA_API_KEY$1 = ".data-api";
var EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
var ESCAPE_KEY = "Escape";
var CLASS_NAME_SHOW$3 = "show";
var CLASS_NAME_SHOWING$1 = "showing";
var CLASS_NAME_HIDING = "hiding";
var CLASS_NAME_BACKDROP = "offcanvas-backdrop";
var OPEN_SELECTOR = ".offcanvas.show";
var EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
var EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
var EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
var EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
var EVENT_RESIZE = `resize${EVENT_KEY$3}`;
var EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
var Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
var DefaultType$5 = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  scroll: "boolean"
};

class Offcanvas extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._addEventListeners();
  }
  static get Default() {
    return Default$5;
  }
  static get DefaultType() {
    return DefaultType$5;
  }
  static get NAME() {
    return NAME$6;
  }
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._backdrop.show();
    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.classList.add(CLASS_NAME_SHOWING$1);
    const completeCallBack = () => {
      if (!this._config.scroll || this._config.backdrop) {
        this._focustrap.activate();
      }
      this._element.classList.add(CLASS_NAME_SHOW$3);
      this._element.classList.remove(CLASS_NAME_SHOWING$1);
      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };
    this._queueCallback(completeCallBack, this._element, true);
  }
  hide() {
    if (!this._isShown) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._focustrap.deactivate();
    this._element.blur();
    this._isShown = false;
    this._element.classList.add(CLASS_NAME_HIDING);
    this._backdrop.hide();
    const completeCallback = () => {
      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }
      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    };
    this._queueCallback(completeCallback, this._element, true);
  }
  dispose() {
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  _initializeBackDrop() {
    const clickCallback = () => {
      if (this._config.backdrop === "static") {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }
      this.hide();
    };
    const isVisible2 = Boolean(this._config.backdrop);
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible: isVisible2,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: isVisible2 ? clickCallback : null
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
      if (event.key !== ESCAPE_KEY) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
    });
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Offcanvas.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (data[config2] === undefined || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2](this);
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  EventHandler.one(target, EVENT_HIDDEN$3, () => {
    if (isVisible(this)) {
      this.focus();
    }
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }
  const data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
    Offcanvas.getOrCreateInstance(selector).show();
  }
});
EventHandler.on(window, EVENT_RESIZE, () => {
  for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
    if (getComputedStyle(element).position !== "fixed") {
      Offcanvas.getOrCreateInstance(element).hide();
    }
  }
});
enableDismissTrigger(Offcanvas);
defineJQueryPlugin(Offcanvas);
var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
var DefaultAllowlist = {
  "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  dd: [],
  div: [],
  dl: [],
  dt: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
var uriAttributes = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
var allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
    }
    return true;
  }
  return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
};
var NAME$5 = "TemplateFactory";
var Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  extraClass: "",
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: "<div></div>"
};
var DefaultType$4 = {
  allowList: "object",
  content: "object",
  extraClass: "(string|function)",
  html: "boolean",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  template: "string"
};
var DefaultContentType = {
  entry: "(string|element|function|null)",
  selector: "(string|element)"
};

class TemplateFactory extends Config2 {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
  }
  static get Default() {
    return Default$4;
  }
  static get DefaultType() {
    return DefaultType$4;
  }
  static get NAME() {
    return NAME$5;
  }
  getContent() {
    return Object.values(this._config.content).map((config2) => this._resolvePossibleFunction(config2)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(content) {
    this._checkContent(content);
    this._config.content = {
      ...this._config.content,
      ...content
    };
    return this;
  }
  toHtml() {
    const templateWrapper = document.createElement("div");
    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
    for (const [selector, text] of Object.entries(this._config.content)) {
      this._setContent(templateWrapper, text, selector);
    }
    const template = templateWrapper.children[0];
    const extraClass = this._resolvePossibleFunction(this._config.extraClass);
    if (extraClass) {
      template.classList.add(...extraClass.split(" "));
    }
    return template;
  }
  _typeCheckConfig(config2) {
    super._typeCheckConfig(config2);
    this._checkContent(config2.content);
  }
  _checkContent(arg) {
    for (const [selector, content] of Object.entries(arg)) {
      super._typeCheckConfig({
        selector,
        entry: content
      }, DefaultContentType);
    }
  }
  _setContent(template, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template);
    if (!templateElement) {
      return;
    }
    content = this._resolvePossibleFunction(content);
    if (!content) {
      templateElement.remove();
      return;
    }
    if (isElement2(content)) {
      this._putElementInTemplate(getElement(content), templateElement);
      return;
    }
    if (this._config.html) {
      templateElement.innerHTML = this._maybeSanitize(content);
      return;
    }
    templateElement.textContent = content;
  }
  _maybeSanitize(arg) {
    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this]);
  }
  _putElementInTemplate(element, templateElement) {
    if (this._config.html) {
      templateElement.innerHTML = "";
      templateElement.append(element);
      return;
    }
    templateElement.textContent = element.textContent;
  }
}
var NAME$4 = "tooltip";
var DISALLOWED_ATTRIBUTES = new Set(["sanitize", "allowList", "sanitizeFn"]);
var CLASS_NAME_FADE$2 = "fade";
var CLASS_NAME_MODAL = "modal";
var CLASS_NAME_SHOW$2 = "show";
var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
var EVENT_MODAL_HIDE = "hide.bs.modal";
var TRIGGER_HOVER = "hover";
var TRIGGER_FOCUS = "focus";
var TRIGGER_CLICK = "click";
var TRIGGER_MANUAL = "manual";
var EVENT_HIDE$2 = "hide";
var EVENT_HIDDEN$2 = "hidden";
var EVENT_SHOW$2 = "show";
var EVENT_SHOWN$2 = "shown";
var EVENT_INSERTED = "inserted";
var EVENT_CLICK$1 = "click";
var EVENT_FOCUSIN$1 = "focusin";
var EVENT_FOCUSOUT$1 = "focusout";
var EVENT_MOUSEENTER = "mouseenter";
var EVENT_MOUSELEAVE = "mouseleave";
var AttachmentMap = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: isRTL() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: isRTL() ? "right" : "left"
};
var Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: "clippingParents",
  container: false,
  customClass: "",
  delay: 0,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  html: false,
  offset: [0, 6],
  placement: "top",
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  title: "",
  trigger: "hover focus"
};
var DefaultType$3 = {
  allowList: "object",
  animation: "boolean",
  boundary: "(string|element)",
  container: "(string|element|boolean)",
  customClass: "(string|function)",
  delay: "(number|object)",
  fallbackPlacements: "array",
  html: "boolean",
  offset: "(array|string|function)",
  placement: "(string|function)",
  popperConfig: "(null|object|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  selector: "(string|boolean)",
  template: "string",
  title: "(string|element|function)",
  trigger: "string"
};

class Tooltip extends BaseComponent {
  constructor(element, config2) {
    if (typeof exports_lib === "undefined") {
      throw new TypeError("Bootstrap\'s tooltips require Popper (https://popper.js.org)");
    }
    super(element, config2);
    this._isEnabled = true;
    this._timeout = 0;
    this._isHovered = null;
    this._activeTrigger = {};
    this._popper = null;
    this._templateFactory = null;
    this._newContent = null;
    this.tip = null;
    this._setListeners();
    if (!this._config.selector) {
      this._fixTitle();
    }
  }
  static get Default() {
    return Default$3;
  }
  static get DefaultType() {
    return DefaultType$3;
  }
  static get NAME() {
    return NAME$4;
  }
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (!this._isEnabled) {
      return;
    }
    this._activeTrigger.click = !this._activeTrigger.click;
    if (this._isShown()) {
      this._leave();
      return;
    }
    this._enter();
  }
  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    if (this._element.getAttribute("data-bs-original-title")) {
      this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
    }
    this._disposePopper();
    super.dispose();
  }
  show() {
    if (this._element.style.display === "none") {
      throw new Error("Please use show on visible elements");
    }
    if (!(this._isWithContent() && this._isEnabled)) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    }
    this._disposePopper();
    const tip = this._getTipElement();
    this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
    const {
      container
    } = this._config;
    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
    }
    this._popper = this._createPopper(tip);
    tip.classList.add(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop);
      }
    }
    const complete = () => {
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
      if (this._isHovered === false) {
        this._leave();
      }
      this._isHovered = false;
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
    if (hideEvent.defaultPrevented) {
      return;
    }
    const tip = this._getTipElement();
    tip.classList.remove(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop);
      }
    }
    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    this._isHovered = null;
    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }
      if (!this._isHovered) {
        this._disposePopper();
      }
      this._element.removeAttribute("aria-describedby");
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  update() {
    if (this._popper) {
      this._popper.update();
    }
  }
  _isWithContent() {
    return Boolean(this._getTitle());
  }
  _getTipElement() {
    if (!this.tip) {
      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
    }
    return this.tip;
  }
  _createTipElement(content) {
    const tip = this._getTemplateFactory(content).toHtml();
    if (!tip) {
      return null;
    }
    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
    tip.classList.add(`bs-${this.constructor.NAME}-auto`);
    const tipId = getUID(this.constructor.NAME).toString();
    tip.setAttribute("id", tipId);
    if (this._isAnimated()) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }
    return tip;
  }
  setContent(content) {
    this._newContent = content;
    if (this._isShown()) {
      this._disposePopper();
      this.show();
    }
  }
  _getTemplateFactory(content) {
    if (this._templateFactory) {
      this._templateFactory.changeContent(content);
    } else {
      this._templateFactory = new TemplateFactory({
        ...this._config,
        content,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      });
    }
    return this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [SELECTOR_TOOLTIP_INNER]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
  }
  _initializeOnDelegatedTarget(event) {
    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
  }
  _createPopper(tip) {
    const placement = execute(this._config.placement, [this, tip, this._element]);
    const attachment = AttachmentMap[placement.toUpperCase()];
    return createPopper5(this._element, tip, this._getPopperConfig(attachment));
  }
  _getOffset() {
    const {
      offset: offset3
    } = this._config;
    if (typeof offset3 === "string") {
      return offset3.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset3 === "function") {
      return (popperData) => offset3(popperData, this._element);
    }
    return offset3;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this._element]);
  }
  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: "flip",
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }, {
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "arrow",
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: "preSetPlacement",
        enabled: true,
        phase: "beforeMain",
        fn: (data) => {
          this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
        }
      }]
    };
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _setListeners() {
    const triggers = this._config.trigger.split(" ");
    for (const trigger of triggers) {
      if (trigger === "click") {
        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context.toggle();
        });
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
        EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
          context._enter();
        });
        EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
          context._leave();
        });
      }
    }
    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };
    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
  }
  _fixTitle() {
    const title = this._element.getAttribute("title");
    if (!title) {
      return;
    }
    if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
      this._element.setAttribute("aria-label", title);
    }
    this._element.setAttribute("data-bs-original-title", title);
    this._element.removeAttribute("title");
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = true;
      return;
    }
    this._isHovered = true;
    this._setTimeout(() => {
      if (this._isHovered) {
        this.show();
      }
    }, this._config.delay.show);
  }
  _leave() {
    if (this._isWithActiveTrigger()) {
      return;
    }
    this._isHovered = false;
    this._setTimeout(() => {
      if (!this._isHovered) {
        this.hide();
      }
    }, this._config.delay.hide);
  }
  _setTimeout(handler, timeout) {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(handler, timeout);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(true);
  }
  _getConfig(config2) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);
    for (const dataAttribute of Object.keys(dataAttributes)) {
      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
        delete dataAttributes[dataAttribute];
      }
    }
    config2 = {
      ...dataAttributes,
      ...typeof config2 === "object" && config2 ? config2 : {}
    };
    config2 = this._mergeConfigObj(config2);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  _configAfterMerge(config2) {
    config2.container = config2.container === false ? document.body : getElement(config2.container);
    if (typeof config2.delay === "number") {
      config2.delay = {
        show: config2.delay,
        hide: config2.delay
      };
    }
    if (typeof config2.title === "number") {
      config2.title = config2.title.toString();
    }
    if (typeof config2.content === "number") {
      config2.content = config2.content.toString();
    }
    return config2;
  }
  _getDelegateConfig() {
    const config2 = {};
    for (const [key, value] of Object.entries(this._config)) {
      if (this.constructor.Default[key] !== value) {
        config2[key] = value;
      }
    }
    config2.selector = false;
    config2.trigger = "manual";
    return config2;
  }
  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
    if (this.tip) {
      this.tip.remove();
      this.tip = null;
    }
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Tooltip.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
}
defineJQueryPlugin(Tooltip);
var NAME$3 = "popover";
var SELECTOR_TITLE = ".popover-header";
var SELECTOR_CONTENT = ".popover-body";
var Default$2 = {
  ...Tooltip.Default,
  content: "",
  offset: [0, 8],
  placement: "right",
  template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  trigger: "click"
};
var DefaultType$2 = {
  ...Tooltip.DefaultType,
  content: "(null|string|element|function)"
};

class Popover extends Tooltip {
  static get Default() {
    return Default$2;
  }
  static get DefaultType() {
    return DefaultType$2;
  }
  static get NAME() {
    return NAME$3;
  }
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }
  _getContentForTemplate() {
    return {
      [SELECTOR_TITLE]: this._getTitle(),
      [SELECTOR_CONTENT]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Popover.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
}
defineJQueryPlugin(Popover);
var NAME$2 = "scrollspy";
var DATA_KEY$2 = "bs.scrollspy";
var EVENT_KEY$2 = `.${DATA_KEY$2}`;
var DATA_API_KEY = ".data-api";
var EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
var EVENT_CLICK = `click${EVENT_KEY$2}`;
var EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
var CLASS_NAME_ACTIVE$1 = "active";
var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
var SELECTOR_TARGET_LINKS = "[href]";
var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
var SELECTOR_NAV_LINKS = ".nav-link";
var SELECTOR_NAV_ITEMS = ".nav-item";
var SELECTOR_LIST_ITEMS = ".list-group-item";
var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
var SELECTOR_DROPDOWN = ".dropdown";
var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
var Default$1 = {
  offset: null,
  rootMargin: "0px 0px -25%",
  smoothScroll: false,
  target: null,
  threshold: [0.1, 0.5, 1]
};
var DefaultType$1 = {
  offset: "(number|null)",
  rootMargin: "string",
  smoothScroll: "boolean",
  target: "element",
  threshold: "array"
};

class ScrollSpy extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._targetLinks = new Map;
    this._observableSections = new Map;
    this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
    this._activeTarget = null;
    this._observer = null;
    this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    this.refresh();
  }
  static get Default() {
    return Default$1;
  }
  static get DefaultType() {
    return DefaultType$1;
  }
  static get NAME() {
    return NAME$2;
  }
  refresh() {
    this._initializeTargetsAndObservables();
    this._maybeEnableSmoothScroll();
    if (this._observer) {
      this._observer.disconnect();
    } else {
      this._observer = this._getNewObserver();
    }
    for (const section of this._observableSections.values()) {
      this._observer.observe(section);
    }
  }
  dispose() {
    this._observer.disconnect();
    super.dispose();
  }
  _configAfterMerge(config2) {
    config2.target = getElement(config2.target) || document.body;
    config2.rootMargin = config2.offset ? `${config2.offset}px 0px -30%` : config2.rootMargin;
    if (typeof config2.threshold === "string") {
      config2.threshold = config2.threshold.split(",").map((value) => Number.parseFloat(value));
    }
    return config2;
  }
  _maybeEnableSmoothScroll() {
    if (!this._config.smoothScroll) {
      return;
    }
    EventHandler.off(this._config.target, EVENT_CLICK);
    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
      const observableSection = this._observableSections.get(event.target.hash);
      if (observableSection) {
        event.preventDefault();
        const root = this._rootElement || window;
        const height = observableSection.offsetTop - this._element.offsetTop;
        if (root.scrollTo) {
          root.scrollTo({
            top: height,
            behavior: "smooth"
          });
          return;
        }
        root.scrollTop = height;
      }
    });
  }
  _getNewObserver() {
    const options = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver((entries) => this._observerCallback(entries), options);
  }
  _observerCallback(entries) {
    const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
    const activate = (entry) => {
      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
      this._process(targetElement(entry));
    };
    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = parentScrollTop;
    for (const entry of entries) {
      if (!entry.isIntersecting) {
        this._activeTarget = null;
        this._clearActiveClass(targetElement(entry));
        continue;
      }
      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      if (userScrollsDown && entryIsLowerThanPrevious) {
        activate(entry);
        if (!parentScrollTop) {
          return;
        }
        continue;
      }
      if (!userScrollsDown && !entryIsLowerThanPrevious) {
        activate(entry);
      }
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = new Map;
    this._observableSections = new Map;
    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
    for (const anchor of targetLinks) {
      if (!anchor.hash || isDisabled(anchor)) {
        continue;
      }
      const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
      if (isVisible(observableSection)) {
        this._targetLinks.set(decodeURI(anchor.hash), anchor);
        this._observableSections.set(anchor.hash, observableSection);
      }
    }
  }
  _process(target) {
    if (this._activeTarget === target) {
      return;
    }
    this._clearActiveClass(this._config.target);
    this._activeTarget = target;
    target.classList.add(CLASS_NAME_ACTIVE$1);
    this._activateParents(target);
    EventHandler.trigger(this._element, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }
  _activateParents(target) {
    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
      return;
    }
    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
        item.classList.add(CLASS_NAME_ACTIVE$1);
      }
    }
  }
  _clearActiveClass(parent) {
    parent.classList.remove(CLASS_NAME_ACTIVE$1);
    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
    for (const node of activeNodes) {
      node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = ScrollSpy.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (data[config2] === undefined || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
}
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
    ScrollSpy.getOrCreateInstance(spy);
  }
});
defineJQueryPlugin(ScrollSpy);
var NAME$1 = "tab";
var DATA_KEY$1 = "bs.tab";
var EVENT_KEY$1 = `.${DATA_KEY$1}`;
var EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
var EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
var EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
var EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
var EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
var EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
var EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
var ARROW_LEFT_KEY = "ArrowLeft";
var ARROW_RIGHT_KEY = "ArrowRight";
var ARROW_UP_KEY = "ArrowUp";
var ARROW_DOWN_KEY = "ArrowDown";
var HOME_KEY = "Home";
var END_KEY = "End";
var CLASS_NAME_ACTIVE = "active";
var CLASS_NAME_FADE$1 = "fade";
var CLASS_NAME_SHOW$1 = "show";
var CLASS_DROPDOWN = "dropdown";
var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
var SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
var NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
var SELECTOR_OUTER = ".nav-item, .list-group-item";
var SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
var SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
var SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;

class Tab extends BaseComponent {
  constructor(element) {
    super(element);
    this._parent = this._element.closest(SELECTOR_TAB_PANEL);
    if (!this._parent) {
      return;
    }
    this._setInitialAttributes(this._parent, this._getChildren());
    EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
  }
  static get NAME() {
    return NAME$1;
  }
  show() {
    const innerElem = this._element;
    if (this._elemIsActive(innerElem)) {
      return;
    }
    const active = this._getActiveElem();
    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
      relatedTarget: innerElem
    }) : null;
    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
      relatedTarget: active
    });
    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
      return;
    }
    this._deactivate(active, innerElem);
    this._activate(innerElem, active);
  }
  _activate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.add(CLASS_NAME_ACTIVE);
    this._activate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.add(CLASS_NAME_SHOW$1);
        return;
      }
      element.removeAttribute("tabindex");
      element.setAttribute("aria-selected", true);
      this._toggleDropDown(element, true);
      EventHandler.trigger(element, EVENT_SHOWN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _deactivate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.remove(CLASS_NAME_ACTIVE);
    element.blur();
    this._deactivate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.remove(CLASS_NAME_SHOW$1);
        return;
      }
      element.setAttribute("aria-selected", false);
      element.setAttribute("tabindex", "-1");
      this._toggleDropDown(element, false);
      EventHandler.trigger(element, EVENT_HIDDEN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _keydown(event) {
    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    const children = this._getChildren().filter((element) => !isDisabled(element));
    let nextActiveElement;
    if ([HOME_KEY, END_KEY].includes(event.key)) {
      nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
    } else {
      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
      nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
    }
    if (nextActiveElement) {
      nextActiveElement.focus({
        preventScroll: true
      });
      Tab.getOrCreateInstance(nextActiveElement).show();
    }
  }
  _getChildren() {
    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find((child) => this._elemIsActive(child)) || null;
  }
  _setInitialAttributes(parent, children) {
    this._setAttributeIfNotExists(parent, "role", "tablist");
    for (const child of children) {
      this._setInitialAttributesOnChild(child);
    }
  }
  _setInitialAttributesOnChild(child) {
    child = this._getInnerElement(child);
    const isActive = this._elemIsActive(child);
    const outerElem = this._getOuterElement(child);
    child.setAttribute("aria-selected", isActive);
    if (outerElem !== child) {
      this._setAttributeIfNotExists(outerElem, "role", "presentation");
    }
    if (!isActive) {
      child.setAttribute("tabindex", "-1");
    }
    this._setAttributeIfNotExists(child, "role", "tab");
    this._setInitialAttributesOnTargetPanel(child);
  }
  _setInitialAttributesOnTargetPanel(child) {
    const target = SelectorEngine.getElementFromSelector(child);
    if (!target) {
      return;
    }
    this._setAttributeIfNotExists(target, "role", "tabpanel");
    if (child.id) {
      this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
    }
  }
  _toggleDropDown(element, open) {
    const outerElem = this._getOuterElement(element);
    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
      return;
    }
    const toggle = (selector, className) => {
      const element2 = SelectorEngine.findOne(selector, outerElem);
      if (element2) {
        element2.classList.toggle(className, open);
      }
    };
    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
    outerElem.setAttribute("aria-expanded", open);
  }
  _setAttributeIfNotExists(element, attribute, value) {
    if (!element.hasAttribute(attribute)) {
      element.setAttribute(attribute, value);
    }
  }
  _elemIsActive(elem) {
    return elem.classList.contains(CLASS_NAME_ACTIVE);
  }
  _getInnerElement(elem) {
    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
  }
  _getOuterElement(elem) {
    return elem.closest(SELECTOR_OUTER) || elem;
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Tab.getOrCreateInstance(this);
      if (typeof config2 !== "string") {
        return;
      }
      if (data[config2] === undefined || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  Tab.getOrCreateInstance(this).show();
});
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
    Tab.getOrCreateInstance(element);
  }
});
defineJQueryPlugin(Tab);
var NAME = "toast";
var DATA_KEY = "bs.toast";
var EVENT_KEY = `.${DATA_KEY}`;
var EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
var EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
var EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
var EVENT_HIDE = `hide${EVENT_KEY}`;
var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
var EVENT_SHOW = `show${EVENT_KEY}`;
var EVENT_SHOWN = `shown${EVENT_KEY}`;
var CLASS_NAME_FADE = "fade";
var CLASS_NAME_HIDE = "hide";
var CLASS_NAME_SHOW = "show";
var CLASS_NAME_SHOWING = "showing";
var DefaultType = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
};
var Default = {
  animation: true,
  autohide: true,
  delay: 5000
};

class Toast extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;
    this._setListeners();
  }
  static get Default() {
    return Default;
  }
  static get DefaultType() {
    return DefaultType;
  }
  static get NAME() {
    return NAME;
  }
  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._clearTimeout();
    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }
    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);
      EventHandler.trigger(this._element, EVENT_SHOWN);
      this._maybeScheduleHide();
    };
    this._element.classList.remove(CLASS_NAME_HIDE);
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE);
      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };
    this._element.classList.add(CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout();
    if (this.isShown()) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }
    super.dispose();
  }
  isShown() {
    return this._element.classList.contains(CLASS_NAME_SHOW);
  }
  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }
    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case "mouseover":
      case "mouseout": {
        this._hasMouseInteraction = isInteracting;
        break;
      }
      case "focusin":
      case "focusout": {
        this._hasKeyboardInteraction = isInteracting;
        break;
      }
    }
    if (isInteracting) {
      this._clearTimeout();
      return;
    }
    const nextElement = event.relatedTarget;
    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }
    this._maybeScheduleHide();
  }
  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
  }
  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  }
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = Toast.getOrCreateInstance(this, config2);
      if (typeof config2 === "string") {
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2](this);
      }
    });
  }
}
enableDismissTrigger(Toast);
defineJQueryPlugin(Toast);

//# debugId=AC2625BB50E985B064756e2164756e21
